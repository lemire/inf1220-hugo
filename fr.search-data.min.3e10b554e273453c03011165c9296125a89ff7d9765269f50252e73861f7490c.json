[{"id":0,"href":"/inf1220-hugo/docs/modules/module3/pasapas/","title":"Java pas à pas","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" Java pas à pas # Nous vous invitons maintenant à lire le chapitre Structures de contrôle (chapitre 3) du manuel Java pas à pas par Robert Godin et Daniel Lemire. Le chapitre comprend plusieurs exemples et exercices. Vous devez compléter les exercices du manuel. Vous pouvez aussi exécuter certains exemples du manuel sur cette page.\nExemplesMath.java public class ExemplesMath { public static void main(String args[]) { System.out.println(\u0026#34;Math.log(1.0)=\u0026#34; \u0026#43; Math.log(1.0)); System.out.println(\u0026#34;Math.exp(1.0)=\u0026#34; \u0026#43; Math.exp(1.0)); System.out.println(\u0026#34;Math.cos(0)=\u0026#34; \u0026#43; Math.cos(0)); System.out.println(\u0026#34;Math.sin(0)=\u0026#34; \u0026#43; Math.sin(0)); System.out.println(\u0026#34;Math.sqrt(4)=\u0026#34; \u0026#43; Math.sqrt(4)); } } Exécuter ExemplesString.java public class ExemplesString { public static void main(String args[]) { String string1 = \u0026#34;abc\u0026#34;; String string2 = \u0026#34;def\u0026#34;; String string3 = \u0026#34;abcdef\u0026#34;; String string4 = new String(\u0026#34;abcdef\u0026#34;); // Tous les litéraux identiques (� la compilation) sont traduits // par une référence au même objet System.out.println(string3 == \u0026#34;abcdef\u0026#34;); // true System.out.println(\u0026#34;abc\u0026#34; \u0026#43; \u0026#34;def\u0026#34; == \u0026#34;abcdef\u0026#34;); // true // Par contre, si le litéral est calculé à l\u0026#39;exécution, ce n\u0026#39;est pas le cas System.out.println(string1 \u0026#43; string2 == \u0026#34;abcdef\u0026#34;); // false // Le constructeur String produit toujours un objet différent de l\u0026#39;objet // correspondant au litéral System.out.println(string4 == \u0026#34;abcdef\u0026#34;); // false // La méthode intern() de la classe String permet de convertir // la référence à l\u0026#39;objet correspondant au litéral System.out.println((string1 \u0026#43; string2).intern() == \u0026#34;abcdef\u0026#34;); // true System.out.println(string4.intern() == \u0026#34;abcdef\u0026#34;); // true // La méthode equals() permet de comparer le contenu de l\u0026#39;objet plutôt que la référence System.out.println((string1 \u0026#43; string2).equals(\u0026#34;abcdef\u0026#34;)); // true System.out.println(string4.equals(\u0026#34;abcdef\u0026#34;)); // true } } Exécuter ExempleZero.java public class ExempleZero { public static void main(String[] s) { double minus_zero = -0.0; double plus_zero = \u0026#43;0.0; System.out.println(minus_zero == plus_zero); System.out.println(1/minus_zero); System.out.println(1/plus_zero); System.out.println(1/minus_zero == 1/plus_zero); double n = 0.0 / 0.0; System.out.println(n); System.out.println(n == n); } } Exécuter ExerciceForFor.java public class ExerciceForFor { public static void main(String args[]) { for (int compteur1 = 1; compteur1 \u0026lt;= 9; compteur1 = compteur1 \u0026#43; 1) { for (int compteur2 = 1; compteur2 \u0026lt;= compteur1; compteur2 = compteur2 \u0026#43; 1) System.out.print(compteur2); System.out.println(); } } } Exécuter Après la lecture du chapitre, répondez aux questions suivantes.\nExpliquez ce qu\u0026rsquo;est la structure de contrôle de type séquence en programmation Java. Donnez un exemple simple de code Java illustrant cette structure et expliquez pourquoi elle est considérée comme la structure de contrôle de base. Décrivez le fonctionnement de la boucle while en Java, en précisant sa syntaxe et les conditions nécessaires pour qu\u0026rsquo;elle s\u0026rsquo;exécute correctement. À l\u0026rsquo;aide d\u0026rsquo;un exemple de code, montrez comment utiliser une boucle while pour afficher les nombres de 1 à 10. Comparez les boucles for et while en termes de structure et d\u0026rsquo;utilisation en Java. Fournissez un exemple de code utilisant une boucle for pour calculer la somme des nombres pairs compris entre 1 et 100, et expliquez pourquoi la boucle for est particulièrement adaptée à ce type de tâche. Expliquez comment la structure if permet de prendre des décisions dans un programme Java. Écrivez un programme simple qui utilise une structure if-else pour déterminer si un nombre saisi par l\u0026rsquo;utilisateur (via la classe Scanner) est Selon le chapitre, pourquoi est-il important de tester et de déboguer un programme Java ? Décrivez une méthode de test que vous pourriez utiliser pour vérifier le bon fonctionnement d\u0026rsquo;une boucle for qui affiche les multiples de 5 jusqu\u0026rsquo;à 50. Expliquez comment vous identifieriez et corrigeriez une erreur si la boucle affichait incorrectement les résultats. Plusieurs étudiants trouvent qu\u0026rsquo;il est plus aisé de faire les lectures dans le manuel Java pas à pas après avoir terminé la lecture du module sur notre site web. Vous pouvez choisir quand il vous convient le mieux d\u0026rsquo;utiliser le manuel Java pas à pas.\nVous avez accès au document PDF. Si vous devez lire un document PDF, nous vous encourageons à charger le fichier sur votre machine et à l\u0026rsquo;ouvrir au sein d\u0026rsquo;un outil dédié (par ex. Adobe Acrobat). Il n\u0026rsquo;est pas très pratique de lire un document PDF au sein d\u0026rsquo;un navigateur web.\nVous pouvez aussi acheter la version papier du manuel Java pas à pas chez Amazon:\n"},{"id":1,"href":"/inf1220-hugo/docs/modules/module4/pasapas/","title":"Java pas à pas","section":"Module 4: Les entrées et sorties","content":" Java pas à pas # Nous vous invitons maintenant à lire le chapitre Traitement de fichiers (chapitre 9) du manuel Java pas à pas par Robert Godin et Daniel Lemire. Le chapitre comprend plusieurs exemples et exercices. Vous devez compléter les exercices du manuel.\nAprès votre lecture du chapitre, répondez aux questions suivantes.\nExpliquez la différence entre un fichier binaire et un fichier texte en Java. À l\u0026rsquo;aide d\u0026rsquo;un exemple de code utilisant les classes FileOutputStream et FileInputStream, montrez comment écrire et lire un entier dans un fichier binaire. Précisez pourquoi il est important de gérer les exceptions dans ce contexte. Décrivez le rôle des classes DataInputStream et DataOutputStream dans le traitement de fichiers binaires en Java. Écrivez un programme simple qui utilise ces classes pour écrire un tableau de doubles dans un fichier binaire, puis le relire et l’afficher à l’écran. Expliquez comment ces classes facilitent la gestion des types de données. Expliquez comment la classe StreamTokenizer peut être utilisée pour effectuer une analyse lexicale d’un fichier texte. Fournissez un exemple de code qui lit un fichier texte contenant des nombres et des mots, et qui utilise StreamTokenizer pour séparer les nombres des chaînes de caractères, en les affichant séparément. Précisez comment configurer les caractères d’espacement (whitespaceChars) et de citation (quoteChar). Décrivez le fonctionnement de la classe JFileChooser pour la sélection de fichiers dans une interface graphique. Écrivez un programme Java qui utilise JFileChooser pour permettre à l’utilisateur de sélectionner un fichier texte, puis affiche son chemin absolu. Expliquez comment cette classe améliore l’expérience utilisateur par rapport à une saisie manuelle du chemin. Expliquez ce qu’est un fichier à adressage relatif et en quoi il diffère d’un fichier sériel en Java. À l’aide d’un exemple de code basé sur la classe RandomAccessFile, montrez comment lire et modifier un enregistrement spécifique dans un fichier contenant des objets Plant (comme dans l’exemple du manuel). Décrivez comment la méthode seek et la gestion des numéros d’enregistrement relatif permettent un accès direct aux données. Plusieurs étudiants trouvent qu\u0026rsquo;il est plus aisé de faire les lectures dans le manuel Java pas à pas après avoir terminé la lecture du module sur notre site web. Vous pouvez choisir quand il vous convient le mieux d\u0026rsquo;utiliser le manuel Java pas à pas.\nVous avez accès au document PDF. Si vous devez lire un document PDF, nous vous encourageons à charger le fichier sur votre machine et à l\u0026rsquo;ouvrir au sein d\u0026rsquo;un outil dédié (par ex. Adobe Acrobat). Il n\u0026rsquo;est pas très pratique de lire un document PDF au sein d\u0026rsquo;un navigateur web.\nVous pouvez aussi acheter la version papier du manuel Java pas à pas chez Amazon:\n"},{"id":2,"href":"/inf1220-hugo/docs/modules/module5/pasapas/","title":"Java pas à pas","section":"Module 5. La programmation orientée objet: héritage et le polymorphisme","content":" Java pas à pas # Nous vous invitons maintenant à lire les chapitres suivants du manuel Java pas à pas par Robert Godin et Daniel Lemire.\nChapitre 5. Graphisme 2D et concepts de programmation objet Chapitre 6. Introduction à l’animation 2D Chapitre 7. Développement de classes : conception objet Chapitre 8. Animation 2D et développement d’un jeu simple Dans ce cours, vous n\u0026rsquo;avez pas à maîtriser la programmation de jeux vidéos et la conception d\u0026rsquo;interfaces graphiques. Le tout est utilisé pour illustrer et motiver les notions du cours. On ne vous demandera pas de programmer un jeu vidéo, mais vous devez comprendre les notions de programmation Java illustrées.\nLes chapitres comprennent plusieurs exemples et exercices. Vous devez compléter les exercices du manuel. Par l\u0026rsquo;entremise de la construction d\u0026rsquo;un jeu, vous pourrez développer une maîtrise des concepts du module.\nAprès votre lecture des chapitres, répondez aux questions suivantes.\nChapitre 5. Graphisme 2D et concepts de programmation objet Comment les classes Graphics et une sous-classe de JFrame sont-elles utilisées pour réaliser des dessins en 2D ? Décrivez les étapes principales pour configurer une fenêtre graphique. Expliquez l’utilité de l’interface MouseListener pour le traitement des événements de souris. Donnez un exemple de méthode de cette interface et son rôle dans une application graphique. Chapitre 6. Introduction à l’animation 2D Quels problèmes peuvent survenir lors d’une première tentative d’animation 2D en Java, et comment la technique du double tampon résout-elle ces problèmes ? Décrivez le rôle d’une boucle d’animation dans un programme Java. Quels éléments doivent être mis à jour à chaque itération pour garantir une animation fluide ? Chapitre 7. Développement de classes : conception objet Pourquoi est-il important de découper un programme en plusieurs classes ? Expliquez comment ce découpage favorise la modularité et la réutilisabilité du code. Comment la création d’une super-classe permet-elle de limiter la répétition de code dans un programme Java ? Fournissez un exemple simple pour illustrer ce concept. Chapitre 8. Animation 2D et développement d’un jeu simple Expliquez comment un Timer est utilisé dans une sous-classe de JPanel pour gérer l’animation dans un jeu simple. Quels sont les avantages de cette approche ? Pourquoi est-il utile d’isoler le monde à animer du mécanisme d’animation ? Décrivez une stratégie pour organiser ces deux aspects dans un jeu. Qu’est-ce qu’une collection générique en Java, et comment peut-elle être utilisée pour gérer les objets d’un jeu, comme des personnages ou des obstacles ? Donnez un exemple concret. Décrivez les étapes principales du développement d’un jeu simple en Java, en mettant l’accent sur la gestion des interactions entre les objets du jeu et l’affichage graphique. Plusieurs étudiants trouvent qu\u0026rsquo;il est plus aisé de faire les lectures dans le manuel Java pas à pas après avoir terminé la lecture du module sur notre site web. Vous pouvez choisir quand il vous convient le mieux d\u0026rsquo;utiliser le manuel Java pas à pas.\nVous avez accès au document PDF. Si vous devez lire un document PDF, nous vous encourageons à charger le fichier sur votre machine et à l\u0026rsquo;ouvrir au sein d\u0026rsquo;un outil dédié (par ex. Adobe Acrobat). Il n\u0026rsquo;est pas très pratique de lire un document PDF au sein d\u0026rsquo;un navigateur web.\nVous pouvez aussi acheter la version papier du manuel Java pas à pas chez Amazon:\n"},{"id":3,"href":"/inf1220-hugo/docs/modules/module5/activite-5-1/","title":"L'héritage, les classes abstraites et les interfaces","section":"Module 5. La programmation orientée objet: héritage et le polymorphisme","content":" L\u0026rsquo;héritage, les classes abstraites et les interfaces # L’héritage, les classes abstraites et les interfaces sont des concepts centraux de la programmation orientée objet en Java. Ils permettent de structurer le code. En utilisant correctement ces idées, on peut rendre les programmes plus modulaires, évolutifs et faciles à maintenir. Comprendre ces notions est essentiel pour concevoir des applications robustes et flexibles.\nL\u0026rsquo;héritage # Après avoir présenté les objets et les classes dans les leçons précédentes, nous abordons ici la notion d'héritage. Cette technique, appliquée à la programmation Java, permet de créer de nouvelles classes fondées sur celles qui existent déjà. Lorsque nous héritons d'une classe, nous réutilisons ses méthodes et champs, auxquels nous pouvons ajouter de nouveaux champs en vue de l'adapter à de nouvelles situations.\nClasse - superclasse - sous-classe # Pour illustrer ce concept, essayons de concevoir un jeu. Tous les jeux ont un nom, un but, un nombre de joueurs requis pour faire une partie, des règles à respecter… Nous pourrions donc envisager de créer une classe Jeu pour représenter les jeux. Toutefois, les règles du jeu Tetris diffèrent de celles de Sudoku, et le nombre de joueurs d'une partie de football n'est pas le même que celui d'une partie de tennis… Supposons que nous implantions une méthode jouer() pour la classe Jeu. Un joueur de tennis ne joue pas de la même façon qu'un joueur de football. Il est par conséquent impossible d'obtenir une implémentation de jouer() qui peut correspondre à tous les jeux.\nL'héritage est un mécanisme qui permet de résoudre ce genre de problème. En fait, nous spécifions dans la classe Jeu, appelée superclasse, l'ensemble des comportements communs à tous les jeux sans fournir une implémentation. Nous créons ensuite des sous-classes qui fournissent pour chaque jeu une implémentation appropriée. D'une manière générale, le format de déclaration d'une sous-classe est le suivant :\npublic class SousClasse extends SuperClasse { // les instructions } Pour signifier l'héritage, nous employons le mot clé extends. Nous créons ainsi une classe qui dérive d'une classe existante, qui portera le nom de superclasse, et la nouvelle classe sera nommée sous-classe.\nVoici maintenant la façon de définir une classe Sudoku qui hérite de la superclasse Jeu :\npublic class Sudoku extends Jeu { // ici nous définissons les champs et les méthodes } Dans l'exemple ci-dessus, la superclasse est la classe Jeu tandis que la sous-classe est la classe Sudoku. La sous-classe hérite automatiquement de tous les champs et de toutes méthodes de la superclasse. Voici quelques principes fondamentaux de l'héritage :\nune sous-classe hérite de tous les membres de la superclasse. Les constructeurs n'étant pas considérés comme étant membres d'une classe, la sous-classe ne peut donc pas hériter des constructeurs de la superclasse; la visibilité (public ou private) de n'importe quels membres de la superclasse est la même dans la sous-classe. Cela voudra dire que si une méthode ou un champ est déclaré private dans la superclasse, la sous-classe ne peut y avoir accès; nous pouvons surcharger une méthode en réutilisant la même signature (nom de méthode et paramètres) et en utilisant l'annotation @override; un autre type, protected, permet de cacher les champs et les méthodes de la superclasse, mais ses membres sont accessibles à la sous-classe; nous pouvons aussi ajouter des méthodes et des champs private et protected à une sous-classe. Prenons un autre exemple. Imaginons une application bancaire avec différents types de comptes : CompteEpargne et CompteCourant. Tous les comptes partagent des propriétés comme le solde et des opérations comme déposer ou retirer de l\u0026rsquo;argent, mais chaque type de compte a des règles spécifiques.\nCompteBancaire.java class CompteBancaire { protected double solde; protected String titulaire; // Constructeur de la classe de base CompteBancaire(String titulaire, double soldeInitial) { this.titulaire = titulaire; this.solde = soldeInitial; } void deposer(double montant) { if (montant \u0026gt; 0) { solde \u0026#43;= montant; System.out.println(\u0026#34;Dépôt de \u0026#34; \u0026#43; montant \u0026#43; \u0026#34;. Nouveau solde : \u0026#34; \u0026#43; solde); } } void retirer(double montant) { if (montant \u0026gt; 0 \u0026\u0026 solde \u0026gt;= montant) { solde -= montant; System.out.println(\u0026#34;Retrait de \u0026#34; \u0026#43; montant \u0026#43; \u0026#34;. Nouveau solde : \u0026#34; \u0026#43; solde); } else { System.out.println(\u0026#34;Retrait impossible.\u0026#34;); } } // Classe statique interne pour CompteEpargne static class CompteEpargne extends CompteBancaire { private double tauxInteret; CompteEpargne(String titulaire, double soldeInitial, double tauxInteret) { super(titulaire, soldeInitial); this.tauxInteret = tauxInteret; } void appliquerInteret() { double interet = solde * tauxInteret / 100; solde \u0026#43;= interet; System.out.println(\u0026#34;Intérêt de \u0026#34; \u0026#43; interet \u0026#43; \u0026#34; appliqué. Nouveau solde : \u0026#34; \u0026#43; solde); } } // Classe statique interne pour CompteCourant static class CompteCourant extends CompteBancaire { private double decouvertAutorise; CompteCourant(String titulaire, double soldeInitial, double decouvertAutorise) { super(titulaire, soldeInitial); this.decouvertAutorise = decouvertAutorise; } @Override void retirer(double montant) { if (montant \u0026gt; 0 \u0026\u0026 solde \u0026#43; decouvertAutorise \u0026gt;= montant) { solde -= montant; System.out.println(\u0026#34;Retrait de \u0026#34; \u0026#43; montant \u0026#43; \u0026#34;. Nouveau solde : \u0026#34; \u0026#43; solde); } else { System.out.println(\u0026#34;Retrait impossible (découvert dépassé).\u0026#34;); } } } public static void main(String[] args) { CompteEpargne epargne = new CompteEpargne(\u0026#34;Alice\u0026#34;, 1000, 2.5); CompteCourant courant = new CompteCourant(\u0026#34;Bob\u0026#34;, 500, 200); epargne.deposer(500); // Dépôt de 500. Nouveau solde : 1500 epargne.appliquerInteret(); // Intérêt de 37.5 appliqué. Nouveau solde : 1537.5 courant.retirer(600); // Retrait de 600. Nouveau solde : -100 courant.retirer(200); // Retrait impossible (découvert dépassé). } } Exécuter Dans cet exemple, le système bancaire est modélisé en une seule classe CompteBancaire qui contient deux classes statiques internes : CompteEpargne et CompteCourant. Ces classes statiques simulent l\u0026rsquo;héritage en étendant la classe englobante CompteBancaire, qui définit les attributs et comportements communs (solde, titulaire, méthodes deposer et retirer). L\u0026rsquo;utilisation de classes statiques internes permet de regrouper toute la logique dans un seul fichier Java, tout en conservant une structure hiérarchique claire. Les classes CompteEpargne et CompteCourant héritent des fonctionnalités de CompteBancaire et ajoutent leurs comportements spécifiques : appliquerInteret pour CompteEpargne et une version redéfinie de retirer pour CompteCourant qui gère un découvert autorisé. Le programme est testé dans une méthode main qui crée des instances des deux types de comptes et montre leur comportement distinct.\nUne classe statique interne est une classe définie à l\u0026rsquo;intérieur d\u0026rsquo;une autre classe et déclarée avec le mot-clé static. Contrairement à une classe interne non statique, elle ne nécessite pas d\u0026rsquo;instance de la classe englobante pour être utilisée, ce qui la rend indépendante et adaptée pour organiser des sous-classes logiquement liées. Le mot-clé @Override est une annotation en Java qui indique qu\u0026rsquo;une méthode dans une sous-classe redéfinit une méthode de la superclasse. Dans l\u0026rsquo;exemple, CompteCourant utilise @Override pour redéfinir retirer, signalant au compilateur que cette méthode remplace celle de CompteBancaire. Cela améliore la lisibilité et permet au compilateur de vérifier que la méthode existe bien dans la superclasse, évitant des erreurs. La logique du code repose sur cette hiérarchie : CompteBancaire fournit une base générique, tandis que CompteEpargne et CompteCourant spécialisent le comportement. Lors de l\u0026rsquo;exécution, CompteEpargne applique des intérêts, et CompteCourant autorise des retraits jusqu\u0026rsquo;à une limite de découvert, démontrant comment l\u0026rsquo;héritage et le polymorphisme (via @Override) permettent des comportements adaptés tout en partageant du code commun.\nSurcharge des méthodes # Si nous déclarons une méthode dans la sous-classe qui a la même signature que celle de la superclasse et qui est public, cette méthode sera dite surchargée. Cette technique permet de modifier une méthode de la superclasse et de l'adapter au besoin de la sous-classe.\nSupposons que nous définissons notre classe Jeu, qui possède une méthode jouer. La superclasse qui représente tous les jeux possibles peut être définie de la manière suivante :\npublic class Jeu { public void jouer() { //... } } Nous pouvons déclarer dans la classe Sudoku, une sous-classe qui hérite de la superclasse Jeu, à laquelle nous appliquons une implémentation de la méthode jouer :\npublic class Sudoku extends Jeu { public void jouer() { System.out.println(\u0026#34;Je viens de commencer le Sudoku niveau 1!\u0026#34;); } } Ici quand nous appelons la méthode jouer avec un objet de la classe Sudoku, le message suivant s'affiche alors :\nJe viens de commencer le Sudoku niveau 1!\nIl faut noter qu'il faut trois conditions avant de réaliser cette opération :\nLa méthode à surcharger doit être définie dans la superclasse; Cette méthode doit être définie public. Nous ne pouvons surcharger une méthode private; La méthode de la sous-classe doit avoir la même signature que celle de la superclasse, c'est-à-dire le même nom et les mêmes types de paramètres. Protection des membres # Nous connaissons déjà les mots clés public et private qui sont utilisés pour indiquer si les membres d'une classe sont visibles ou non à l'extérieur de cette classe. Quand nous héritons d'une classe, tous les membres publics de la superclasse sont visibles pour les sous-classes, mais pas les membres privés. Ces membres privés sont des membres des sous-classes, mais nous ne pouvons pas accéder à ces membres privés directement à partir des sous-classes.\nJava nous fournit une troisième option quant à la visibilité des membres d'une classe. Nous pouvons ainsi créer des membres protégés d'une classe avec le mot clé protected. Ainsi les membres protected de la superclasse sont visibles pour les sous-classes, mais pas pour les autres classes. Considérons l'exemple suivant :\nclass Jeu { private String nomdujeu; protected String getnomdujeu() { return this.nomdujeu; } protected void setnomdujeu(String nom) { this.nomdujeu = nom; } } public class Sudoku extends Jeu { public Sudoku() { setnomdujeu(\u0026#34;Sudoku\u0026#34;); } } Dans l'exemple ci-dessus, les méthodes getnomdujeu et setnomdujeu sont déclarées protected et donc visibles à la sous-classe Sudoku. Ces méthodes sont seulement visibles pour les classes qui héritent de la classe Jeu.\nUtilisation des mots clés this et super dans une sous-classe # En Java, le mot-clé this est une référence à l\u0026rsquo;instance actuelle de la classe dans laquelle il est utilisé. Il sert principalement à lever l\u0026rsquo;ambiguïté entre les variables d\u0026rsquo;instance et les paramètres ou variables locales ayant le même nom. Par exemple, dans un constructeur ou une méthode, si un paramètre porte le même nom qu\u0026rsquo;un attribut de la classe, this permet de spécifier que l\u0026rsquo;on fait référence à l\u0026rsquo;attribut de l\u0026rsquo;instance. De plus, this peut être utilisé pour appeler un autre constructeur de la même classe (via this()) ou pour passer l\u0026rsquo;instance actuelle comme argument à une méthode. Ce mot-clé est essentiel pour écrire un code clair et éviter des erreurs dans la gestion des variables, surtout dans des classes avec de nombreux attributs.\nUn autre usage de this est de renforcer la lisibilité du code en explicitant que l\u0026rsquo;on manipule les membres de l\u0026rsquo;instance courante, même en l\u0026rsquo;absence d\u0026rsquo;ambiguïté. Par exemple, dans une méthode, écrire this.nom = nom; est plus explicite que nom = nom;, car cela indique clairement que l\u0026rsquo;attribut de l\u0026rsquo;instance est modifié. Cependant, this ne peut pas être utilisé dans des contextes statiques (comme les méthodes ou blocs static), car il se réfère à une instance spécifique, et les membres statiques appartiennent à la classe elle-même. Voici un exemple simple illustrant l\u0026rsquo;utilisation de this dans une classe Java pour gérer les attributs et appeler un autre constructeur.\nEtudiant.java class Etudiant { String nom; int age; // Constructeur avec un seul paramètre Etudiant(String nom) { this(nom, 18); // Appelle l\u0026#39;autre constructeur avec un âge par défaut } // Constructeur avec deux paramètres Etudiant(String nom, int age) { this.nom = nom; // Utilise this pour distinguer l\u0026#39;attribut du paramètre this.age = age; } void afficherDetails() { System.out.println(\u0026#34;Nom : \u0026#34; \u0026#43; this.nom \u0026#43; \u0026#34;, Âge : \u0026#34; \u0026#43; this.age); } public static void main(String[] args) { Etudiant etudiant1 = new Etudiant(\u0026#34;Alice\u0026#34;, 20); Etudiant etudiant2 = new Etudiant(\u0026#34;Bob\u0026#34;); etudiant1.afficherDetails(); // Nom : Alice, Âge : 20 etudiant2.afficherDetails(); // Nom : Bob, Âge : 18 } } Exécuter Dans cet exemple, this est utilisé dans le constructeur pour assigner les valeurs des paramètres nom et age aux attributs de l\u0026rsquo;instance, évitant toute confusion. De plus, le constructeur à un seul paramètre utilise this(nom, 18) pour déléguer l\u0026rsquo;initialisation à l\u0026rsquo;autre constructeur, démontrant une autre facette de l\u0026rsquo;utilité de this. La méthode afficherDetails emploie this.nom pour accéder à l\u0026rsquo;attribut, bien que ce ne soit pas strictement nécessaire ici, afin d\u0026rsquo;améliorer la clarté du code.\nAinsi le mot clé this sert à nous référer à une instance courante de l\u0026rsquo;objet comme dans l\u0026rsquo;exemple ci-dessous.\npublic class Sudoku { private int difficulte; public void setDifficulte(int diff) { this.difficulte = diff; } } Quand nous voulons nous référer à un champ ou à une méthode qui appartient à une classe de base, nous utilisons le mot clé super. Cela fonctionne de la même façon qu'avec this, mais super renvoie à une instance de la classe de base au lieu de celle de la classe courante.\nConsidérons les deux classes suivantes :\nclass Jeu { public void choixDeJeu() { System.out.println(\u0026#34; Niveau expert!\u0026#34;); } } public class Sudoku extends Jeu { public void choixDeJeu() { System.out.println(\u0026#34;je joue au Sudoku :\u0026#34;); super.choixDeJeu(); } } Après l'exécution de ce programme, nous aurons :\nje joue au Sudoku :\nNiveau expert\nAinsi, avec le mot clé super, nous appelons la méthode choixdejeu de la classe de base. Nous pouvons aussi utiliser ce mot clé dans un constructeur.\nConstructeur d\u0026rsquo;une classe héritée # Le constructeur de la classe dérivée (ou héritée) fait appel au constructeur de la superclasse au moment de la création d\u0026rsquo;un objet. (Le Sudoku est avant tout un jeu.) Cet appel au constructeur de la superclasse peut être implicite ou explicite. Dans ce dernier cas, le constructeur de la classe héritée exécutera la première instruction.\nclass Jeu { String nom; String description; String but; Jeu(String nom, String description, String but) { this.nom = nom; this.description = description; this.but = but; } } public class Sudoku extends Jeu { public Sudoku(String nom, String description, String but) { super(nom, description, but); } } Cet exemple montre comment appeler le constructeur de la superclasse.\nClasses abstraites # Les classes abstraites permettent de créer des concepts de haut-niveau, ne pouvant être instanciés et rendant obligatoire la conception de sous-classes pour leur utilisation. Les classes abstraites sont donc souvent utilisées dans des API ou autres bibliothèques de code. Afin de rendre possible la redéfinition de méthode par héritage, les méthodes d'une superclasse doivent être déclarées avec le modificateur abstract. Ainsi, une classe abstraite est une classe qui contient des méthodes abstraites. L'intérêt de ceci est de rendre la classe « héritable ». La sous-classe peut implémenter ou non les méthodes abstraites héritées. Si elles ne les implémentent pas, elle est elle-même une classe abstraite. Une sous-classe dérivant d'une classe non abstraite peut définir des nouvelles méthodes abstraites, et par le fait même, devenir à leur tour abstraite.\nRemarque : Nous ne pouvons instancier des objets d'une classe abstraite. Ce sont des classes qui sont destinées à subir le processus d'héritage.\nObject # La classe Object est la superclasse de toutes les classes en Java. Cela signifie que chaque classe, même si elle n’hérite pas explicitement d’une autre classe, hérite automatiquement de Object. Cette classe fournit des méthodes fondamentales que tous les objets Java possèdent, comme toString() (pour obtenir une représentation textuelle de l’objet), equals() (pour comparer deux objets), et hashCode() (pour obtenir un code de hachage). Grâce à cette hiérarchie, il est possible de manipuler des collections d’objets de types variés, d’utiliser des tableaux de type Object[], ou de passer n’importe quel objet à des méthodes qui attendent un paramètre de type Object.\nComprendre le rôle de Object est essentiel pour maîtriser l’héritage, le polymorphisme et la gestion des collections en Java. Par exemple, lorsqu’on utilise des structures de données génériques ou qu’on souhaite sérialiser des objets, la connaissance des méthodes héritées de Object permet d’écrire du code plus flexible et réutilisable. Il est aussi courant de redéfinir certaines de ces méthodes dans ses propres classes pour adapter leur comportement aux besoins spécifiques de l’application.\nUtilisation du modificateur final # Il arrive que nous ne souhaitions pas offrir une possibilité d'héritage à une certaine classe. Dans ce cas, nous la définissons avec le mot clé final. Si le mot clé final est utilisé dans la définition d'une méthode, celle-ci ne pourra plus être redéfinie par héritage. Enfin, nous définissons une constante en écrivant final dans la déclaration de la variable. Voici un exemple d'utilisation d'une classe abstraite. Ici, la méthode analyse est abstraite et oblige donc les sous-classes à implémenter celle-ci :\npublic abstract class AlgorithmeIA { Object[] data = null; public AlgorithmeIA(Object[] data) { this.data = data; } public abstract Object[] analyse(); } public class FastDynamicTimeWarping extends AlgorithmeIA { public FastDynamicTimeWarping(Object[] data) { super(data); } // Implementation de la méthode abstraite de AlgorithmeIA @Override public Object[] analyse() { //Ajouter le code pour le traitement FDTW return null; } } Classes scellées # Les classes scellées permettent de contrôler précisément quelles classes peuvent étendre une classe ou implémenter une interface. Voici deux exemples concrets pour illustrer leur utilisation.\nExemple 1 : hiérarchie de formes géométriques # Dans cet exemple, une classe abstraite Forme est scellée et ne peut être étendue que par Cercle, Rectangle et Triangle.\npublic abstract sealed class Forme permits Cercle, Rectangle, Triangle { public abstract double calculerAire(); } public final class Cercle extends Forme { private final double rayon; public Cercle(double rayon) { this.rayon = rayon; } @Override public double calculerAire() { return Math.PI * rayon * rayon; } } public final class Rectangle extends Forme { private final double longueur; private final double largeur; public Rectangle(double longueur, double largeur) { this.longueur = longueur; this.largeur = largeur; } @Override public double calculerAire() { return longueur * largeur; } } public non-sealed class Triangle extends Forme { private final double base; private final double hauteur; public Triangle(double base, double hauteur) { this.base = base; this.hauteur = hauteur; } @Override public double calculerAire() { return (base * hauteur) / 2; } } Exemple 2 : interface scellée pour types de véhicules # public sealed interface Vehicule permits Voiture, Moto { String getType(); } public final class Voiture implements Vehicule { @Override public String getType() { return \u0026#34;Voiture\u0026#34;; } } public final class Moto implements Vehicule { @Override public String getType() { return \u0026#34;Moto\u0026#34;; } } public class TestVehicule { public static void main(String[] args) { Vehicule voiture = new Voiture(); Vehicule moto = new Moto(); System.out.println(voiture.getType()); // Affiche : Voiture System.out.println(moto.getType()); // Affiche : Moto } } Et voici une variante avec les classes statiques.\nVehiculeSystem.java class VehiculeSystem { // Interface statique interne static interface Vehicule { String getType(); } // Classe statique interne Voiture static class Voiture implements Vehicule { @Override public String getType() { return \u0026#34;Voiture\u0026#34;; } } // Classe statique interne Moto static class Moto implements Vehicule { @Override public String getType() { return \u0026#34;Moto\u0026#34;; } } // Méthode main pour tester public static void main(String[] args) { Vehicule voiture = new Voiture(); Vehicule moto = new Moto(); System.out.println(voiture.getType()); // Affiche : Voiture System.out.println(moto.getType()); // Affiche : Moto } } Exécuter Héritage multiple # L’héritage multiple, qui permet à une classe d’hériter de plusieurs classes parentes, est une fonctionnalité disponible dans certains langages comme C++, mais absente en Java pour des raisons de simplicité et de sécurité. En Java, une classe ne peut étendre qu’une seule classe (héritage simple), ce qui évite des complexités et des ambiguïtés potentielles, notamment le problème du diamant.\nLe problème du diamant est une ambiguïté classique liée à l’héritage multiple, qui explique en partie pourquoi Java l’évite. Imaginons une classe D qui hérite de deux classes B et C, elles-mêmes héritant d’une classe commune A. Si A définit une méthode m(), et que B et C la redéfinissent différemment, quelle version de m() D doit-elle hériter ? Cette situation, appelée problème du diamant en raison de la forme en losange de la hiérarchie (A au sommet, B et C au milieu, D en bas), peut créer des conflits difficiles à résoudre. En C++, des mécanismes comme les classes virtuelles permettent de gérer ce problème, mais ils ajoutent de la complexité. Java évite cela en interdisant l’héritage multiple pour les classes, obligeant les développeurs à utiliser une hiérarchie claire et linéaire.\nPour contourner l’absence d’héritage multiple, Java propose des interfaces, qui peuvent être implémentées en nombre illimité par une classe, et la composition, où une classe inclut des instances d’autres classes pour réutiliser leurs fonctionnalités. Par exemple, une classe VehiculeAmphibie qui doit combiner les comportements d’un Bateau et d’une Voiture peut implémenter les interfaces Navigable et Roulable, chacune définissant des méthodes spécifiques. Si des attributs ou des méthodes communes sont nécessaires, la composition (inclure un Bateau et une Voiture comme attributs) est préférable à l’héritage. Cette approche, combinée aux méthodes par défaut des interfaces (depuis Java 8), permet de simuler les avantages de l’héritage multiple sans les inconvénients du problème du diamant, tout en gardant le code modulaire et maintenable.\nEn pratique, il est presque toujours préférable d\u0026rsquo;utiliser les interfaces plutôt que l\u0026rsquo;héritage.\nLes interfaces # En Java, une interface est un contrat qui définit un ensemble de méthodes abstraites (et parfois des méthodes par défaut ou statiques) qu’une classe doit implémenter. Contrairement à l’héritage, où une classe hérite directement des attributs et méthodes d’une superclasse, une interface se concentre sur ce qu’une classe doit faire, sans imposer comment elle le fait. Cela en fait une alternative pragmatique à l’héritage, car les interfaces permettent une flexibilité accrue, évitent les problèmes de l’héritage multiple (non supporté en Java pour les classes) et favorisent une conception modulaire. Une classe peut implémenter plusieurs interfaces, ce qui permet de combiner des comportements variés sans créer une hiérarchie rigide. De plus, les interfaces sont idéales pour définir des comportements standardisés (comme trier ou comparer) utilisés dans des contextes génériques, rendant le code plus réutilisable et maintenable.\nL’héritage est utile pour modéliser des relations « est-un » (par exemple, un Chat est un Animal), mais il peut devenir lourd si la hiérarchie devient complexe ou si une classe doit combiner des comportements de plusieurs sources. Les interfaces, en revanche, modélisent des capacités ou des rôles (« peut-faire »), comme « comparable » ou « sérialisable ». Elles sont particulièrement adaptées aux bibliothèques Java standard, où des interfaces comme Comparable, Comparator, Runnable ou Serializable définissent des comportements que de nombreuses classes peuvent adopter. Voici des exemples concrets d’interfaces courantes en Java, avec du code pour illustrer leur utilité.\nL’interface Comparable est utilisée pour définir un ordre naturel pour les objets d’une classe, souvent pour le tri. Une classe qui implémente Comparable doit fournir la méthode compareTo, qui compare l’objet courant à un autre. Voici un exemple.\nEtudiant.java class Etudiant implements Comparable\u0026lt;Etudiant\u0026gt; { private String nom; private int age; Etudiant(String nom, int age) { this.nom = nom; this.age = age; } @Override public int compareTo(Etudiant autre) { return Integer.compare(this.age, autre.age); // Tri par âge } @Override public String toString() { return nom \u0026#43; \u0026#34; (\u0026#34; \u0026#43; age \u0026#43; \u0026#34;)\u0026#34;; } public static void main(String[] args) { Etudiant[] etudiants = { new Etudiant(\u0026#34;Alice\u0026#34;, 20), new Etudiant(\u0026#34;Bob\u0026#34;, 18), new Etudiant(\u0026#34;Charlie\u0026#34;, 22) }; java.util.Arrays.sort(etudiants); // Trie grâce à compareTo for (Etudiant e : etudiants) { System.out.println(e); } } } Exécuter En implémentant Comparable, la classe Etudiant définit un ordre naturel (ici, par âge). Cela permet d’utiliser des méthodes comme Arrays.sort ou Collections.sort sans code supplémentaire. Contrairement à l’héritage, où une classe de base pourrait imposer une structure rigide, Comparable ajoute une capacité de tri sans affecter la hiérarchie de la classe.\nL’interface Comparator permet de définir des ordres de tri personnalisés, indépendamment de l’ordre naturel défini par Comparable. Elle est utile lorsque vous voulez trier des objets de différentes manières sans modifier leur classe.\nEtudiant.java import java.util.Arrays; import java.util.Comparator; public class Etudiant { private String nom; private int age; public Etudiant(String nom, int age) { this.nom = nom; this.age = age; } public String getNom() { return nom; } public int getAge() { return age; } @Override public String toString() { return nom \u0026#43; \u0026#34; (\u0026#34; \u0026#43; age \u0026#43; \u0026#34;)\u0026#34;; } private static class ComparateurParNom implements Comparator\u0026lt;Etudiant\u0026gt; { @Override public int compare(Etudiant e1, Etudiant e2) { return e1.getNom().compareTo(e2.getNom()); } } public static void main(String[] args) { Etudiant[] etudiants = { new Etudiant(\u0026#34;Charlie\u0026#34;, 22), new Etudiant(\u0026#34;Alice\u0026#34;, 20), new Etudiant(\u0026#34;Bob\u0026#34;, 18) }; Arrays.sort(etudiants, new ComparateurParNom()); for (Etudiant e : etudiants) { System.out.println(e); } } } Exécuter Ici, Comparator permet de trier les Etudiant par nom sans modifier la classe Etudiant. Cela illustre la flexibilité des interfaces : au lieu d’hériter d’une classe de base avec une méthode de tri fixe, on définit un comparateur externe. Cela est particulièrement utile pour des tris multiples (par nom, âge, etc.) ou pour des classes que vous ne pouvez pas modifier.\nL’interface CharSequence est un exemple emblématique de la bibliothèque Java standard. Elle représente une séquence de caractères et est utilisée par des classes comme String, StringBuilder ou StringBuffer. Cette interface définit des méthodes pour accéder à une séquence de caractères de manière standardisée, sans imposer de structure interne. Les méthodes principales sont length(), charAt(int index), subSequence(int start, int end) et toString(). Cela permet à des classes variées de fournir un accès uniforme à leurs données sous forme de caractères, facilitant leur utilisation dans des API génériques, comme les expressions régulières ou les manipulations de texte. Pour illustrer, voici une implémentation personnalisée de CharSequence qui représente une séquence de caractères inversée, utile par exemple pour des opérations où l’ordre des caractères doit être retourné.\npublic class ReverseCharSequence implements CharSequence { private final String sequence; public ReverseCharSequence(String sequence) { this.sequence = sequence; } @Override public int length() { return sequence.length(); } @Override public char charAt(int index) { return sequence.charAt(sequence.length() - 1 - index); } @Override public CharSequence subSequence(int start, int end) { if (start \u0026lt; 0 || end \u0026gt; length() || start \u0026gt; end) { throw new IndexOutOfBoundsException(); } StringBuilder sub = new StringBuilder(); for (int i = start; i \u0026lt; end; i++) { sub.append(charAt(i)); } return new ReverseCharSequence(sub.toString()); } @Override public String toString() { return new StringBuilder(this).toString(); } } L’interface Serializable est une interface marqueur (sans méthode) qui indique qu’une classe peut être sérialisée, c’est-à-dire convertie en un flux d’octets pour être sauvegardée ou transmise.\nProduit.java import java.io.*; class Produit implements Serializable { private String nom; private double prix; Produit(String nom, double prix) { this.nom = nom; this.prix = prix; } @Override public String toString() { return \u0026#34;Produit : \u0026#34; \u0026#43; nom \u0026#43; \u0026#34;, Prix : \u0026#34; \u0026#43; prix; } public static void main(String[] args) { Produit produit = new Produit(\u0026#34;Ordinateur\u0026#34;, 999.99); // Sérialisation try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;produit.ser\u0026#34;))) { oos.writeObject(produit); System.out.println(\u0026#34;Produit sérialisé.\u0026#34;); } catch (IOException e) { e.printStackTrace(); } // Désérialisation try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;produit.ser\u0026#34;))) { Produit produitDeserialise = (Produit) ois.readObject(); System.out.println(\u0026#34;Produit désérialisé : \u0026#34; \u0026#43; produitDeserialise); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } } Exécuter L\u0026rsquo;interface Serializable en Java est une interface marqueur, c\u0026rsquo;est-à-dire qu\u0026rsquo;elle ne définit aucune méthode, mais indique que les objets d\u0026rsquo;une classe peuvent être sérialisés, c\u0026rsquo;est-à-dire convertis en un flux de données (par exemple, pour être sauvegardés dans un fichier ou transmis via un réseau). Lorsqu\u0026rsquo;une classe implémente Serializable, le mécanisme de sérialisation de Java peut automatiquement sauvegarder l\u0026rsquo;état de ses champs non transitoires et non statiques. Cela est particulièrement utile dans des contextes comme la persistance d\u0026rsquo;objets ou la communication entre applications. Pour une gestion fine, les développeurs peuvent personnaliser le processus avec les méthodes writeObject et readObject ou utiliser l\u0026rsquo;attribut serialVersionUID pour assurer la compatibilité entre différentes versions d\u0026rsquo;une classe.\nEn Java, une interface peut inclure des méthodes statiques (depuis Java 8) et des champs statiques (qui sont implicitement public, static, et final, donc des constantes). Les méthodes statiques dans une interface sont utiles pour fournir des utilitaires liés au contrat de l’interface, tandis que les champs statiques définissent des valeurs constantes partagées par toutes les implémentations. Voici un exemple concret d’interface avec une méthode statique et un champ statique, suivi d’un exemple d’utilisation.\ninterface GestionStock { // Champ statique (constante) double TAXE_VENTE = 0.20; // 20% de taxe sur les ventes // Méthode abstraite à implémenter double calculerValeurStock(int quantite, double prixUnitaire); // Méthode statique pour calculer le prix avec taxe static double calculerPrixAvecTaxe(double prix) { return prix * (1 + TAXE_VENTE); } } class Produit implements GestionStock { private String nom; Produit(String nom) { this.nom = nom; } @Override public double calculerValeurStock(int quantite, double prixUnitaire) { return quantite * prixUnitaire; } public String getNom() { return nom; } } class TestGestionStock { public static void main(String[] args) { Produit produit = new Produit(\u0026#34;Ordinateur\u0026#34;); int quantite = 10; double prixUnitaire = 1000.0; // Calcul de la valeur du stock double valeurStock = produit.calculerValeurStock(quantite, prixUnitaire); System.out.println(\u0026#34;Valeur du stock de \u0026#34; + produit.getNom() + \u0026#34; : \u0026#34; + valeurStock); // Utilisation de la méthode statique et du champ statique double prixAvecTaxe = GestionStock.calculerPrixAvecTaxe(prixUnitaire); System.out.println(\u0026#34;Prix unitaire avec taxe (\u0026#34; + (GestionStock.TAXE_VENTE * 100) + \u0026#34;%) : \u0026#34; + prixAvecTaxe); } } Instanciation anonyme # L’instanciation anonyme consiste à créer une instance d’une classe ou d’une interface sans lui donner de nom explicite, généralement pour une utilisation ponctuelle. En Java, cela sert souvent à fournir rapidement une implémentation d’une interface ou à redéfinir une méthode d’une classe abstraite, sans devoir écrire une classe séparée. Cette technique est très utilisée pour les interfaces fonctionnelles, comme ActionListener ou Comparator, notamment dans la programmation événementielle ou pour trier des collections.\nL’avantage principal de l’instanciation anonyme est de rendre le code plus concis et lisible, surtout lorsqu’on n’a besoin de l’implémentation qu’à un seul endroit du programme. Cela évite de créer des classes supplémentaires inutiles et permet de garder le code lié à son contexte d’utilisation.\nList\u0026lt;Integer\u0026gt; liste = Arrays.asList(5, 2, 9, 1); Collections.sort(liste, new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer a, Integer b) { return b - a; // ordre décroissant } }); System.out.println(liste); // Affiche [9, 5, 2, 1] Dans cet exemple, on crée un Comparator anonyme directement dans l’appel à Collections.sort, ce qui rend le code plus compact et facile à comprendre.\nPrincipe de substitution de Liskov # Le principe de substitution de Liskov (Liskov Substitution Principle, LSP) est un principe fondamental de la programmation orientée objet. Il stipule que toute classe dérivée (sous-classe) doit pouvoir être utilisée à la place de sa classe de base (super-classe) sans que cela ne provoque d’erreur ou de comportement inattendu. Autrement dit, un objet d’une sous-classe doit pouvoir remplacer un objet de la super-classe partout où celui-ci est attendu, et le programme doit continuer à fonctionner correctement.\nCe principe garantit la cohérence et la robustesse du code lors de l’utilisation de l’héritage et du polymorphisme.\nExemple en Java :\nclass Animal { public void crier() { System.out.println(\u0026#34;Un animal fait un bruit.\u0026#34;); } } class Chien extends Animal { @Override public void crier() { System.out.println(\u0026#34;Le chien aboie.\u0026#34;); } } public class TestLiskov { public static void faireCrier(Animal a) { a.crier(); } public static void main(String[] args) { Animal animal = new Animal(); Chien chien = new Chien(); faireCrier(animal); // Affiche : Un animal fait un bruit. faireCrier(chien); // Affiche : Le chien aboie. } } Ici, la méthode faireCrier accepte un Animal : on peut lui passer un Chien sans problème, car Chien respecte le contrat d’Animal. C’est le principe de substitution de Liskov.\nProtection des données héritées # Les trois modificateurs de portée qui réalisent l'encapsulation jouent simultanément un rôle dans la protection des données.\nModificateur Rôles private C\u0026rsquo;est le niveau de protection le plus fort. Les composants ne sont visibles qu\u0026rsquo;à l\u0026rsquo;intérieur de la classe : ils ne peuvent être modifiés que par des méthodes définies dans la classe prévues à cet effet. Les méthodes déclarées private ne peuvent pas être en même temps déclarée abstract, car elles ne peuvent pas être redéfinies dans les classes filles. protected Si une méthode ou une variable est déclarée protected, seules les méthodes présentes dans le même package que cette classe ou de ses sous-classes pourront y accéder. public Ce modificateur stipule que la variable ou la méthode est visible par tous les autres objets. Lorsqu\u0026rsquo;un membre de la classe n\u0026rsquo;est précédé d\u0026rsquo;aucun modificateur, il est accessible à toutes les classes du même package que la classe qui le définit. Différence entre types primitifs et objets # En Java, il existe deux grandes catégories de types : les types primitifs (comme int, double, char, boolean, etc.) et les types objets (toutes les classes, y compris String, Integer, et toute classe que vous définissez). Les types primitifs représentent des valeurs simples et ne sont pas des objets : ils ne possèdent pas de méthodes et sont stockés directement en mémoire. Par exemple, une variable int contient directement la valeur numérique. À l’inverse, les objets sont des instances de classes, stockées sous forme de références (pointeurs) en mémoire. Une variable de type objet ne contient pas l’objet lui-même, mais une référence vers celui-ci. Cela a des conséquences sur la manipulation, la comparaison et la gestion de la mémoire. Par exemple, les collections Java (ArrayList, etc.) ne peuvent contenir que des objets, pas des types primitifs : il faut alors utiliser les classes enveloppes (Integer pour int, Double pour double, etc.).\nDifférence entre == et equals # En Java, l’opérateur == compare les références pour les objets, c’est-à-dire s’il s’agit exactement du même objet en mémoire. Pour les types primitifs, == compare directement les valeurs (par exemple, 3 == 3 est vrai). Pour les objets, == ne compare pas le contenu, mais l’adresse mémoire. Pour comparer le contenu de deux objets, il faut utiliser la méthode equals(), qui peut être redéfinie dans chaque classe pour définir ce que signifie « égalité » pour ce type d’objet.\nPrenons l’exemple d’une classe Point :\nclass Point { int x, y; Point(int x, int y) { this.x = x; this.y = y; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Point other = (Point) obj; return x == other.x \u0026amp;\u0026amp; y == other.y; } } Point p1 = new Point(1, 2); Point p2 = new Point(1, 2); System.out.println(p1 == p2); // false (références différentes) System.out.println(p1.equals(p2)); // true (contenu identique) Ici, p1 et p2 sont deux objets différents en mémoire, donc p1 == p2 est faux. Mais comme ils ont les mêmes coordonnées et que la méthode equals a été redéfinie, p1.equals(p2) est vrai.\nÀ propos des records :\nDepuis Java 16, les records simplifient la création de classes immuables destinées à contenir des données. Un record déclare automatiquement les méthodes equals(), hashCode() et toString() en fonction de ses composants. Ainsi, deux records avec les mêmes valeurs sont considérés comme égaux avec equals, et leur hashCode est cohérent avec leur contenu, sans avoir à redéfinir ces méthodes manuellement.\nExemple :\nrecord Point(int x, int y) {} Point p1 = new Point(1, 2); Point p2 = new Point(1, 2); System.out.println(p1.equals(p2)); // true System.out.println(p1.hashCode() == p2.hashCode()); // true hashCode et son utilisation # La méthode hashCode() est définie dans la classe Object et doit être redéfinie dans toute classe dont les instances seront utilisées comme clés dans des structures de données comme les tables de hachage (HashMap, HashSet). Le code de hachage est un entier calculé à partir du contenu de l’objet, permettant de répartir efficacement les objets dans des « buckets » pour accélérer la recherche. La règle fondamentale est : si deux objets sont égaux selon equals(), ils doivent avoir le même hashCode(). En revanche, deux objets avec le même hashCode() ne sont pas forcément égaux. Si vous redéfinissez equals(), il est donc essentiel de redéfinir aussi hashCode() pour garantir le bon fonctionnement des collections basées sur le hachage.\nExemple :\n@Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; MaClasse autre = (MaClasse) obj; return this.champ == autre.champ; } @Override public int hashCode() { return Objects.hash(champ); } Les classes enveloppes # En Java, les types primitifs (int, double, char, etc.) ne sont pas des objets et ne possèdent donc pas de méthodes. Pour pouvoir manipuler ces valeurs comme des objets (par exemple, dans les collections comme ArrayList), Java fournit des classes enveloppes (wrapper classes) pour chaque type primitif : Integer pour int, Double pour double, Character pour char, etc. Ces classes permettent d’encapsuler une valeur primitive dans un objet et offrent des méthodes utilitaires (conversion, comparaison, parsing, etc.).\nPar exemple :\nint a = 5; Integer b = Integer.valueOf(a); // Conversion d\u0026#39;un int en Integer ArrayList\u0026lt;Integer\u0026gt; liste = new ArrayList\u0026lt;\u0026gt;(); liste.add(a); // Autoboxing automatique Depuis Java 5, l’autoboxing et l’unboxing permettent de convertir automatiquement entre types primitifs et classes enveloppes :\nAutoboxing : conversion automatique d’un type primitif vers sa classe enveloppe (int → Integer) Unboxing : conversion automatique d’une classe enveloppe vers son type primitif (Integer → int) Les classes enveloppes sont aussi utiles pour utiliser les méthodes equals() et hashCode() sur des valeurs numériques, ou pour gérer la valeur spéciale null (impossible avec un type primitif).\nRésumé des principales classes enveloppes :\nType primitif Classe enveloppe boolean Boolean byte Byte char Character short Short int Integer long Long float Float double Double Dans l\u0026rsquo;API Stream, la méthode boxed() permet de convertir un stream de types primitifs (comme IntStream, DoubleStream, etc.) en un stream d’objets correspondants (par exemple, de int vers Integer). Cela est nécessaire car de nombreuses méthodes de l’API Stream, comme collect, map, ou encore l’utilisation de collections (List, Set, etc.), attendent des objets et non des types primitifs. Par exemple, un IntStream ne peut pas être directement collecté dans une List\u0026lt;Integer\u0026gt; sans conversion, car une liste Java ne peut contenir que des objets. De plus, certaines opérations comme le tri personnalisé, l’utilisation de méthodes d’instance (par exemple, Integer::compareTo), ou l’application de méthodes génériques sur des streams nécessitent de manipuler des objets. La méthode boxed() effectue donc automatiquement l’autoboxing de chaque valeur primitive du stream, rendant possible l’utilisation de toute la richesse de l’API des objets Java.\nExemple :\nint[] tab = {1, 2, 3, 4}; List\u0026lt;Integer\u0026gt; liste = Arrays.stream(tab) .boxed() // Convertit chaque int en Integer .collect(Collectors.toList()); System.out.println(liste); // Affiche [1, 2, 3, 4] Lecture optionnelle dans le livre de référence (Delannoy) # Pour aller plus en profondeur (optionnel), vous pouvez lire dans Programmer en Java de Claude Delannoy, Chapitre 8:\nSection 1 à 5 Section 8 : Les membres protégés Section 10 : Classes et méthodes finales Section 11 : Les classes abstraites Section 12 : Les interfaces Vidéos # Il y a une liste de vidéos sur l'héritage par Sam et al. "},{"id":4,"href":"/inf1220-hugo/docs/extra/credits/","title":"Le professeur","section":"Autres ressources","content":" Le professeur # Daniel Lemire est professeur d\u0026rsquo;informatique à l\u0026rsquo;Université du Québec (TELUQ). Il est classé dans les 2 % des meilleurs scientifiques (classement Stanford University/Elsevier, 2024). Il fait partie des 1000 programmeurs les plus suivis au monde sur GitHub; GitHub compte plus de 100 millions de développeurs. Il a publié plus de 85 articles de recherche évalués par des pairs. Ses travaux se retrouvent dans de nombreuses bibliothèques standard (.NET, Rust, GCC/glibc++, LLVM/libc, Go, Node.js, etc.) et dans les principaux navigateurs web (Safari, Chrome, etc.). Il est rédacteur de la revue Software : Practice and Experience (Wiley, créée en 1971). En 2020, il a reçu le Prix d\u0026rsquo;excellence 2020 de l\u0026rsquo;Université du Québec pour ses travaux sur l\u0026rsquo;accélération de l\u0026rsquo;analyse JSON. Ses recherches portent notamment sur la programmation haute performance. Il est @lemire sur X et tient un blog hebdomadaire à l\u0026rsquo;adresse https://lemire.me/blog. On peut aussi le trouver sur GitHub.\nLes géants du numérique raffolent des algorithmes de ce prof québécois, Journal de Montréal, octobre 2024 Le professeur Daniel Lemire de l\u0026rsquo;Université TÉLUQ parmi les chercheurs les plus cités au monde Manuels # Java pas à pas # Programmation avec Python: des jeux au Web # La science des données: Théorie et applications avec R et Python # Conférences # NodeConf EU 2023 # BID 2023 # SPIRE 2021 # Go Systems (San Francisco, 2020) # Performance Summmit III (Seattle, 2020) # QCon San Francisco 2019 (la conférence la plus appréciée par les participants) # Spark Summit East 2017 # "},{"id":5,"href":"/inf1220-hugo/docs/modules/module4/activite-4-1/","title":"Les flux de console","section":"Module 4: Les entrées et sorties","content":" Les flux de console # La bibliothèque System Les bibliothèques responsables de la gestion des éléments de bas niveau (écran, clavier, etc.), lesquelles nécessitent donc le système de l'ordinateur, s'appellent bibliothèques System. Dans les exemples précédents, nous avons utilisé amplement l'affichage à la console avec la méthode System.out.println(). Ainsi, la gestion de l'affichage d'un message à l'écran ou la saisie de valeurs au clavier font partie des fonctions requérant le système de l'ordinateur. C'est pourquoi leur nom commence toujours par « System ».\nLa librairie System est composée de deux sous-ensembles principaux : in et out. L'affichage est une opération de sortie et fait donc partie des éléments out de la classe System. Pour accéder au sous-ensemble out, on écrit System.out. Finalement, pour afficher à l'écran, nous faisons appel à la fonction print du sous-ensemble out.\nAfficher à la console Avant de développer des applications graphiques ou des applications web, il faut maîtriser les fichiers et la console. Nous avons utilisé la console à plusieurs reprises dans les activités précédentes. Il s'agit d'utiliser la sortie \"out\" de system et d'appeler les méthodes print (pas de retour de ligne automatique) ou println (retour de ligne automatique à la fin du texte). Plus particulièrement, l'instance \"out\" réfère à la classe PrintStream, qui possède plus de méthodes d'impression que print et println. De plus, à partir de l'objet System, il est également possible de changer la modalité d'impression de System.out de la console (par défaut) vers, par exemple, un fichier, et ce en utilisant la méthode System.setOut(). Nous verrons dans la prochaine activité comment rediriger les sorties vers un fichier à l'aide des flux de fichiers. Voici, donc des exemples de l'utilisation de System.out :\nSystem.out.println(\u0026#34;Imprimer une ligne\u0026#34;); System.out.print(\u0026#34;Imprimer des chaînes de caractères\u0026#34;); System.out.print(\u0026#34;On peut additionner des String et d\u0026#39;autres types grâce à l\u0026#39;auto-boxing\u0026#34; + 5 + \u0026#34;-\u0026#34; + \u0026#39;a\u0026#39;); System.out.append(\u0026#39;c\u0026#39;); try { // Ici ça fonctionne System.out.write(\u0026#34;Ça marche\u0026#34;.getBytes()); // Méthode permettant de fermer le flux System.out.close(); // Ici ne s\u0026#39;imprime pas car le flux est fermé. System.out.write(\u0026#34;Ça ne marche pas\u0026#34;.getBytes()); } catch (IOException ex) { Logger.getLogger(AlgorithmeTri.class.getName()).log(Level.SEVERE, null, ex); } Saisir des données au clavier Le langage Java a été principalement conçu pour le développement d'interface graphique (GUI) et d'interface web (JSP, Servlet, etc.). Toutefois, comme la majorité des langages de programmation, il supporte la saisie de données dans la console, grâce à \"System.in\" et des objets tels que Scanner. Voici la façon de récupérer des saisies au clavier à partir du terminal/console :\n// Instanciation de entree permettant de lire dans le InputStream correspondant à la console de l\u0026#39;OS(System.in) Scanner entree = new Scanner(System.in); // Récupérer les données jusqu\u0026#39;à la saisie d\u0026#39;un retour de chariot String texte = entree.nextLine(); La méthode nextInt() permet de lire un entier. Le code suivant illustre cette méthode :\nScanner entree = new Scanner(System.in); int entier = entree.nextInt(); La classe Scanner ne convient pas à la lecture des mots de passe à partir d'une console puisque ces derniers sont invisibles. Le langage de programmation Java SE 6 introduit une classe Console réservée à cet usage. Donc, pour lire un mot de passe, il faut utiliser le code suivant :\n// Ce code retourne un objet Console null si exécuté dans certains environnements. // Nécessite d\u0026#39;être lancée dans un terminal/console de l\u0026#39;OS Console uneConsole = System.console(); // définir une console String nomUtilisateur = uneConsole.readLine(\u0026#34; Nom Utilisateur: \u0026#34;); // lire le nom utilisateur char[] motDePasse = uneConsole.readPassword(\u0026#34;Mot de Passe: \u0026#34;); // le mot de passe. Vidéos Recevoir des arguments en ligne de commande La méthode main en Java reçoit un tableau de String. Ainsi donc, si on lance un programme Java en ligne de commande (java MonProgramme arg1 arg2), la fonction main recevra les chaînes de caractère arg1 et arg2. Vous pouvez regarder la vidéo suivante pour en apprendre davantage sur ce mécanisme si vous le souhaitez.\nSi vous utilisez repl.it, vous pouvez ouvrir une console avec les touches ctrl-shift-s où vous pouvez exécuter des commandes comme « javac Main.java » et « java Main arg1 arg2 ».\n"},{"id":6,"href":"/inf1220-hugo/docs/modules/module1/teluq/","title":"Modèle du cours","section":"Module 1: Algorithme et pseudocode","content":" Le modèle pédagogique du cours # Le cours INF 1220 est autoportant. Cela signifie que vous êtes capable, de manière autonome, de réaliser toutes les activités du cours. Il est important de bien comprendre ce modèle avant de débuter si vous n\u0026rsquo;êtes pas familier avec les cours en ligne de ce type.\nLe modèle de l’Université TÉLUQ # Plusieurs étudiants inscrits au cours INF 1220 en sont en leur premier cours à l’Université TÉLUQ. À l’Université TÉLUQ, nous offrons un enseignement personnalisé : vous débutez et terminez le cours à une date qui vous convient, vous faites les travaux au sein du cours à votre rythme. Le cours est conçu pour être autoportant : un travail pédagogique substantiel a été fait afin que l’étudiant autonome puisse compléter le cours par lui-même, sans aide. Un professeur ou une personne tutrice est là pour répondre à vos questions lorsque vous êtes devant une impasse après avoir fait les lectures et vos recherches, à tous les moments de votre parcours. Ce modèle diffère de celui des Universités traditionnelles où il y a de rencontres de groupes hebdomadaires et où tous les étudiants cheminent en même temps. Les deux modèles ont des forces et des faiblesses. L’Université TÉLUQ offre plus de flexibilité, mais son modèle exige plus d’autonomie intellectuelle de la part des étudiants.\nMener à terme un cours à l’Université TÉLUQ exige de la persévérance et de la motivation, ainsi que de l’autonomie et de la discipline. En vous inscrivant à un cours à distance, vous adoptez un modèle différent de celui d’un cours sur campus. Vous devez organiser votre apprentissage de manière autonome, en utilisant les ressources didactiques et d’encadrement mises à votre disposition, à l’endroit et au moment de votre choix.\nLe professeur est préoccupé par le fait que l’apprentissage s’effectue de façon autonome. Tout le cours est créé en fonction de cet objectif. Nous croyons que le résultat est une formation de qualité axée sur l’autonomie et l’indépendance d’esprit.\nApprentissage par vidéo # Certains étudiants préfèrent lire, d\u0026rsquo;autres préfèrent regarder des vidéos. Nous croyons que les deux modes de diffusion (écrit et vidéo) ont leur place en enseignement.\nL’Université TÉLUQ est un précurseur dans l’enseignement avec la vidéo. Longtemps, lors de l’inscription à un cours, on pouvait recevoir des cassettes vidéos (VHS). L’Université TÉLUQ a même porté son propre poste de télévision appelé Canal Savoir.\nQuelques cours à l’Université TÉLUQ sont toujours diffusés principalement avec des vidéos. Dans la plupart des cas, cependant, les cours utilisent des notes de cours. C’est le cas du cours INF 1220. Le langage écrit a plusieurs avantages, notamment le fait d’être plus accessible.\nUn texte peut être lu rapidement. S’il est possible de modifier la vitesse de diffusion d’une vidéo, il demeure plus difficile de faire rapidement des sauts et des retours. Il est relativement aisé de faire des recherches dans un document écrit, et plus difficile dans une vidéo.\nDans le cas du cours INF 1220, l’utilisation plus intensive de la vidéo n’est pas jugée souhaitable pour deux raisons outre l’accessibilité. Tout d’abord, il existe un grand éventail de vidéos de grande qualité déjà disponibles et répondant bien au besoin du cours. Nous jugeons qu’il n’y aurait pas de sens à produire du contenu redondant. Dans certains cas spécifiques, nous avons produit des vidéos, mais dans l’ensemble, il est préférable de renvoyer les étudiants qui souhaitent du contenu vidéo à ce qui est déjà en place. Par ailleurs, avec des décennies d’expérience en pédagogie universitaire, nous savons que l’utilisation à grand volume de la vidéo a des limites. Nous croyons qu’il est beaucoup plus utile d’amener les étudiants à programmer le plus possible, tout en se référant à du contenu écrit. Personne n’apprend vraiment à programmer en regardant des vidéos. On apprend à programmer en lisant du code et en programmant. Et il est difficile de faire des recherches techniques au sein d’un enregistrement vidéo.\nCertains étudiants préfèrent écouter et regarder plutôt que de lire. Nous sommes conscients que la lecture d’un manuel portant sur la programmation peut sembler rébarbative. Par contre, la lecture technique fait partie intégrante de l’activité de programmation. Il est absolument essentiel de pouvoir lire des documents techniques et des descriptions formelles. En somme, si la vidéo peut être utilisée, elle ne peut remplacer la lecture en programmation.\nPython, JavaScript, C#, C++, Go, Rust, etc. # Certains étudiants souhaitent apprendre un autre langage que Java. Nous vous encourageons à étudier plus d’un langage de programmation, surtout si vous souhaitez faire carrière en informatique. Dans le cadre de ce cours, nous allons cibler un seul langage.\nCertains étudiants souhaitent apprendre le C#. Il est particulièrement facile de passer du Java au C#. En effet, le C# peut être vu comme une variante du Java. La syntaxe est souvent quasiment identique et les pratiques de programmation sont équivalentes.\nDans le cadre d’une carrière dans l’industrie du logiciel, il peut être dommage de se limiter à une seule technologie, un seul langage de programmation. Les choix technologiques évoluent et les offres d’emploi diffèrent d’un moment à l’autre. On s’attend à ce qu’un diplômé universitaire maîtrise plusieurs technologies, plusieurs langages.\nSi vous souhaitez étudier le langage Python, vous pourrez prendre le cours INF 2020 Programmation d\u0026rsquo;applications avec Python. Si vous souhaitez étudier le langage Go, vous pourrez prendre le cours INF 2007 Programmation avancée.\nSoyez informé ! # Si ce n’est pas déjà fait, prenez le temps de lire la description du cours sur le site web de la TÉLUQ. Vous y trouverez notamment la grille d’équivalence entre les notes numériques et les lettres. Une telle grille répond notamment à la question « quelle est la note de passage ». Observez bien cependant que la note de passage n’est pas suffisante généralement pour progresser normalement au sein d’un programme universitaire et obtenir un diplôme.\nNous vous rappelons que lorsque vous suivez un cours, vous devez lire les courriels de l’Université. L’information pertinente concernant le cours, votre inscription, etc. peut y être acheminée. Si vous ne prenez pas vos messages dans votre boîte courriel TÉLUQ, il peut vous manquer des informations importantes.\nImportant: En commençant, prenez en note la date de fin de cours. Vous devez avoir remis les travaux d’ici cette date. Si vous avez besoin d’un report de la date de fin de cours, peut-être à cause d’empêchements médicaux ou familiaux, vous devez joindre l’Université (pas le professeur) pour établir votre situation et obtenir un report. Vous ne pouvez pas obtenir un report après la date de fin de cours. En aucun cas est-ce que l\u0026rsquo;enseignant peut modifier votre date de fin de cours.\nVotre date de fin de cours est inscrite dans votre dossier et vous pouvez la trouver sur le portail étudiant et sur la documentation qu’on vous a remise lors de votre inscription. Il est possible que votre examen ait lieu des semaines ou même des mois après votre date de fin de cours: cela ne constitue pas une extension de votre date de fin de cours. Tout travail remis après votre date de fin de cours pourra recevoir la note de zéro. En tout temps, la note « incomplet » peut être attribuée à un travail qui n’est pas remis après votre date de fin de cours, même si vous n’avez pas encore passé l’examen.\nVous ne devriez jamais avoir à nous demander jusqu’à quelle heure précise lors de la dernière journée de votre cours vous avez pour compléter vos travaux. Prenez le temps de planifier votre travail. Avec la possibilité de report et la flexibilité offerte par la TÉLUQ, il n’y a pas d’excuse pour terminer le cours à la dernière heure.\nLes reports de la date de fin de cours # À la TÉLUQ, chaque étudiant a sa propre date de fin de cours. Les professeurs ne peuvent pas modifier ces dates, quelle que soit votre situation. Les dates des examens sont fixées par l\u0026rsquo;Université. Les professeurs conçoivent les examens, mais leur déroulement est géré par l\u0026rsquo;Université. La période suivant la date de fin de cours, où votre dossier est fermé et où vous risquez de recevoir un incomplet, est également gérée par l\u0026rsquo;Université. Vous devez donc contacter l\u0026rsquo;Université si vous avez besoin de plus de temps. Il est inutile d\u0026rsquo;écrire aux professeurs à ce sujet.\nIl est de votre responsabilité de respecter les délais et de réaliser les travaux selon l\u0026rsquo;échéancier prévu dans le cours. En cas de difficultés (familiales, médicales, situation de handicap), vous devez en informer l\u0026rsquo;Université, et non le professeur. Sinon, une bonne organisation est essentielle.\nLa gestion efficace de votre temps est une compétence clé pour réussir vos études universitaires. Le cours est conçu pour vous y aider en structurant les activités en modules avec des échéances suggérées. Toutefois, c\u0026rsquo;est à vous de vous organiser.\nPlanifier votre temps # Le niveau de difficulté du cours augmente progressivement. Les premiers travaux sont plus accessibles, mais environ un tiers du cours devrait être consacré aux deux derniers modules, qui sont plus avancés. Si vous passez trop de temps sur les lectures et les travaux initiaux, vous pourriez être surpris par la difficulté et le volume de travail des dernières parties.\nExigences du cours # Le cours INF 1220 n\u0026rsquo;est pas un cours facile.\nDans certaines disciplines, lire suffit pour préparer les travaux. En programmation, la lecture seule est insuffisante. Un manuel ne vous apprendra pas à programmer. Vous devez lire, faire des exercices, relire, et répéter ce processus. Apprendre à programmer demande du travail et de la persévérance. La présence de nombreux travaux dans le cours vise à vous encourager à travailler régulièrement et à pratiquer.\nPrévoyez environ 9 heures de travail par semaine pendant 15 semaines pour réussir ce cours. Chaque travail noté demande plusieurs heures, tout comme la préparation et l\u0026rsquo;étude préalables. Il est normal de consacrer des dizaines d\u0026rsquo;heures pour compléter un module et son travail noté. Si vous n\u0026rsquo;avez pas entre 5 et 15 heures par semaine à consacrer au cours, vous risquez de ne pas réussir.\nLe cours inclut des lectures et des activités d\u0026rsquo;autoévaluation (par exemple, des problèmes avec solutions cachées). Vous devez obligatoirement réaliser ces lectures et activités avant les travaux notés. Des vidéos explicatives sont également disponibles : visionnez-les et revisionnez-les au besoin. Tenter de passer directement aux travaux notés sans préparation est voué à l\u0026rsquo;échec. Faire uniquement le minimum pour compléter les travaux notés ne suffira pas pour réussir l\u0026rsquo;examen. Vous devez pratiquer la programmation, apprendre à penser comme un programmeur et maîtriser le Java grâce à une étude rigoureuse.\nSi un travail noté exige d\u0026rsquo;expliquer votre solution, cette consigne est impérative. Ne pas la respecter peut entraîner une note de zéro.\nVotre code doit être fonctionnel et valide, sinon une note de zéro peut être attribuée. La réussite de ce cours repose sur votre capacité à programmer.\nIl est fortement recommandé de faire des recherches autonomes en ligne (YouTube, etc.) pour compléter le manuel, les notes de cours et les activités. La recherche en ligne est une composante essentielle du développement logiciel aujourd\u0026rsquo;hui. Prévoyez plusieurs heures pour explorer des ressources complémentaires selon vos besoins.\nNe débutez pas ce cours si vous n'avez pas les préalables mathématiques nécessaires.\nLe cours INF 1220 a été développé en prenant pour acquis que vous avez fait les mathématiques avancées au secondaire et au collégial. Il fait partie d'un cursus en informatique de niveau universitaire. Si vous n'étiez pas « fort en math » au secondaire, il est possible que vous trouviez le cours trop difficile. Il est de votre responsabilité de faire une mise à niveau au besoin avant de débuter le cours INF 1220.\nNavigateur web # Vous pouvez suivre ce cours avec pratiquement n'importe quel navigateur web. Par contre, pour que les formules mathématiques s'affichent correctement, vous devez utiliser un navigateur supportant la norme MathML. Les navigateurs Chrome, Edge, Firefox et Safari font bien l'affaire.\nIl y a peu de formules mathématiques dans ce cours, et il est donc parfaitement possible de travailler sans un support correct des formules mathématiques. Par contre, si vous avez besoin de bien suivre nos consignes et rappels mathématiques, vous devriez sans doute adopter, au moins temporairement, un des navigateurs supportant MathML (par ex., Chrome, Edge, Firefox et Safari).\nEncadrement et suivi # Prenez connaissance de la documentation fournie par l'université. Vous y trouverez le nom et l'adresse courriel de la personne qui vous encadre. Après avoir fait les lectures, vous pouvez écrire vos questions à cette personne. Assurez-vous de respecter les consignes énoncées dans la présentation du cours : vous devez mettre « [INF1220] » dans l'objet du courriel et vous devez utiliser une adresse de courriel à votre nom afin que nous puissions vous identifier. Vos courriels devraient comprendre des questions précises, bien détaillées. Vous devriez commencer expliquer ce que vous avez fait, ce que vous comprenez. Il peut être utile de faire référence aux lectures que vous avez faites. N'oubliez pas que les lectures au sein du manuel sont obligatoires. Par exemple, si vous avez du mal avec une notion couverte par le manuel, vous devriez faire une référence à cette section. N'hésitez pas à joindre des saisies d'écran pour illustrer vos propos. Nous nous ferons un plaisir de répondre à vos questions par courriel, mais tel qu'expliqué dans la présentation du cours, nous n’offrons pas d’enseignement par vidéoconférence au sein du cours INF 1220. Réseaux sociaux # Attention: Il est strictement défendu de demander des indices aux autres étudiants du cours concernant les travaux notés et l'examen. Il est aussi défendu de donner des indices concernant les travaux notés.\nPlagiat # Nous mettons bien entendu à jour les travaux notés et les examens. Dans le cas des travaux notés, vous pouvez toujours remettre la version que vous avez débutée sans pénalité dans le cas où les travaux sont mis à jour pendant votre travail. Par contre, soyez avisé que nous portons une attention particulière au plagiat. Si votre travail ressemble trop à un autre travail remis, nous pourrons alors procéder à un examen oral, pour vérifier si vous avez effectivement fait le travail par vous-même. Dans le cas des examens, nous tentons de les offrir en présence avec surveillance. Quand ce n'est pas possible, nous varions autant que possible le contenu des examens et nous utilisons d'autres mesures à notre disposition pour contrer le plagiat.\nLe plagiat peut avoir des conséquences sévères. Une note permanente peut être ajoutée à votre dossier et à votre relevé de notes. Le plagiat peut mener à votre exclusion du programme universitaire où vous avez été admis.\n"},{"id":7,"href":"/inf1220-hugo/docs/modules/module1/","title":"Module 1: Algorithme et pseudocode","section":"Modules","content":" Module 1 # Le module 1 pose les bases de l’algorithmique et du raisonnement informatique. Il vous initie à la notion d’algorithme : une suite d’instructions précises permettant de résoudre un problème, à l’image d’une recette de cuisine. Vous apprendrez à décrire ces solutions en pseudocode, un langage intermédiaire entre le français et la programmation, pour exprimer clairement chaque étape sans vous soucier de la syntaxe d’un langage particulier.\nAu fil du module, vous découvrirez :\nComment identifier les composants essentiels d’un algorithme (entrées, sorties, instructions, conditions, boucles). Comment rédiger des algorithmes simples en pseudocode, en français. Les bases de la complexité algorithmique (notation grand-O, comparaison d’approches). L’importance de la rigueur, de la précision et de la pratique pour progresser. Un aperçu historique des langages de programmation et de l’évolution des ordinateurs. De nombreux exemples concrets et exercices d’autoévaluation vous permettront d’appliquer ces concepts et de développer votre capacité à raisonner de façon logique et méthodique, compétence essentielle pour la suite du cours et pour toute démarche informatique.\n"},{"id":8,"href":"/inf1220-hugo/docs/modules/module2/preparation/","title":"Préparation de l’espace de travail","section":"Module 2: Introduction au langage Java","content":" Préparation de l\u0026rsquo;espace de travail # Comme langage de support à l'introduction des concepts de programmation, nous utiliserons le langage Java. Tel que présenté dans l'introduction du cours, le langage Java est un langage interprété multi-plateforme où le code est pré-compilé dans un ensemble d'instructions intermédiaires (appelé Java bytecode), puis interprété sur chaque système d'exploitation à partir de la machine virtuelle Java. Celle-ci transforme alors le bytecode en instructions machine propre au système d'exploitation et aux processeurs spécifiques de l'ordinateur.\nSi ce n'est pas déjà fait, il est maintenant temps de configurer un environnement de développement Java. Dans ce cours, vous pouvez utiliser l'environnement de programmation qui vous convient le mieux ou qui fonctionne bien pour vous. Vous n'avez pas à utiliser une approche spécifique.\nDans ce cours, vous devez être à même de choisir l'environnement qui vous convient le mieux. Cette démarche d'appropriation fait partie intégrante du cours. Nous n'offrons pas de soutien technique concernant les outils logiciels que vous choisissez d'installer sur vos ordinateurs. Nous vous invitons à procéder par essai/erreur et à faire les recherches nécessaires.\nQuand vous testez un nouvel environnement, utilisez du code Java simple et bien testé. Si vous ne connaissez pas bien le Java, ne commencez pas à expérimenter avec la programmation tout en testant un nouvel environnement. Allez-y une étape à la fois.\nUtilisation d\u0026rsquo;un environnement de programmation en ligne # Plusieurs étudiants préfèrent un environnement de développement conventionnel, installé sur leur PC. D'autres étudiants peuvent avoir une préférence pour les environnements en ligne qui ne nécessitent aucune installation.\nAu sein même du cours, nous mettons à votre disposition un environnement de développement entièrement en ligne, suffisant pour les travaux du cours. Vous pouvez y avoir accès dès maintenant. Suivez le lien qui se trouve dans le menu du cours. Vous y trouverez des instructions.\nAutres systèmes en ligne # Outre le système inclut dans le cours, il y a plusieurs autres environnements en ligne, nous vous invitons à les explorer, en commençant par les suggestions suivantes :\nrepl.it ideone Ces outils en ligne vous permettent de saisir votre code, dans le navigateur, et de l'exécuter par la suite. Vous pouvez faire une grande partie du cours en utilisant seulement un outil comme repl.it. En effet, le cours se concentre principalement sur la programmation de base. Les outils d'aide à la programmation sont moins importants. Nous ne ferons pas de grands projets dans ce cours qui nécessitent beaucoup de gestion de code.\nLa vidéo suivante illustre l'utilisation de repl.it (il n'est pas nécessaire d'écouter la narration en anglais pour comprendre). Truc: Avec repl.it, vous pouvez ouvrir une console avec les touches ctrl-shift-s où vous pouvez exécuter des commandes comme « javac Main.java » et « java Main ».\nDans le cours, vous trouverez des exemples utilisant repl.it, mais l'utilisation de repl.it est optionnelle. Si repl.it ne fonctionne pas bien pour vous, utilisez autre chose.\nUne des limites d'un environnement comme repl.it est qu'ils ne permettent pas la production d'interfaces graphiques. Ainsi, certains exemples ne peuvent fonctionner sous repl.it.\nNotez bien: Certains des exemples repl.it comprennent plusieurs fichiers. Comme dans plusieurs interfaces, repl.it ne permet de voir le contenu que d'un seul fichier à la fois. Par contre, il vous permet de naviguer entre différents fichiers. Nous verrons dans ce cours que Java exige que les \"classes\" soient définies au sein de fichiers du même nom, ce qui implique souvent que nous utilisions plusieurs fichiers avec des noms prédéterminés. Cette contrainte en ce qui a trait aux fichiers n'est pas spécifique à repl.it. En Java, il y a un lien direct entre le nom des fichiers et leur contenu. Dans ce cours, vous devez faire preuve de débrouillardise et nous supposons que vous trouverez comment faire pour naviguer et voir les différents fichiers. Instructions détaillées pour Repl.it # Repl.it est une plateforme en ligne qui permet d’écrire, d’exécuter et de tester du code Java directement dans votre navigateur, sans avoir besoin d’installer un environnement de développement sur votre ordinateur. Pour commencer, accédez aux liens Repl.it fournis dans le cours. Cliquez sur un lien pour ouvrir le projet Java correspondant. Vous verrez une interface avec un éditeur de code à gauche, où le code est déjà chargé, et une console à droite pour afficher les résultats. Si vous n’êtes pas encore inscrit, créez un compte gratuit sur Repl.it en utilisant votre adresse e-mail ou un compte Google. Une fois connecté, vous pouvez modifier le code directement dans l’éditeur. Pour exécuter votre programme, cliquez sur le bouton vert « Run » en haut de la page. La console affichera les sorties ou les erreurs, ce qui vous permettra de vérifier si votre code fonctionne comme prévu.\nPour travailler efficacement sur Repl.it, familiarisez-vous avec ses fonctionnalités principales. Vous pouvez créer un nouveau fichier ou répertoire dans votre projet en cliquant sur l’icône « + » dans la barre latérale. Si vous modifiez le code fourni dans les liens du cours, assurez-vous de ne pas écraser les instructions ou les parties essentielles sans les comprendre. Avec un peu de pratique, Repl.it deviendra un outil puissant et intuitif pour développer vos compétences en programmation Java.\nInstallation du Java Development Kit (JDK) # Système d\u0026rsquo;exploitation Microsoft Windows : # Je vous suggère d'installer le JDK à partir du site https://adoptium.net/. La vidéo suivante illustre comment y arriver sous Windows en moins de deux minutes. Aller sur le site https://adoptium.net/. Choisir la dernière version disponible. Une fois le fichier d'installation téléchargé, démarrer l'installation et suivre les différentes étapes d'installation. Une fois le logiciel installé, la machine virtuelle Java (java.exe) et ses outils de compilation (javac.exe) auront été installés. macos # Nous vous suggérons d'utiliser https://adoptium.net/ encore une fois.\nLinux Debian # Si vous êtes un utilisateur de Linux et plus particulièrement de Debian (ou Ubuntu), vous savez probablement déjà utiliser les Debian Packages! Pour installer la JDK, il faut ouvrir l'invite de commande (la console...), se mettre en mode super-utilisateur (su) et exécuter la commande « apt-get install default-jdk ».\nUtilisation d\u0026rsquo;un éditeur de texte # La plupart des langages de programmation s'utilisent avec des fichiers de texte. Le fichier n'est qu'une séquence de caractères sans autre structure particulière. L'outil le plus simple en programmation est donc le simple éditeur de texte. Comme le nom l'indique, l'éditeur de texte vise principalement à éditer des fichiers de texte. Notons que les traitements de texte (comme Word) ne sont pas fait pour éditer des fichiers de texte. Par ailleurs, un éditeur de texte ne peut pas, par lui-même, compiler et exécuter des programmes. Il sert surtout à écrire le code.\nLe meilleur éditeur de fichier texte est sans doute Visual Studio Code (à ne pas confondre avec Visual Studio). Microsoft rend disponible un guide d'utilisation de Visual Studio Code avec java.\nNous recommandons Visual Studio Code plutôt que l'utilisation d'un environnement comme IDEA, Eclipse ou NetBeans. L'utilisation d'un éditeur de texte combiné avec le JDK vous met davantage en charge du développement.\nInstallation de l\u0026rsquo;IDE IntelliJ IDEA # Lecture suggérée : Environnement de développement\nVous pouvez installer l'IDE IntelliJ IDEA. L'utilisation d'un IDE n'est pas obligatoire, mais cela est recommandé. IntelliJ IDEA est un excellent choix.\nRendez-vous sur https://www.jetbrains.com/idea/. Cliquez sur Download. Sous \"Community\", cliquez sur Download. Cette version est gratuite. L'enregistrement du programme d'installation devrait débuter. Suivez ensuite les consignes. Nous croyons que IntelliJ IDEA est supérieur aux autres IDE, étant plus élégant et convivial. Cependant, le choix vous appartient.\nNotez que nous n'offrons pas de soutien technique pour les IDE dans ce cours. Si vous optez pour IntelliJ IDEA, vous devrez vous en remettre au soutien technique et à la documentation de l'entreprise qui fournit le produit. Nous sommes là pour vous appuyer dans l'apprentissage de la programmation et du Java, mais pas dans l'utilisation d'un IDE spécifique.\nLes IDE ont la fâcheuse habitude d'automatiser plusieurs opérations ce qui ne pose pas de problème aux programmeurs expérimentés, mais qui est souvent déroutant pour les débutants. Les IDE vont souvent créer des répertoires, des « paquetages » et avoir différentes attentes quant à l'endroit où les différentes fonctions et classes doivent être. Le résultat net est que les étudiants sont souvent confrontés à des messages d'erreur qui les laissent perplexes après des modifications faites en utilisant l'interface graphique (par exemple, après le déplacement d'un fichier). Si vous utilisez un IDE, il faut apprendre à travailler selon les attentes de l'IDE. À terme, certains programmeurs trouvent que l'utilisation d'un IDE les rend plus productifs, mais quand on débute, l'IDE est un obstacle supplémentaire pour certains étudiants.\nInstallation de l\u0026rsquo;IDE Netbeans # Si vous avez installé IntelliJ IDEA, il n'est sans doute pas nécessaire d'installer aussi Netbeans. Cependant, vous pouvez installer les deux, pour comparer.\nCet IDE possède un éditeur visuel bien fait, stable et complet. Pour installer Netbeans (lors de la dernière mise à jour du cours, il s'agissait de la version Apache Netbeans 11; Depuis Janvier 2019, la gestion du projet Netbeans a passé de Oracle vers l'organisation Apache, vous pouvez utiliser les versions plus récentes sous Apache ainsi que la dernière version d'Oracle 8.2), vous devez suivre les étapes suivantes :\nSuivre le lien suivant: https://netbeans.apache.org/download/index.htmlTélécharger la version \"binaries\" (déjà compilée).Une fois le fichier .zip téléchargé, veuillez le décompresser dans un répertoire personnel. Ouvrez le répertoire ./netbeans/bin, les exécutables pour lancer Netbeans s'y trouvent.Vous pouvez démarrer maintenant Netbeans. Au démarrage, vous pouvez spécifier dans quel répertoire vous voulez que vos projets de programmation soient « sauvegardés ». Par défaut, il s'agit de « C:\\Users\\VotreNomUtilisateur\\Documents\\NetBeansProjects ». Si vous optez pour NetBeans, vous devrez vous en remettre au soutien technique et à la documentation de l'entreprise qui fournit le produit.\nInstallation de l'IDE Eclipse Si vous avez installé IntelliJ IDEA ou Netbeans, il n'est sans doute pas nécessaire d'installer aussi Eclipse. Cependant, vous pouvez installer les trois, pour comparer.\nRendez-vous sur http://www.eclipse.org. Cliquez sur Download. Il peut être nécessaire de cliquer sur Download à plus d'une reprise, alors que différentes pages sont chargées. L'enregistrement du programme d'installation devrait débuter. Suivez ensuite les consignes. [embed width=\u0026ldquo;600\u0026rdquo; height=\u0026ldquo;800\u0026rdquo;]https://www.youtube.com/embed/3vhLoQZOEzU[/embed]\nSi vous optez pour Eclipse, vous devrez vous en remettre au soutien technique et à la documentation de l'entreprise qui fournit le produit.\nErreurs et avertissements # Java pourra émettre certains messages lors de la compilation et de l'exécution de vos programmes. Il y a d'une part les messages d'erreur. Dans un tel cas, le programme ne peut être compilé ou exécuté. Il y a d'autre part les messages d'avertissement. Le plus souvent, on peut ignorer les messages d'avertissement. Ils servent avant tout à attirer l'attention du programmeur sur des problèmes potentiels, mais ils ne nuisent pas à la compilation et à l'exécution.\nIl est important de faire la différence entre une erreur et un avertissement. Vous ne devez pas confondre les deux concepts lorsque vous programmez. Soyez précis!\nLes choix du professeur # S'il faut que je développe du code, j'utilise Visual Studio Code. Je suis actif au sein de plusieurs projets et Visual Studio Code a plusieurs avantages. Il fonctionne pratiquement partout. Visual Studio Code me permet de \"programmer\" dans une multitude de langages, de LaTeX à Go en passant par Haskell, Markdown, C++, etc. Je peux facilement combiner Visual Studio Code a plusieurs autres outils. Je peux développer aussi bien sous docker qu'avec ssh, etc. "},{"id":9,"href":"/inf1220-hugo/docs/modules/module2/oriente/","title":"Création d'une classe en Java","section":"Module 2: Introduction au langage Java","content":" Création d\u0026rsquo;une classe en Java # Créer une classe en Java, c’est définir un nouveau type d’objet qui regroupe à la fois des données (appelées attributs ou champs) et des comportements (appelés méthodes). Cette approche permet de modéliser des entités du monde réel ou conceptuel de façon structurée et réutilisable. Une classe sert de « plan » pour fabriquer des objets : chaque objet créé à partir d’une classe possède ses propres valeurs pour les attributs, mais partage les mêmes méthodes. La programmation orientée objet favorise ainsi la modularité, la clarté et la maintenance du code, car chaque classe peut être développée, testée et améliorée indépendamment des autres.\nUn premier programme # En Java, toutes parties d'un programme informatique doit donc être encapsulée dans une classe. Pour ce faire, il est donc nécessaire de créer un premier fichier de code source qui décrira une première classe et contiendra la description de la méthode \"main\", la méthode de démarrage (appelé parfois \"bootstrap\") du programme. Il est possible tout simplement d'utiliser le Bloc-Note avec Windows ou un autre éditeur de texte brut (ce n'est pas le cas de Microsoft Word!), d'écrire les lignes de code nécessaire à la création de la classe et de ses fonctions et d'enregistrer ce texte sous l'extension .java (dans l'exemple ci-dessous dans un fichier Main.java). Voici un exemple d'une première classe qui imprimera dans l'invite de commande un texte de bienvenue.\nBienvenue.java /* Ma première classe */ public class Bienvenue { public static void main(String args[]) { System.out.println(\u0026#34;Bienvenue au sein du cours INF1220 !\u0026#34;); } } Exécuter Vous devez choisir comment vous allez exécuter ce programme. Vous pouvez le faire sans IDE (avec Bloc-Note et un accès en ligne de commande), avec repl.it en ligne, avec IntelliJ IDEA, avec Netbeans. Vous pouvez même faire des expériences avec plus d'une approche et ne retenir que celle qui vous convient le mieux.\nNous reviendrons dans le cours sur les éléments de programmation nécessaires pour comprendre ce programme. Néanmoins, en voici l'essentiel:\nLes parties de code situées entre /* et */ sont des commentaires qui ne seront pas compilés. La première instruction public class Bienvenue indique que nous créons une classe publique (accessible à toutes autres parties du programme) qui se nomme Bienvenue. Cette classe doit être enregistrée dans un fichier portant le même nom et la même extension .java. Attention, Java différencie les majuscules et les minuscules. La classe Bienvenue est différente de la classe bienvenue, et le fichier bienvenue.java n'est pas l'équivalent du fichier Bienvenue.java. Important : La norme de programmation en Java est de toujours commencer un nom de classe par une majuscule. S'il y a plusieurs mots dans le nom de la classe, utiliser une majuscule au début de chaque mot. Par exemple, TexteBrute ou Encrypteur32Bits. La classe Bienvenue doit être définie dans un fichier appelé Bienvenue.java. Le nom et l'emplacement des fichiers est important en Java. Java étant un langage orienté objet, tout fichier source définit une classe, c'est-à-dire un objet possédant des champs et des méthodes. La définition de la classe se fait dans un bloc d'instructions contenu entre des accolades ouvrantes { et fermantes }. C'est ce que l'on appelle la portée. Notre classe Bienvenue contient une unique méthode annoncée par l'instruction public static void main (String args[]). Il s'agit de la méthode principale d'un programme, celle qui sera exécutée lors du lancement par la machine virtuelle Java (JVM). Le nom et la déclaration de cette méthode ne peuvent pas être modifiés. Par exemple, la fonction \"public static void main (int x)\" ne sera pas interprétée comme la méthode principale de démarrage. Pour définir une méthode, il faut donner une suite d'instructions situées entre deux nouvelles accolades. Dans le cas qui nous intéresse, la méthode \"main\" ne comporte qu'une seule instruction qui provoque l'affichage du message «Bienvenue au sein du cours INF 1220!», à savoir la méthode System.out.println. Les lignes contenant une instruction simple comme celle-ci doivent se terminer par un point-virgule. Important: Le code en Java est généralement organisé en « classes ». En Java, une classe doit être déclarée et définie dans un fichier qui porte son nom. Ainsi, si votre classe s\u0026rsquo;appelle \u0026ldquo;MonChat\u0026rdquo;, vous devez l\u0026rsquo;enregistrer dans un fichier nommé MonChat.java.\nCréation d\u0026rsquo;une classe sans IDE # Créez un fichier au format texte nommé Bienvenue.java et contenant le code suggéré. Le fichier source étant créé et enregistré, nous pouvons passer aux phases de compilation et d'exécution.\nSi vous utilisez Windows, vous pouvez suivre cette vidéo\u0026nbsp;:\nCompilation # Le compilateur Java est le programme javac.exe (ou simplement javac sous OSX et Linux) contenu dans le dossier bin du JDK. Pour compiler Bienvenue.java, il faut :\nouvrir une invite de commande (sous windows) ou bien Terminal (macos et Linux); se déplacer dans le dossier de travail dans la console en utilisant la commande cd qui permet de changer de répertoire (ex. \"cd /INF1220\"); exécuter la commande \"javac Bienvenue.java\"; Si tout s'est bien passé (c'est à dire qu'il n'y a pas eu d'erreur de compilation), vous obtiendrez dans le même dossier le nouveau fichier Bienvenue.class, qui est le résultat de la compilation. C'est le fichier intermédiaire qui contient le Bytecode et qui sera interprété par la JVM\nMalheureusement, plusieurs erreurs peuvent survenir. Voici quelques causes d'erreurs possibles.\nVotre environnement ne trouve pas le programme javac.exe. Il faut indiquer le chemin d'accès à ce programme. Pour éviter d'avoir à réécrire à chaque fois le chemin d'accès à javac et aux autres programmes du SDK, il est conseillé d'ajouter ce chemin dans le PATH en complétant le fichier autoexec.bat. javac.exe s'exécute, mais ne trouve pas bienvenue.java. Le dossier actif de votre console/invite de commande n'est pas celui qui contient Bienvenue.java. Allez dans le bon dossier. javac.exe s'exécute et trouve bienvenue.java, mais écrit un message d'erreur. Il s'agit en général d'une erreur dans le fichier source. Le message d'erreur vous donne une indication sur la nature de l'erreur et sur la ligne où elle s'est produite. Essayez de comprendre. Dans la plupart des cas, il s'agit : (i) d'un point-virgule oublié à la fin d'une instruction simple; (ii) d'une faute de syntaxe; (iii) d'une confusion majuscule/minuscule; (iv) d'une accolade fermante oubliée. Il vous faut alors corriger l'erreur dans le fichier Bienvenue.java et recommencer la compilation. Prenez bien note des points suivants:\nLes programmes Java sont écrits dans des fichiers au format texte ayant l'extension «.java». Le nom du fichier (par exemple Bienvenue.java) doit correspondre au code: un fichier Java comporte généralement une déclaration « public class » qui détermine le nom du fichier. Ainsi donc si votre code Java contient la déclaration « public class Bienvenue » alors le fichier doit être nommé Bienvenue.java. La plupart des fichiers en Java ne contiennent qu'une seule « classe ». Un programme Java exécutable doit contenir une méthode nommée « main ». Tous les fichiers Java n'ont pas une méthode « main », mais ceux qui en contiennent une peuvent souvent être exécutés. Beaucoup des exemples dans le cours peuvent être recopiés et exécutés, mais vous devez choisir le bon nom de fichier (correspondant à la classe). Si vous modifiez du code, même très légèrement, et qu'il ne fonctionne plus, revenez en arrière. Il faut avoir beaucoup de rigueur pour programmer, vous ne pouvez pas juste modifier du code en suivant votre instinct et espérer que tout fonctionne. Vous devez apprendre et comprendre avant de pouvoir modifier du code. Vous ne devez en aucun cas copier du code au sein d'autre code en espérant que tout fonctionne. Le copier-coller sans comprendre ce que l'on fait ne fonctionnera pas. Pour commencer, ne changez absolument rien, rien, au code. Copiez le code à l'identique, caractère par caractère.Tout doit être identique. Le nom de fichier, le nom de la classe, le nom des méthodes, etc. Exécution # Après la réussite de la compilation et la création du fichier Bienvenue.class, il faut l'exécuter avec l'interpréteur (la JVM) java.exe (java sous OSX et Linux). À partir de la console/invite de commande, il suffit d'exécuter la commande \"java Bienvenue\". Si tout se passe bien, on voit apparaître le message prévu : Bienvenue au cours INF 1220! Sinon, il y a sans doute un problème de répertoire actif ou de chemin d'accès à java.exe\nCréation d\u0026rsquo;une classe avec repl.it # Vous pouvez aussi utiliser repl.it. Dans ce cas, il suffit d'aller en ligne et d'utiliser l'interface graphique.\nEn général, vous pouvez créez vos propres programmes sur repl.it. Repl.it est une plateforme en ligne pour écrire et tester du code Java sans installation. Cliquez sur les liens Repl.it du cours pour ouvrir les projets Java. Voici un exemple pertinent déjà en place.\nSi vous utilisez repl.it, vous devez tenir compte que la classe contenant la fonction exécutable (main) doit être nommée Main, mais c'est un détail technique spécifique à repl.it qui ne change pas la nature de l'exercice.\nVidéo suggérée # Création d\u0026rsquo;une classe avec ideone.com # Vous pouvez aussi utiliser ideone.com. Le fonctionnement est similaire à repl.it. Encore une fois, vous devrez créer un compte gratuit.\nCréation d\u0026rsquo;une classe avec IntelliJ IDEA, sa compilation et son exécution # Si vous avez installé l'IDE IntelliJ IDEA lors de l'activité précédente, vous pouvez maintenant l'utiliser pour écrire et exécuter du code Java.\nAprès avoir lancé IntelliJ IDEA, suivez les consignes suivantes:\nChoisissez \"Create New Project\". Choisissez \"Java\" et cliquez sur \"Next\". Choisissez \"Create project from template\", puis \"Command Line App\" et cliquez sur \"Next\". Choisissez un nom pour votre project ou utilisez le nom par défaut, puis cliquez sur \"Next\". Vous trouverez alors un bout de code. Tapez System.out.println(\"Allo\"); en plein milieu du code, remplaçant la ligne qui débute par //, entre les deux accolades. Allez dans le menu \"Run\" et choisissez \"Run Main\". Une console devrait s'ouvrir et vous devriez y voir le texte \"Allo\". L'IDE IntelliJ permet, comme les autres IDE, l'ajout de nouvelles classes à un projet.\nTout comme les autres IDE, IntelliJ est difficile d'utilisation pour les débutants. Il expose le débutant à un environnement inutilement complexe. Néanmoins, plusieurs étudiants insistent pour utiliser des IDE. Nous donnons ici la base, mais si vous souhaitez prendre cette approche, vous devrez apprendre à vous retrouver dans un environnement complexe qui n'est pas destiné aux débutants. Nous vous rappelons que nous n'offrons pas de soutien technique. Si vous avez du mal avec IntelliJ, c'est votre responsabilité de trouver l'information pertinente. L'utilisation IntelliJ est purement optionnelle.\nVidéo suggérée # (YouTube offre des sous-titres en français.)\nL'approche est essentiellement la même pour les autres IDE comme Eclipse et NetBeans. On créé un projet, on écrit son code, et on exécute. Tous les IDE peuvent vous aider à identifier vos erreurs de syntaxe.\nCréation d\u0026rsquo;une classe avec NetBeans, sa compilation et son exécution # Si vous avez installé l'IDE Netbeans lors de l'activité précédente, il est maintenant le temps d'utiliser cet outil de développement très utile, permettant d'accélérer et de simplifier les étapes dans le développement d'une application. Voici les étapes pour réaliser l'équivalent de l'activité précédente.\nPour créer un projet aller dans \"File\" (ou Fichier) et sélectionner \"New Project\" (Nouveau projet). Choisir dans la fenêtre de type \"Wizard\", un projet de type Java (liste de gauche) et Java Application (liste de droite). Appuyer sur \"Next\" (Suivant). Entre le nom du projet, par exemple \"Exercice1\" et assurer vous que la case \"Create Main Class\" soit cochée. Ceci va créer automatiquement une classe \"Exercice1\" avec une méthode \"main\". Appuyer sur \"Finish\" (Terminer). Une fois le projet crée, celui-ci apparaît dans la liste des projets à gauche. Vous pouvez avoir plusieurs projets à la fois et naviguez entre les classes de ces projets via l'arborescence. La classe \"Exercice1\", qui a été auto-générée, apparaît dans la partie droite de la fenêtre de l'IDE. Copier la ligne \"System.out.println(\"Bienvenue au sein du cours INF1220 !\");\" et l'ajouter dans la portée de la fonction main. Enregistrer le fichier (via le menu) suite à la modification. Nous allons maintenant compiler et exécuter cette classe et cette fonction main. Pour ce faire, faite un clique droit sur le fichier \"Exercice1.java\" dans le fenêtre de gauche et choisir l'option \"Run File\". L'IDE Netbeans va alors vérifier si le fichier a été modifié. Si c'est le cas (nous avons ajouté une ligne ...), il va compiler la classe (via javac), puis exécuter celle-ci automatique (via java). Le résultat de l'affichage à la console de l'opération System.out.println(\"Bienvenue au sein du cours INF1220 !\"), apparaît dans la fenêtre de console au bas de l'IDE. Vous pouvez également vous créer une seconde classe dans le projet en utilisant l'option du menu \"File\u003eNew File\". Choisir dans le fenêtre de type \"Wizard\", un fichier de catégorie Java et de type \"Java Class\". Appuyer sur \"Next\". Choisir un nom de classe (différent de Exercice1), par exemple \"AutreClasse\", puis appuyer sur terminer. Vous pouvez dans la nouvelle classe recopier la fonction main de \"Exercice1\", puis compiler et exécuter celle-ci. Tout comme IntelliJ, l'utilisation de NetBeans est optionnelle. Ce n'est pas un environnement destiné aux débutants. Si vous choisissez d'utiliser NetBeans, c'est à vous de faire le travail d'assimilation nécessaire.\nVidéo suggérée # Lecture optionnelle dans le livre de référence (Delannoy) (optionnel) # Vous pouvez lire dans Programmer en Java de Claude Delannoy, le premier chapitre. Le manuel de Delannoy est à son mieux comme manuel de référence. On vous invite à faire les lectures à et garder le manuel avec vous lors que vous étudiez si vous en avez fait l'acquisition. Le manuel de Delannoy n'est pas obligatoire.\nVidéos suggérées # "},{"id":10,"href":"/inf1220-hugo/docs/modules/module3/github/","title":"GitHub","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" GitHub (optionnel) # GitHub est un site où les programmeurs partagent leur code et travaillent de manière collaborative sur des projets de programmation. Si vous créez un compte et apprenez à utiliser Git, vous pourrez y partager votre code, ou contribuer au code d\u0026rsquo;autres projets. C\u0026rsquo;est une excellente manière de développer un portfolio afin d\u0026rsquo;impressionner les employeurs potentiels. Vous trouverez le professeur responsable du cours sur GitHub. Encore une fois, tout s\u0026rsquo;y déroule en anglais, mais si vous ne maîtrisez pas l\u0026rsquo;anglais, vous aurez du mal à faire carrière en informatique.\nCréation d’un compte sur github # GitHub, lancé en 2008, est une plateforme qui a révolutionné la collaboration dans le développement logiciel en s’appuyant sur Git, un système de contrôle de version créé par Linus Torvalds en 2005. Pour commencer, la première étape consiste à se créer un compte. Rendez-vous sur le site officiel de GitHub et cliquez sur l\u0026rsquo;option pour créer un compte. Remplissez les champs requis : une adresse e-mail, un mot de passe et un nom d’utilisateur unique. GitHub vous demandera de vérifier votre adresse e-mail via un code envoyé par courriel. Une fois cette étape complétée, vous pouvez personnaliser votre profil et choisir un plan, gratuit ou payant, selon vos besoins. Historiquement, GitHub a démocratisé l’accès au contrôle de version, rendant les projets open source plus accessibles, comme en témoigne son acquisition par Microsoft en 2018, qui a amplifié son influence.\nInstallation et configuration de git # Avant d’utiliser GitHub, il faut installer Git localement. Git, conçu pour gérer les versions du noyau Linux après l’échec de solutions comme BitKeeper, est un outil décentralisé permettant de suivre les modifications dans le code. Téléchargez Git depuis son site officiel ou via un gestionnaire de paquets (par exemple, apt sur Ubuntu ou brew sur macOS). Une fois installé, configurez votre identité avec les commandes git config \u0026ndash;global user.name \u0026ldquo;Votre Nom\u0026rdquo; et git config \u0026ndash;global user.email \u0026ldquo;votre@email.com\u0026rdquo;. Ces informations lieront vos contributions à votre compte GitHub.\nUtilisation de git sur windows # Pour les utilisateurs de Windows, Git peut être installé via le programme « GitHub Desktop », disponible sur le site officiel de Git. Ce paquet inclut Git Bash, une interface en ligne de commande simulant un environnement Unix, ainsi qu’une interface graphique optionnelle. Après l’installation, ouvrez Git Bash ou l’invite de commande Windows. Les commandes Git (comme git clone, git add, git commit) fonctionnent de manière identique à celles des autres systèmes. Cependant, prenez garde aux différences dans la gestion des fins de ligne : Windows utilise CRLF, contrairement à LF sur Unix. Pour éviter des problèmes, exécutez git config \u0026ndash;global core.autocrlf true afin que Git convertisse automatiquement les fins de ligne lors des commits et checkouts. Historiquement, l’adoption de Git sur Windows a été facilitée par ces outils, rendant le contrôle de version accessible même dans un écosystème traditionnellement moins orienté vers la ligne de commande.\nCréation d’un dépôt sur github # Un dépôt, ou « repository », est l’espace où sont stockés les fichiers d’un projet et leur historique. Sur GitHub, cliquez sur « New repository » depuis votre tableau de bord. Donnez un nom au dépôt, choisissez sa visibilité (public ou privé) et, si vous débutez, cochez l’option pour inclure un fichier README. Ce fichier sert souvent de vitrine pour décrire le projet. Historiquement, les dépôts GitHub ont permis de centraliser des projets décentralisés, facilitant la collaboration mondiale. En arrière-plan, GitHub utilise Git pour gérer les versions, mais ajoute une interface graphique et des outils comme les pull requests, qui n’existent pas dans Git seul.\nClonage et premières modifications locales # Pour travailler sur un projet, commencez par cloner le dépôt sur votre machine avec la commande git clone \u0026lt;URL-du-dépôt\u0026gt;, où l’URL est fournie par GitHub. Cela crée une copie locale du dépôt. Naviguez dans le dossier cloné avec cd \u0026lt;nom-du-dépôt\u0026gt;. Vous pouvez maintenant modifier des fichiers ou en ajouter. Utilisez git add pour indiquer les fichiers modifiés à inclure dans le prochain commit, puis git commit -m \u0026ldquo;Description des changements\u0026rdquo; pour enregistrer ces modifications. Théoriquement, un commit est un instantané immuable, lié à ses prédécesseurs par des hachages SHA-1, garantissant l’intégrité de l’historique.\nSynchronisation avec github # Pour envoyer vos modifications vers GitHub, utilisez git push origin main, où « main » est la branche principale (parfois appelée « master » dans des projets plus anciens). Si d’autres contributeurs ont modifié le dépôt entre-temps, vous devrez peut-être récupérer leurs changements avec git pull pour résoudre d’éventuels conflits. Historiquement, cette synchronisation a résolu les problèmes de collaboration rencontrés dans les projets des années 1990, où les développeurs s’échangeaient des patchs par e-mail. GitHub, en centralisant les dépôts, a simplifié ce processus tout en préservant la décentralisation inhérente à Git.\nCollaboration via branches et pull requests # Git excelle dans la gestion des branches, permettant à plusieurs développeurs de travailler sur des fonctionnalités distinctes sans interférer. Créez une branche avec git branch et passez-y avec git checkout (ou combinez les deux avec git checkout -b ). Une fois vos modifications terminées, poussez la branche vers GitHub (git push origin ) et ouvrez une pull request sur l’interface de GitHub. Les pull requests, introduites par GitHub, formalisent l’examen et l’intégration des contributions. Théoriquement, les branches sont des pointeurs vers des commits, permettant une exploration parallèle de l’historique sans affecter la branche principale.\nPerspective historique et théorique # Git et GitHub incarnent une évolution majeure dans la gestion de code. Git, né d’une nécessité pratique pour Linux, a introduit un modèle décentralisé robuste, contrastant avec les systèmes centralisés comme SVN. GitHub, en ajoutant une couche sociale et collaborative, a transformé Git en un outil universel, utilisé bien au-delà du développement logiciel, par exemple pour des projets d’écriture ou de données. Théoriquement, Git repose sur des principes de cryptographie (hachages) et de théorie des graphes, garantissant traçabilité et cohérence. Ensemble, ils ont redéfini la collaboration, rendant les contributions transparentes et traçables, comme le montrent des projets emblématiques comme TensorFlow ou Linux.\nSite du manuel # Si ce n\u0026rsquo;est pas déjà fait, vous pouvez consulter le code source des exemples du manuel sur GitHub. Prenez en connaissance. Pouvez-vous naviguer dans les fichiers? Pouvez-vous charger le code sur votre machine ?\nExercice pratique # Pour consolider vos connaissances, essayez cet exercice : créez un compte GitHub, configurez Git localement, puis créez un dépôt nommé « mon-premier-projet ». Ajoutez un fichier README.md avec une brève description. Clonez le dépôt, créez une branche appelée « feature », ajoutez un fichier texte avec un court message, commitez et poussez la branche vers GitHub. Enfin, ouvrez une pull request pour fusionner vos changements dans la branche principale. Si vous rencontrez des difficultés, consultez la documentation officielle de GitHub ou les tutoriels disponibles sur leur site.\n"},{"id":11,"href":"/inf1220-hugo/docs/modules/module2/pasapas/","title":"Java pas à pas","section":"Module 2: Introduction au langage Java","content":" Java pas à pas # Nous vous invitons maintenant à lire les chapitres suivants du manuel Java pas à pas par Robert Godin et Daniel Lemire.\nChapitre 2. Introduction à la programmation Java Chapitre 4. Types et expressions Java Les chapitres comprennent plusieurs exemples et exercices. Vous devez compléter les exercices du manuel.\nAprès votre lecture, répondez aux questions suivantes.\nChapitre 2. Introduction à la programmation Java\nQuelles sont les principales étapes de la création et de l\u0026rsquo;exécution d’un programme Java, et pourquoi la méthode main() est-elle essentielle dans ce processus ? Expliquez la différence entre une déclaration de variable et une initialisation de variable à la déclaration dans une méthode Java. Donnez un exemple concret pour illustrer votre réponse. Comment la classe Scanner est-elle utilisée pour lire des données saisies par l’utilisateur, et quelles précautions doivent être prises lors de son importation et de son utilisation ? Chapitre 4. Types et expressions Java\nQuels sont les types primitifs en Java, et comment les littéraux associés à ces types sont-ils utilisés dans les expressions ? Donnez un exemple pour chaque type primitif mentionné. Décrivez le rôle de la classe java.lang.Math dans le traitement des fonctions mathématiques en Java. Fournissez un exemple d’expression utilisant une méthode de cette classe pour résoudre un calcul spécifique. Plusieurs étudiants trouvent qu\u0026rsquo;il est plus aisé de faire les lectures dans le manuel Java pas à pas après avoir terminé la lecture du module sur notre site web. Vous pouvez choisir quand il vous convient le mieux d\u0026rsquo;utiliser le manuel Java pas à pas.\nVous avez accès au document PDF. Si vous devez lire un document PDF, nous vous encourageons à charger le fichier sur votre machine et à l\u0026rsquo;ouvrir au sein d\u0026rsquo;un outil dédié (par ex. Adobe Acrobat). Il n\u0026rsquo;est pas très pratique de lire un document PDF au sein d\u0026rsquo;un navigateur web.\nVous pouvez aussi acheter la version papier du manuel Java pas à pas chez Amazon:\n"},{"id":12,"href":"/inf1220-hugo/docs/modules/module5/activite-5-2/","title":"Le polymorphisme","section":"Module 5. La programmation orientée objet: héritage et le polymorphisme","content":" Le polymorphisme # Le polymorphisme est la capacité d’un même nom de méthode à s’adapter à différents contextes, selon l’objet qui l’utilise. Cela permet de manipuler des objets de différentes classes de façon uniforme, sans se soucier de leur type précis. En Java, la machine virtuelle (JVM) choisit automatiquement la bonne méthode à exécuter selon la classe réelle de l’objet. On distingue trois formes principales de polymorphisme : ad hoc (surcharge), par héritage (redéfinition), et paramétrique (génériques). Chacune permet d’écrire du code plus flexible et réutilisable.\nLe polymorphisme ad hoc # Le polymorphisme ad hoc, aussi appelé surcharge de méthodes (overloading), consiste à définir plusieurs méthodes portant le même nom mais acceptant des paramètres différents (par leur nombre ou leur type). C’est la signature de la méthode qui change. Lorsqu’on appelle la méthode, Java choisit la version appropriée selon les arguments fournis. Par exemple, on peut écrire plusieurs méthodes `calculMoyenne` : l’une prenant un tableau d’entiers, l’autre un tableau de réels. Ce mécanisme permet d’adapter un même nom d’opération à différents types de données, ce qui rend le code plus lisible et modulaire. Dans d’autres langages comme C++, la surcharge permet aussi de redéfinir des opérateurs (par exemple, l’opérateur == pour comparer deux objets).\nL’exemple suivant montre trois méthodes `ajouterGradient` dans la classe `MixageCouleur`, chacune acceptant des types de paramètres différents (entiers, flottants, ou un objet Color). Selon le type d’argument passé, la bonne méthode est appelée automatiquement.\nMixageCouleur.java import java.awt.Color; public class MixageCouleur { int rouge = 0; int vert = 0; int bleu = 0; public MixageCouleur(int rouge, int vert, int bleu) { this.rouge = rouge; this.bleu = bleu; this.vert = vert; } public void ajouterGradient(int rouge, int vert, int bleu) { this.rouge \u0026#43;= rouge; this.bleu \u0026#43;= bleu; this.vert \u0026#43;= vert; } public void ajouterGradient(float rouge, float vert, float bleu) { this.rouge \u0026#43;= (int) rouge; this.bleu \u0026#43;= (int) bleu; this.vert \u0026#43;= (int) vert; } public void ajouterGradient(Color color) { this.rouge \u0026#43;= color.getRed(); this.bleu \u0026#43;= color.getBlue(); this.vert \u0026#43;= color.getGreen(); } public static void main(String[] args) { MixageCouleur mixeur = new MixageCouleur(100, 100, 100); mixeur.ajouterGradient(10, 5, 15); mixeur.ajouterGradient(Color.PINK); } } Exécuter Le polymorphisme par héritage # Le polymorphisme par héritage, ou redéfinition de méthode (overriding), consiste à réécrire dans une sous-classe une méthode déjà définie dans la classe parente. Cela permet à chaque sous-classe de personnaliser le comportement hérité. Lorsqu’on manipule un objet via une référence de la classe parente, c’est toujours la version la plus spécifique (celle de la sous-classe) qui est exécutée. Ce mécanisme est au cœur de la programmation orientée objet, car il permet d’utiliser des collections d’objets variés de façon uniforme, tout en conservant leur comportement propre.\nDans l’exemple, la classe `CerclePointille` définit une méthode `dessiner` pour tracer un cercle en pointillé. La sous-classe `OvalePointille` redéfinit cette méthode pour dessiner un ovale pointillé. Même si on manipule un `OvalePointille` via une référence de type `CerclePointille`, c’est la méthode redéfinie qui sera appelée.\nimport java.awt.Color; import java.awt.Dimension; import java.awt.EventQueue; import java.awt.Graphics; import java.awt.Graphics2D; import java.awt.RenderingHints; import javax.swing.JFrame; import javax.swing.JPanel; /** * Classe permettant de dessiner un cercle pointillé. */ public class CerclePointille extends JPanel { // Distance entre les points protected final static int DISTANCE_ENTRE_POINT = 10; protected float rayon = 0; protected int posX = 0; protected int posY = 0; public CerclePointille(float rayon) { this.rayon = rayon; this.posX = posX; this.posY = posY; } @Override protected void paintComponent(Graphics g) { super.paintComponent(g); //To change body of generated methods, choose Tools | Templates. dessiner(g); } public void dessiner(Graphics g) { //Calculer le périmètre double perimeter = (rayon * 2) * Math.PI; //Calculer le nombre de point à dessiner int nbPoint = (int) (perimeter / DISTANCE_ENTRE_POINT); //position de départ int x = this.getWidth()/2; int y = this.getHeight()/2 + (int) rayon; Graphics2D g2d = (Graphics2D) g; g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); g2d.setColor(Color.BLACK); for (int i = 0; i \u0026lt; nbPoint; i++) { double t = 2 * Math.PI * i / nbPoint; int x1 = (int) Math.round(x + rayon * Math.cos(t)); int y1 = (int) Math.round(y + rayon * Math.sin(t)); g2d.fillOval(x1 - (int) rayon, y1 - (int) rayon, 10, 10); } } private static void create() { JFrame f = new JFrame(); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); CerclePointille cercle = new CerclePointille(50); cercle.setPreferredSize(new Dimension(300, 300)); f.add(cercle); f.pack(); f.setVisible(true); } public static void main(String[] args) { EventQueue.invokeLater(new Runnable() { @Override public void run() { create(); } }); } } Cette classe permet de tracer un cercle en pointillé dans une fenêtre appelée JFrame. Nous viendrons surcharger la méthode dessiner dans une sous-classe afin de permettre de tracer des ovales pointillés :\nimport java.awt.Color; import java.awt.Dimension; import java.awt.EventQueue; import java.awt.Graphics; import java.awt.Graphics2D; import java.awt.RenderingHints; import javax.swing.JFrame; public class OvalePointille extends CerclePointille { protected float rayonHorizontal = 0; public OvalePointille(float rayonVertical, float rayonHorizontal) { //RayonVertical sera le Rayon super(rayonVertical); this.rayonHorizontal = rayonHorizontal; } //Surcharge ou polymorphisme par héritage @Override public void dessiner(Graphics g) { //Calculer le périmètre double perimeter = (rayon * 2) * Math.PI; //Calculer le nombre de point à dessiner int nbPoint = (int) (perimeter / DISTANCE_ENTRE_POINT); //position de départ int x = this.getWidth()/2; int y = this.getHeight()/2 + (int) rayon; Graphics2D g2d = (Graphics2D) g; g2d.setRenderingHint( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); g2d.setColor(Color.BLACK); for (int i = 0; i \u0026lt; nbPoint; i++) { double t = 2 * Math.PI * i / nbPoint; // Dessiner avec différent rayon pour tracer l\u0026#39;oval int x1 = (int) Math.round(x + rayonHorizontal * Math.cos(t)); int y1 = (int) Math.round(y + rayon * Math.sin(t)); g2d.fillOval(x1 - (int) rayon, y1 - (int) rayon, 10, 10); } } private static void create() { JFrame f = new JFrame(); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); OvalePointille ovale = new OvalePointille(50,30); ovale.setPreferredSize(new Dimension(300, 300)); f.add(ovale); f.pack(); f.setVisible(true); } public static void main(String[] args) { EventQueue.invokeLater(new Runnable() { @Override public void run() { create(); } }); } } Dans cette dernière classe, nous avons donc redéfini la méthode afin de spécialiser la méthode dessiner. Même si nous faisons un \"cast\" de la classe en CerclePointille (CerclePointille cercle = new OvalePointille(10)), ce sera tout de même la méthode surchargée qui sera appelée.\nLe polymorphisme paramétrique (génériques) # Le polymorphisme paramétrique, ou utilisation de génériques, permet d’écrire des classes ou des méthodes qui fonctionnent avec différents types d’objets, sans dupliquer le code. En Java, cela se fait grâce aux « templates » (génériques). Par exemple, la classe `ArrayList` peut contenir des éléments de n’importe quel type : `ArrayList`, `ArrayList`, etc. On peut aussi écrire des méthodes génériques, comme une fonction `equals` qui compare deux objets de n’importe quel type. Les génériques rendent le code plus sûr (détection d’erreurs à la compilation) et plus réutilisable.\nL’exemple montre comment déclarer une méthode générique avec `` ou une classe générique avec ``. On peut aussi utiliser plusieurs paramètres génériques si besoin.\npublic class TestGenerique { public static \u0026lt;T\u0026gt; boolean equals(T a, T b) { return a.equals(b); } public static void main(String[] args) { String allo = \u0026#34;allo\u0026#34;; String bonjour = \u0026#34;bonjour\u0026#34;; System.out.println(equals(allo, bonjour)); } } public class TestGenerique { public static \u0026lt;T,U\u0026gt; boolean equals(T a, U b) { return a.equals(b); } public static void main(String[] args) { String allo = \u0026#34;allo\u0026#34;; String bonjour = \u0026#34;bonjour\u0026#34;; System.out.println(equals(allo, bonjour)); } } public class Chainon\u0026lt;T\u0026gt; { protected T donnee = null; protected Chainon\u0026lt;T\u0026gt; prochainChainon; public Chainon(T donnee) { this.donnee = donnee; prochainChainon = null; } public void addChainon(Chainon\u0026lt;T\u0026gt; chainon) { prochainChainon = chainon; } public void removeChainon() { prochainChainon = null; } public Chainon\u0026lt;T\u0026gt; getNext() { return prochainChainon; } public boolean hasNext() { if (prochainChainon == null) { return false; } else { return true; } } public T getDonnee() { return donnee; } public void setDonnee(T donnee) { this.donnee = donnee; } public static void main(String[] args) { Chainon\u0026lt;String\u0026gt; chaine1 = new Chainon\u0026lt;String\u0026gt;(\u0026#34;Veni\u0026#34;); Chainon\u0026lt;String\u0026gt; chaine2 = new Chainon\u0026lt;String\u0026gt;(\u0026#34;Vidi\u0026#34;); Chainon\u0026lt;String\u0026gt; chaine3 = new Chainon\u0026lt;String\u0026gt;(\u0026#34;Vici\u0026#34;); chaine1.addChainon(chaine2); chaine2.addChainon(chaine3); Chainon\u0026lt;String\u0026gt; iterateur = chaine1; //Façon peu recommendé d\u0026#39;utiliser le for ... for(boolean iterate = true; iterate == true;) { System.out.println(iterateur.getDonnee()); if(iterateur.hasNext()) { iterateur = iterateur.getNext(); } else { iterate = false; } } } } Il est possible d'omettre le type. Dans un tel cas, Java va omettre la vérification de la classe, comme dans cet exemple:\nArrayList al = new ArrayList(); al.add(1); Dans un tel cas, Java peut émettre un avertissement à la compilation.\nEn résumé # Voici les trois formes principales de polymorphisme en Java, avec leur principe et un exemple concret pour chacune.\nType de polymorphisme Description Exemple en Java Ad hoc (surcharge) Plusieurs méthodes portent le même nom mais ont des paramètres différents. void f(int x) et void f(double x) Par héritage (redéfinition) Une méthode d’une classe parente est redéfinie dans une sous-classe. @Override void dessiner() dans une sous-classe Paramétrique (génériques) Une méthode ou une classe fonctionne avec différents types d’objets. ArrayList\u0026lt;String\u0026gt;, public \u0026lt;T\u0026gt; void f(T x) Lecture optionnelle dans le livre de référence (Delannoy) # Pour aller plus en profondeur (optionnel), vous pouvez lire dans Programmer en Java de Claude Delannoy, Chapitre 8 et 21:\nChapitre 8 - Section 6 : Le polymorphisme Chapitre 21 - Section 1 : Notion de classe générique Chapitre 21 - Section 2 : Compilation du code générique Chapitre 21 - Section 3 : Méthode générique Chapitre 21 - Section 5 : Héritage et programmation générique Vidéos # Il y a une liste de vidéos sur le polymorphisme par Sam et al. "},{"id":13,"href":"/inf1220-hugo/docs/modules/module4/activite-4-2/","title":"Les flux de données: lecture dans des fichiers et autres","section":"Module 4: Les entrées et sorties","content":" Les flux de données: lecture dans des fichiers et autres # Nous avons couvert la façon d'afficher des données à l'écran et de lire des données à partir du clavier en utilisant les flux de données (streams) dans les leçons précédentes. Quand nous avons utilisé les méthodes System.out.print ou System.out.println pour afficher des données à l'écran, ces dernières ont été envoyées sur un flux de sortie (output stream). Nous nous servirons des flux d'entrée et de sortie pour lire et écrire des données dans un fichier texte. Mais auparavant, il nous faut savoir comment créer le fichier dans lequel ces données seront archivées.\nPour manipuler les flux d'entrée et de sortie, nous utilisons les classes du package java.io. Les données sont manipulées suivant deux principes : la lecture/écriture en flux binaire ou en flux texte. Le tableau ci-dessous représente les différents flux que nous pouvons manipuler ainsi que les classes abstraites de base, l'implémentation, les fichiers et les tampons d'entrée-sortie qui leur sont associés.\nFlux texte (lecture) Flux texte (écriture) Flux binaire (lecture) Flux binaire (écriture) Classe abstraite de base Reader Writer InputStream OutputStream Implémentation InputStreamReader PrintWriter DataInputStream DataOutputStream Fichier FileReader FileWriter FileInputStream FileOutputStream Buffer E/S BufferedReader BufferedWriter BufferedInputStream BufferedOutputStream La classe File # Pour travailler avec les fichiers et les répertoires, nous utilisons la classe File. Un objet de cette classe peut représenter un fichier ou un répertoire. Il est très important de savoir qu\u0026rsquo;il n\u0026rsquo;est pas nécessaire d\u0026rsquo;avoir physiquement le fichier ou le répertoire sur un disque avant d\u0026rsquo;utiliser la classe File. Pour utiliser cette classe, nous devons intégrer le package java.io.* dans notre programme.\nLa classe File dispose d\u0026rsquo;un constructeur qui prend en paramètre l\u0026rsquo;emplacement du fichier que nous voulons créer. Si cet emplacement n\u0026rsquo;est pas spécifié et que c\u0026rsquo;est seulement le nom du fichier qui est passé en paramètre, ce dernier est créé dans le répertoire par défaut.\nPour créer un fichier, nous appelons le constructeur de la classe File de la façon suivante :\nFile exempleFile1= new File (\u0026#34;fichier\u0026#34;); File exempleFile2= new File (\u0026#34;c:\\exemple\\unFichier.txt\u0026#34;); Dans le premier cas, un objet File, agissant comme référence vers le fichier dans l'arborescence du système de fichier, et ce pour un fichier du nom \"fichier\" dans le répertoire courant (\".\" dans Linux/Mac OS) sera crée. Dans le deuxième cas, une référence vers le fichier sur le disque \"C:\", dossier \"/exemple\", fichier \"unFichier.txt\" sera créée (exemple pour Windows ...). À ce stade, aucun fichier n'est crée ou ouvert, il ne s'agit que d'une référence vers l'emplacement possible d'un fichier. Pour savoir si le fichier existe ou non, il est possible d'utiliser la méthode exists() :\nFile unFichier = new File(\u0026#34;lefichier\u0026#34;); // création d\u0026#39;un objet fichier if (!unFichier.exists()) { System.out.println(\u0026#34;le fichier n\u0026#39;existe pas!\u0026#34;); } Pour créer un nouveau fichier sur un disque dur, il faut, dans un premier temps, créer l'objet File avec le nom du fichier voulu et, par la suite, utiliser la méthode createNewFile(), comme le montre le code ci-dessous :\nFile unFichier = new File(\u0026#34;lefichier\u0026#34;); // création d\u0026#39;un objet fichier if (unFichier.createNewFile()) { System.out.println(\u0026#34;le fichier est créé!\u0026#34;); } else { System.out.println(\u0026#34;le fichier ne pas être créé\u0026#34;); } Lecture d\u0026rsquo;un fichier # Lecture dans un fichier de bas niveau En informatique, on fait référence à une approche de bas niveau quand celle-ci demande au programmeur de tenir compte de plus de détails techniques. Les approche de bas niveau demandent plus d'effort, mais peuvent offrir plus de flexibilité.\nJava possède deux classes, à savoir FileReader et File, qui nous permettent de lire un fichier texte de bas niveau. Pour cela, nous devons connaître le fichier que nous voulons lire. Pour cette leçon, nous avons choisi de lire le fichier unfichier.\nPour lire un fichier, nous devons d'abord construire un objet de type File (la classe File), qui prend comme paramètre le nom du fichier à lire. Ici, il s'agit de unfichier, et nous obtenons :\ntry { FileReader fichierALire = new FileReader(\u0026#34;unfichier\u0026#34;); // ou bien en utilisant l\u0026#39;objet File dans le constructeur File file = new File(\u0026#34;unFichier\u0026#34;); fichierALire = new FileReader(file); } catch (IOException exception) { System.out.println(\u0026#34;Le fichier n\u0026#39;a pas été trouvé\u0026#34;); } Note: dans cet exemple, la variable fichierALire est déclarée comme étant de type FileReader lors de sa première utilisation. On ne peut déclarer une même variable qu'une seule fois. On peut cependant réassigner la variable à une autre valeur. Il est donc légal d'écrire \"FileReader fichierALire = new ...\" suivi de \"fichierALire = new ...\" (sans répéter le nom de la classe, FileReader). Par contre, il serait illégal en Java d'écrire \"FileReader fichierALire = new ...\" suivi de \"FileReader fichierALire = new ...\" dans le même contexte puisqu'on déclarerait la variable deux fois. Nous venons juste de créer une instance de l'objet FileReader permettant de lire le contenu d'un fichier. Cependant, la classe FileReader ne possède que des méthodes pouvant lire « en bas niveau », c'est-à-dire que la méthode read permet de lire caractère par caractère le contenu d'un fichier. Cette méthode peut lever une exception si, par exemple, nous ne pouvons accéder au disque dur ou si le fichier en question est protégé. Voici comment lire un caractère d'un fichier :\ntry { FileReader fichierALire = new FileReader(\u0026#34;unfichier\u0026#34;); char caractere = (char) fichierALire.read(); System.out.print(caractere); } catch (FileNotFoundException exception) { System.out.println(\u0026#34;Il y a une erreur lors de la lecture: \u0026#34; + exception.getMessage()); } Avec tout ce que nous avons vu jusqu'à présent, nous ne pouvons écrire qu'un seul caractère à l'écran. À chaque appel de la méthode read, un caractère est lu. Pour lire un fichier en entier, il faut donc vérifier si la méthode read renvoie -1 car c'est cette valeur qui indique la fin d'un fichier. Le code ci-dessous montre comment nous pouvons procéder :\ntry { FileReader fichierALire = new FileReader(\u0026#34;unfichier\u0026#34;); int c = fichierALire.read(); while (c != -1) {// tant que nous ne sommes pas à la fin du fichier System.out.print((char) c); c = fichierALire.read(); } } catch (IOException exception) { System.out.println(\u0026#34;Il y a une erreur lors de la lecture: \u0026#34; + exception.getMessage()); } Pour terminer, il ne reste qu'à fermer le FileReader, en effet, lorsqu'un programme effectue une opération d'entrée-sortie, celui-ci doit demander de l'aide au système d'exploitation et ce dernier va mobiliser des ressources comme le disque dur. Une fois l'opération d'entrée-sortie terminée, vous devez le signaler pour que le système d'opération puisse libérer les ressources que vous n'utilisez plus. En Java, il suffit simplement de faire appel à la méthode close comme indiqué ci-dessous.\nfichierALire.close(); Lecture dans un fichier de haut niveau Nous venons de terminer la lecture de bas niveau d'un fichier. Nous abordons maintenant celle de haut niveau, car la classe FileReader n'est pas très efficace. En effet, elle pourrait s'avérer longue en raison du nombre impressionnant d'appels à la méthode read qu'elle devrait faire. La classe BufferedReader permet pour sa part de lire un fichier texte avec des fonctions de niveau supérieur. Avec ces fonctions, nous pouvons, par exemple, lire un fichier texte ligne par ligne.\nPour une lecture de haut niveau d'un fichier avec les fonctions de la classe BufferedReader, il faut créer un objet de type BufferedReader qui doit prendre en paramètre un type Reader et lui donner un objet FileReader. Pour ce faire, il faut d'abord créer le fichier à lire. Le code ci-dessous explique mieux la façon à suivre :\ntry { File FichierALire = new File(\u0026#34;textfichier\u0026#34;); FileReader unFichier = new FileReader(FichierALire); BufferedReader leBuffer = new BufferedReader(unFichier); } catch (FileNotFoundException exception) { System.out.println(\u0026#34; Fichier introuvable!\u0026#34;); } Pour lire maintenant le fichier créé, nous devons utiliser la méthode readLine, qui le fait ligne par ligne et retourne null à la fin du fichier. Nous pouvons réaliser cela grâce au code ci-dessous :\ntry { String uneligne = leBuffer.readLine(); while (uneligne != null) { System.out.println(uneligne); uneligne = leBuffer.readLine(); } leBuffer.close(); unFichier.close(); } catch (IOException exception) { System.out.println(\u0026#34;Il y a une erreur lors de la lecture: \u0026#34; + exception.getMessage()); } Écriture d\u0026rsquo;un fichier texte # Nous aborderons maintenant l'écriture de données vers un fichier texte. Cette dernière sert à les stocker lorsque le programme ne s'exécute plus et en vue de pouvoir les récupérer plus tard ou les envoyer à d'autres personnes. Comme vous le verrez, l'écriture de fichiers texte est assez similaire à leur lecture. Pour écrire, nous allons utiliser les trois classes suivantes FileWriter, BufferedWriter et PrintWriter.\nÉcriture de bas niveau Pour écrire dans un fichier, nous utilisons la classe FileWriter. Nous commençons par créer un objet File qui sera le fichier vers lequel nous désirons écrire. Par la suite, nous produirons l'objet FileWriter. Le fichier représenté par l'objet File sera créé s'il n'existe pas. Dans le cas contraire, le contenu de ce fichier sera complètement écrasé. La classe FileWriter offre des méthodes de bas niveau pour l'écriture. Nous trouvons plusieurs méthodes dont Write pour écrire un caractère, une partie de String ou enfin un String complet. Le code ci-dessous démontre comment écrire des données dans un fichier :\ndouble[] notes = {95.5, 91.5, 78.5, 75.0, 81.50}; File fichier = new File(\u0026#34;notes.txt\u0026#34;); try { FileWriter fichierEcriture = new FileWriter(fichier); for (double lanote : notes) { fichierEcriture.write(String.valueOf(lanote)); fichierEcriture.write(\u0026#34;\\r\\n\u0026#34;); } fichierEcriture.close(); } catch (IOException exception) { System.out.println(\u0026#34;Erreur lors de la lecture : \u0026#34; + exception.getMessage()); } Écriture de haut niveau Les méthodes proposées par la classe FileWriter sont de bas niveau. Par contre, d'autres classes offrant des méthodes de plus haut niveau qui accélèrent et rendent plus facile l'écriture vers un fichier texte. Nous avons la classe BufferedWriter qui offre des méthodes de plus haut niveau et une écriture plus rapide et performante. Son fonctionnement est assez similaire à la celui de la classe BufferedReader. La classe BufferedWriter permet d'avoir une écriture plus performante. Elle propose une méthode supplémentaire, newLine, qui ajoute un retour à la ligne. Le retour à la ligne dans un fichier texte dépend du système d'exploitation ( \\r\\n sous Windows, \\n sous Unix, ...). Alors, il est préférable d'utiliser cette méthode qui peut être portable.\nIl faut donc utiliser une autre classe en plus, par exemple la classe PrintWriter qui se comporte de manière semblable à la classe PrintStream dont l'objet System.out est une instance. Nous pouvons donc réécrire le programme précédent avec ces nouveaux objets pour obtenir une écriture de meilleur rendement.\ndouble[] notes = {95.5, 91.5, 78.5, 75.0, 81.50}; File fichier = new File(\u0026#34;notes.txt\u0026#34;); try { PrintWriter fichierAEcrire = new PrintWriter(new BufferedWriter(new FileWriter(fichier))); for (double lanote : notes) { fichierAEcrire.println(lanote); } fichierAEcrire.close(); } catch (IOException exception) { System.out.println(\u0026#34;Erreur lors de la lecture : \u0026#34; + exception.getMessage()); } Écriture d'un fichier texte avec PrintWriter Nous utilisons donc un PrintWriter (pour les méthodes de haut niveau) par-dessus un BufferedWriter (pour l'écriture rapide) sur un FileWriter (pour l'écriture vers un fichier texte). Il faut noter qu'avec la classe PrintWriter, nous pouvons utiliser des méthodes de haut niveau comme println qui ajoutent une ligne au fichier texte. Cependant, il existe d'autres méthodes très riches comme printf pour les sorties formatées par exemple. Le code ci-dessous montre comment utiliser PrintWriter :\nPrintWriter sortie = null; try { System.out.println(\u0026#34;Plus grand diviseur commun :\u0026#34; + plusGrandCommunDiviseur(455,322) ); File fichier = new File(\u0026#34;fichier.txt\u0026#34;); sortie = new PrintWriter(new BufferedWriter(new FileWriter(fichier))); sortie.println(\u0026#34;Une ligne de texte\u0026#34;); } catch (IOException ex) { Logger.getLogger(ExempleRecursivite.class.getName()).log(Level.SEVERE, null, ex); } finally { sortie.close(); } Approche simplifiée La gestion des cas d'exception et de la nécessité de fermer les fichiers avant de terminer la fonction est pénible. Heureusement, on peut faire mieux si on dispose d'une version récente de Java (Java 8 ou mieux). Toutes les classes nécessitant d'être fermée (\"close\") peuvent être déclarée dans le \"try\" comme ceci:\nimport java.io.*; class MaClasse { public static void main(String[] args) throws IOException { File unFichier = new File(\u0026#34;monfichier\u0026#34;); try ( BufferedReader leBuffer = new BufferedReader(new FileReader(unFichier)); ) { System.out.println(leBuffer.readLine()); } catch (FileNotFoundException exception) { System.out.println(\u0026#34; Fichier introuvable!\u0026#34;); } } } Path et Files # La lecture de fichiers en Java est une tâche courante qui a évolué avec les versions modernes du langage, notamment à partir de Java 7 avec l’introduction de l’API java.nio.file. Cette API, plus robuste et flexible que l’ancienne java.io, simplifie la gestion des fichiers et des répertoires. À partir de Java 21, les développeurs bénéficient d’une syntaxe encore plus concise grâce aux flux (Stream) et aux améliorations des performances, tout en conservant une gestion efficace des erreurs.\nUn concept clé ici est l’utilisation de Path et Files. Un objet Path, créé via Path.of, représente un chemin dans le système de fichiers de manière portable, compatible avec différents systèmes d’exploitation. La classe Files, quant à elle, propose des méthodes statiques pour manipuler les fichiers, comme Files.lines, qui lit un fichier sous forme de flux de lignes. Ce flux permet de traiter les données de manière fonctionnelle, en utilisant des lambdas pour des opérations comme le filtrage ou la transformation.\nMain.java import java.nio.file.Files; import java.nio.file.Path; import java.io.IOException; void main() { try { Path chemin = Path.of(\u0026#34;Main.java\u0026#34;); Files.lines(chemin) .forEach(ligne -\u0026gt; System.out.println(\u0026#34;Lue : \u0026#34; \u0026#43; ligne)); } catch (IOException e) { System.out.println(\u0026#34;Erreur de lecture : \u0026#34; \u0026#43; e.getMessage()); } } Exécuter Accès à l\u0026rsquo;Internet # Java permet aussi d\u0026rsquo;avoir accès à des ressources sur le web. Grâce à ses bibliothèques modernes, comme l\u0026rsquo;API HttpClient introduite dans Java 11, il est possible d\u0026rsquo;effectuer des requêtes HTTP de manière simple et efficace, facilitant la récupération de données depuis des serveurs distants.\nL\u0026rsquo;API HttpClient offre une approche fluide pour interagir avec des ressources en ligne. Dans l\u0026rsquo;exemple fourni, la classe SimpleHttpReader utilise cette API pour envoyer une requête GET à l\u0026rsquo;URL http://worldtimeapi.org/api/timezone/Etc/UTC. Cette URL renvoie des informations sur l\u0026rsquo;heure universelle coordonnée (UTC) au format JSON. La méthode HttpClient.newHttpClient() crée une instance du client HTTP, qui est ensuite utilisée pour construire et envoyer la requête. Cette approche est non seulement concise, mais aussi adaptée aux applications modernes nécessitant des interactions fréquentes avec des services web.\nLa gestion des requêtes dans l\u0026rsquo;exemple est robuste grâce à la vérification du code de statut HTTP. Si le serveur renvoie un code différent de 200 (indiquant une réussite), une exception est levée avec un message clair, permettant une gestion d\u0026rsquo;erreur appropriée. De plus, l\u0026rsquo;utilisation de StandardCharsets.UTF_8 garantit que les données textuelles sont correctement décodées, évitant les problèmes liés aux encodages de caractères. Ce mécanisme illustre comment Java combine simplicité et fiabilité pour accéder aux ressources web.\nUn aspect notable de ce code est sa structure orientée objet et sa facilité d\u0026rsquo;exécution. La méthode main ne prend aucun paramètre, rendant le programme immédiatement exécutable sans configuration supplémentaire. En cas d\u0026rsquo;erreur, un message précis est affiché, indiquant une \u0026ldquo;Erreur lors de la requête HTTP\u0026rdquo; accompagnée de détails sur l\u0026rsquo;exception. Cette clarté est essentielle pour le débogage et la maintenance, en particulier dans des applications plus complexes intégrant de multiples appels réseau.\nEnfin, l\u0026rsquo;exemple démontre la puissance de Java pour intégrer des services web dans des applications. En récupérant des données d\u0026rsquo;une API publique comme worldtimeapi.org, le programme montre comment Java peut être utilisé pour consommer des services RESTful. Cette capacité est cruciale dans le développement d\u0026rsquo;applications modernes, qu\u0026rsquo;il s\u0026rsquo;agisse de microservices, d\u0026rsquo;applications mobiles ou de systèmes de monitoring, où l\u0026rsquo;accès aux données en temps réel est souvent une exigence clé.\nSimpleHttpReader.java import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.nio.charset.StandardCharsets; public class SimpleHttpReader { public static void main(String[] args) { try { String content = readHttpFile(); System.out.println(content); } catch (Exception e) { System.err.println(\u0026#34;Erreur lors de la requête HTTP : \u0026#34; \u0026#43; e.getMessage()); System.exit(1); } } public static String readHttpFile() throws Exception { HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder() .uri(URI.create(\u0026#34;http://worldtimeapi.org/api/timezone/Etc/UTC\u0026#34;)) .GET() .build(); HttpResponse\u0026lt;String\u0026gt; response = client.send(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8)); if (response.statusCode() != 200) { throw new RuntimeException(\u0026#34;Échec de la requête HTTP : \u0026#34; \u0026#43; response.statusCode()); } return response.body(); } } Exécuter Performance # La performance est un enjeu crucial lorsqu’on manipule des fichiers ou des flux de données, surtout avec de grands volumes ou des opérations répétées. Un code inefficace peut entraîner des ralentissements importants, une consommation excessive de mémoire ou des blocages inutiles.\nLire ou écrire un fichier caractère par caractère est très lent. Il vaut mieux utiliser des tampons (buffers) pour traiter plusieurs caractères ou octets à la fois. C\u0026rsquo;est un peu comme essayer d\u0026rsquo;envoyer un message texte par quelqu\u0026rsquo;un caractère par caractère.\nLes requêtes HTTP ou les accès à des fichiers distants sont beaucoup plus lents que les accès en mémoire. Il faut donc limiter leur nombre et traiter les données efficacement.\nDans cet exemple, BufferedReader lit le fichier par blocs (c\u0026rsquo;est-à-dire plusieurs caractères à la fois), ce qui réduit considérablement le nombre d\u0026rsquo;accès disque et accélère la lecture, surtout pour les gros fichiers. Plutôt que de lire un caractère à la fois (ce qui serait très lent), le tampon (buffer) permet de charger une portion du fichier en mémoire, puis de traiter cette portion ligne par ligne ou caractère par caractère en mémoire vive, ce qui est bien plus efficace.\nDe la même façon, pour l\u0026rsquo;écriture, la classe BufferedWriter permet d\u0026rsquo;écrire dans un fichier par blocs, en accumulant les caractères dans un tampon avant de les écrire d\u0026rsquo;un coup sur le disque. Cela réduit le nombre d\u0026rsquo;opérations d\u0026rsquo;écriture physiques, ce qui améliore la performance.\nVoici un exemple complet de lecture et d\u0026rsquo;écriture performantes avec BufferedReader et BufferedWriter :\nimport java.io.*; public class ExempleBuffer { public static void main(String[] args) { // Lecture performante try (BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;entree.txt\u0026#34;))) { String ligne; while ((ligne = reader.readLine()) != null) { System.out.println(ligne); } } catch (IOException e) { System.err.println(\u0026#34;Erreur de lecture : \u0026#34; + e.getMessage()); } // Écriture performante try (BufferedWriter writer = new BufferedWriter(new FileWriter(\u0026#34;sortie.txt\u0026#34;))) { writer.write(\u0026#34;Ceci est une ligne écrite rapidement grâce au buffer.\\n\u0026#34;); writer.write(\u0026#34;Une autre ligne.\\n\u0026#34;); } catch (IOException e) { System.err.println(\u0026#34;Erreur d\u0026#39;écriture : \u0026#34; + e.getMessage()); } } } Utiliser BufferedReader et BufferedWriter est essentiel pour la performance lors de la lecture et l\u0026rsquo;écriture de fichiers texte en Java. Cela permet de traiter efficacement de grands volumes de données tout en minimisant les accès disque, ce qui accélère significativement les opérations d\u0026rsquo;entrée/sortie.\nDonnées binaires et performance # Pour les fichiers binaires (images, sons, vidéos, données structurées, etc.), le principe de la lecture/écriture en bloc reste tout aussi important. En Java, on utilise alors BufferedInputStream et BufferedOutputStream pour optimiser les opérations sur les flux binaires. Ces classes fonctionnent de façon similaire à leurs équivalents pour le texte, mais traitent des octets au lieu de caractères.\nL\u0026rsquo;utilisation de buffers permet de lire ou d\u0026rsquo;écrire plusieurs kilo-octets d\u0026rsquo;un coup, ce qui réduit le nombre d\u0026rsquo;accès disque et améliore la rapidité, surtout pour les gros fichiers binaires.\nVoici un exemple de copie performante d\u0026rsquo;un fichier binaire :\nimport java.io.*; public class CopieBinaire { public static void main(String[] args) { try ( BufferedInputStream in = new BufferedInputStream(new FileInputStream(\u0026#34;source.bin\u0026#34;)); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(\u0026#34;destination.bin\u0026#34;)); ) { byte[] buffer = new byte[8192]; // 8 Ko int bytesRead; while ((bytesRead = in.read(buffer)) != -1) { out.write(buffer, 0, bytesRead); } } catch (IOException e) { System.err.println(\u0026#34;Erreur lors de la copie : \u0026#34; + e.getMessage()); } } } Pour les fichiers binaires, il est essentiel d\u0026rsquo;utiliser des buffers pour garantir des performances optimales. Cela permet de manipuler efficacement de grandes quantités de données, tout en minimisant la sollicitation du disque dur.\nConseils génériques # Il faut privilégier les lectures/écritures en bloc (bufferisées). Il faut limiter les accès réseau (en réduire le nombre).\nEn contrepartie, il vaut mieux éviter de charger de très gros fichiers en une seule fois si ce n’est pas nécessaire (privilégier le traitement ligne par ligne ou par bloc). Votre ordinateur est plus rapide s\u0026rsquo;il ne traite que de petites quantités de données à la fois (ex. 10 Ko plutôt que 10 Mo).\nLecture optionnelle dans le livre de référence (Delannoy) # Pour aller plus en profondeur sur les flux de fichier (optionnel), vous pouvez lire dans Programmer en Java de Claude Delannoy, Chapitre 20:\nSection 1 : Fichier binaire Section 2 : Liste séquentielle d'un fichier binaire Section 3 : Accès direct à un fichier binaire Section 6 : La gestion des fichiers avec la classe File Vidéo # "},{"id":14,"href":"/inf1220-hugo/docs/modules/module3/activite-3-1/","title":"Les structures de contrôle","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" Les structures de contrôle # Les structures de contrôle sont des outils essentiels en programmation : elles permettent de prendre des décisions et de répéter des actions selon certaines conditions. En Java, les structures de contrôle principales sont if-else et switch-case pour le choix, ainsi que les boucles (qui seront vues plus loin).\nUne structure de contrôle permet d’exécuter différentes instructions selon la valeur d’une variable ou le résultat d’une expression logique. Cela rend les programmes dynamiques et capables de s’adapter à différentes situations.\nLe bloc d\u0026rsquo;instructions # Un bloc d\u0026rsquo;instructions est un ensemble d’instructions regroupées entre deux accolades ({ }). Il permet de définir clairement quelles instructions doivent être exécutées ensemble, par exemple dans un if ou une boucle. Les variables déclarées à l’intérieur d’un bloc ne sont visibles que dans ce bloc (on parle de portée ou « scope »).\nOn peut aussi donner un nom (une étiquette) à un bloc d’instructions, ce qui peut servir dans certains cas avancés (par exemple avec break ou continue étiquetés).\nExemple :\nbloc1: { instruction_1; instruction_2; // ... instruction_n; } Ce bloc nommé bloc1 regroupe plusieurs instructions qui seront exécutées dans l’ordre.\nLa structure de contrôle IF-ELSE # Le branchement conditionnel (if) peut apparaître sous deux formes : avec ou sans clause else. Dans les deux cas, il s'agit d'un branchement booléen, c'est à dire que selon le contrôle (qui est au final une valeur booléenne, ex. i != 0) ou la valeur vraie permettra d'aller dans la portée de la structure ou non. La forme :\nif (expression) { instruction1; } s'exécute de la manière suivante : l'expression est évaluée; si le résultat renvoie le booléen true, alors l'instruction instruction1 est exécutée, sinon le branchement conditionnel est terminé. Considérons maintenant une forme avec if et else:\nif (expression) { instruction1; } else { instruction2; } Dans ce dernier cas, la clause else se rapporte à l'instruction if, c'est-à-dire que son bloc (instruction2) est exécuté si et seulement si l'expression expression est fausse.\nCe qui est différent du programme : if (expression1) { if (expression2) { instruction2; } } else { instructionFin; } Dans ce nouveau cas, la clause else se rapporte à l’expression if (expression1) : son bloc (contenant instructionFin) est exécutée si et seulement si expression1 est fausse. Par ailleurs, dans ce dernier exemple, instruction2 est exécutée si et seulement si les valeurs expression1 et expression2 sont toutes les deux vraies.\n\u0026nbsp;\nLe programme suivant montre comment fonctionnent les instructions if et else. Ce programme montre la note obtenue par des personnes ayant terminé leur premier cours de Java.\nclass IfElseDemontration { public static void main(String[] args) { int resultat = 76; char note; if (resultat \u0026gt;= 90) { note = \u0026#39;A\u0026#39;; } else if (resultat \u0026gt;= 80) { note = \u0026#39;B\u0026#39;; } else if (resultat \u0026gt;= 70) { note = \u0026#39;C\u0026#39;; } else if (resultat \u0026gt;= 60) { note = \u0026#39;D\u0026#39;; } else { note = \u0026#39;F\u0026#39;; } System.out.println(\u0026#34;Note finale = \u0026#34; + note); } } La structure de contrôle SWITCH-CASE # L'instruction de choix multiples switch permet d'effectuer un aiguillage sur plusieurs instructions, suivant la valeur retournée par une expression d'un des types suivants : char, byte, short ou int. Lorsque la valeur de l'expression est connue, elle est comparée à chacune des valeurs indiquées par les clauses case, en séquence dans l'ordre d'apparition des clauses. Dès qu'une valeur indiquée par une clause est égale à la valeur calculée, le contrôle d'exécution est donné à la séquence d'instructions qui suit cette clause. Si aucune valeur ne correspond, le contrôle est donné à la clause default, si celle-ci existe, ou bien, l'instruction de choix multiples est considérée comme terminée.\nL'instruction break permet d'arrêter l'instruction de choix multiples. Elle sera en général utilisée à la fin de la séquence d'instructions de chaque clause.\nPar exemple, la détermination d'une valeur paire ou impaire peut se faire par l'instruction suivante :\nswitch (i % 2) { case 0: System.out.println(\u0026#34;C\u0026#39;est un nombre pair\u0026#34;); break; case 1: System.out.println(\u0026#34;C\u0026#39;est un nombre impair\u0026#34;); break; } Le programme suivant montre l'utilisation de l'instruction switch. Il s'agit ici d'une banque qui définit quatre catégories de classes afin de donner des commissions à ses employés. Pour la classe 1, nous avons un taux de commission de 2 %, de 3,5 % pour la classe 2, de 5 % pour la classe 3 et de 0 % pour la classe 4.\nVoici le programme qui permet de réaliser cette opération :\nclass SwitchExemple { public static void main(String[] args) { double TauxCommission; int cas = 1; switch (cas) { case 1: TauxCommission = 0.02; break; case 2: TauxCommission = 0.035; break; case 3: TauxCommission = 0.05; break; default: TauxCommission = 0.0; break; } System.out.println(\u0026#34; le taux de commission = \u0026#34; + TauxCommission); } } La nouvelle syntaxe des expressions switch en Java, introduite avec Java 12 (JEP 325) et finalisée dans Java 14 (JEP 361), permet d\u0026rsquo;utiliser des flèches (-\u0026gt;) pour rendre les instructions switch plus concises et de les transformer en expressions qui renvoient une valeur. Cette syntaxe améliore la lisibilité et réduit la verbosité par rapport au switch traditionnel.\nSwitchExpressionExample.java public class SwitchExpressionExample { public static void main(String[] args) { String mois = \u0026#34;Février\u0026#34;; int jours = switch (mois) { case \u0026#34;Janvier\u0026#34;, \u0026#34;Mars\u0026#34;, \u0026#34;Mai\u0026#34;, \u0026#34;Juillet\u0026#34;, \u0026#34;Août\u0026#34;, \u0026#34;Octobre\u0026#34;, \u0026#34;Décembre\u0026#34; -\u0026gt; 31; case \u0026#34;Avril\u0026#34;, \u0026#34;Juin\u0026#34;, \u0026#34;Septembre\u0026#34;, \u0026#34;Novembre\u0026#34; -\u0026gt; 30; case \u0026#34;Février\u0026#34; -\u0026gt; { int annee = 2024; // Exemple d\u0026#39;année if (annee % 4 == 0 \u0026\u0026 (annee % 100 != 0 || annee % 400 == 0)) { yield 29; // Année bissextile } else { yield 28; } } default -\u0026gt; throw new IllegalArgumentException(\u0026#34;Mois invalide : \u0026#34; \u0026#43; mois); }; System.out.println(\u0026#34;Le mois de \u0026#34; \u0026#43; mois \u0026#43; \u0026#34; a \u0026#34; \u0026#43; jours \u0026#43; \u0026#34; jours.\u0026#34;); } } Exécuter Observez le mot-clé yield utilisé dans les expressions switch pour spécifier la valeur renvoyée par une branche d’un bloc switch lorsqu’une logique complexe nécessite plusieurs instructions.\nLecture optionnelle dans le livre de référence (Delannoy) # Pour aller plus en profondeur sur les structures de contrôle (optionnel), vous pouvez lire dans Programmer en Java de Claude Delannoy, Chapitre 5:\nSection 1 : L'instruction If Section 2 : L'instruction switch Vidéos suggérées # "},{"id":15,"href":"/inf1220-hugo/docs/modules/module2/","title":"Module 2: Introduction au langage Java","section":"Modules","content":" Module 2 # Dans le module 2, le concept de programme est exploré en profondeur, constituant une étape clé pour maîtriser les bases de la programmation. Ce module introduit les éléments fondamentaux qui composent un programme : les types, les fonctions, les méthodes et les variables. Les types permettent de définir la nature des données manipulées, tandis que les fonctions et les méthodes offrent des outils pour structurer le code de manière modulaire et réutilisable. Les variables, quant à elles, servent à stocker et gérer des informations de façon efficace. À travers des exemples concrets et des exercices pratiques, ce module montre comment ces composants s’assemblent pour créer des programmes cohérents et fonctionnels, jetant ainsi les bases d’un apprentissage solide.\nLe module 2 aborde également la distinction entre les variables de classe et les variables locales, une notion essentielle pour organiser le code de manière claire et efficace. Les variables de classe, accessibles à l’échelle d’un programme ou d’un objet, facilitent la gestion des données globales, tandis que les variables locales, restreintes à un contexte spécifique, favorisent la clarté et la modularité du code. Grâce à des activités pratiques, notamment en Java, ce module permet de comprendre la portée et le cycle de vie des variables. En s’appuyant sur les exemples du manuel Java pas à pas et du site web du cours, il offre une opportunité de consolider les compétences en programmation tout en développant la capacité à concevoir des solutions logiques et bien structurées.\nLe cours comprend aussi plusieurs exemples de code Java exécutable en ligne, comme cet exemple :\nHelloWorld.javapublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Bonjour, INF 1220 !\u0026#34;); } } Exécuter Ce programme Java, appelé HelloWorld, est un petit exemple qui affiche le message \u0026ldquo;Bonjour, INF 1220 !\u0026rdquo; à l\u0026rsquo;écran. Imaginez une classe comme une boîte qui contient des instructions, et ici, notre boîte s\u0026rsquo;appelle HelloWorld. À l\u0026rsquo;intérieur, il y a une action spéciale nommée main, qui est comme la porte d\u0026rsquo;entrée du programme : c\u0026rsquo;est par là que tout commence quand vous lancez le code. La ligne public static void main(String[] args) crée cette porte d\u0026rsquo;entrée, et String[] args est juste un moyen de donner des informations supplémentaires au programme (on ne s\u0026rsquo;en sert pas ici). Ensuite, l\u0026rsquo;instruction System.out.println(\u0026ldquo;Bonjour, INF 1220 !\u0026rdquo;); est comme une commande qui dit à l\u0026rsquo;ordinateur d\u0026rsquo;écrire \u0026ldquo;Bonjour, INF 1220 !\u0026rdquo; dans la console, un peu comme si vous écriviez sur une feuille. En gros, ce code est une première étape pour apprendre à donner des ordres simples à l\u0026rsquo;ordinateur avec Java !\nVous devriez pouvoir exécuter le code et prendre connnaissance du résultat. Vous pouvez aussi modifier le code, etc. À la fin du cours, vous serez capable de réaliser des tâches complexes avec la programmation Java.\nAu sujet du Java # Java est un langage de programmation orienté objet, conçu pour être à la fois simple à utiliser et puissant. Il est largement utilisé dans le développement d\u0026rsquo;applications d\u0026rsquo;entreprise, d\u0026rsquo;applications mobiles (surtout Android), et dans de nombreux autres domaines. Java est apprécié pour sa portabilité, sa robustesse et sa capacité à gérer des applications de grande envergure.\nJava présente plusieurs avantages par rapport à d’autres langages de programmation :\nPortabilité : Grâce à la machine virtuelle Java (JVM), un programme Java peut être exécuté sur n’importe quelle plateforme disposant d’une JVM, sans modification du code source (« Write Once, Run Anywhere »). Gestion automatique de la mémoire : Le ramasse-miettes (garbage collector) libère automatiquement la mémoire inutilisée, ce qui réduit les risques de fuites de mémoire et simplifie la gestion des ressources. Vaste écosystème : Java dispose d’un grand nombre de bibliothèques, de frameworks et d’outils, facilitant le développement d’applications variées (web, mobile, entreprise, etc.). Documentation et communauté : La documentation est abondante et la communauté très active, ce qui facilite l’apprentissage et la résolution de problèmes. Cependant, Java présente aussi certains inconvénients :\nPerformances parfois inférieures au code natif : Les programmes Java peuvent être plus lents que ceux écrits en C ou C++, car ils s’exécutent sur la JVM et non directement sur le matériel. Java permet tout de même d\u0026rsquo;offrir une performance très supérieurs au JavaScript ou à Python. Syntaxe parfois verbeuse : Le code Java peut être plus long et moins concis que dans d’autres langages modernes comme Python ou Kotlin. Nécessité d’installer la JVM : Pour exécuter un programme Java, il faut installer la machine virtuelle Java, ce qui peut compliquer le déploiement sur certains systèmes. En résumé, Java est un langage polyvalent, robuste et largement utilisé, mais il n’est pas toujours le plus adapté pour les applications nécessitant des performances maximales ou une grande concision syntaxique.\nConseils génériques # Pour devenir un bon programmeur\u0026hellip;\nIl faut comprendre les bases : maîtriser les concepts fondamentaux comme les variables, les boucles et les fonctions avant de passer à des sujets complexes. Il faut pratiquer régulièrement : il faut coder tous les jours pendant des mois afin de renforcer ses compétences et de gagner en aisance. Il faut lire du code : il faut explorer des exemples pour comprendre comment les autres structurent leurs programmes. Il faut écrire un code lisible : Il faut utiliser des noms de variables clairs et il faut commenter son code pour qu’il soit facile à comprendre. Il faut accepter les erreurs : les échecs sont des opportunités d’apprentissage, car ils font partie intégrante du processus. Objectifs du module # Ce module a pour objectif de vous donner une compréhension solide des bases de la programmation en Java, en insistant sur :\nLa distinction entre les différents types de données (primitifs et objets), leur rôle et leur manipulation. La déclaration, l’utilisation et la portée des variables (locales, de classe, d’instance). L’utilisation des opérateurs et des classes enveloppes pour manipuler les données. La structuration du code à l’aide de méthodes (fonctions), leur définition, leur appel et leur utilité pour la réutilisation et la clarté du programme. Les fondements de la programmation orientée objet : classes, instances, constructeurs, et premières notions d’organisation du code. La lecture, l’écriture et la compréhension de programmes Java simples, en s’appuyant sur des exemples concrets et des exercices pratiques. Le développement de l’autonomie dans la résolution de problèmes, la lecture de code et la correction d’erreurs courantes. À l’issue de ce module, vous serez capable de :\nÉcrire et comprendre des programmes Java simples utilisant variables, types, opérateurs, méthodes et classes. Structurer votre code de façon claire et modulaire. Appliquer les bonnes pratiques de base pour progresser efficacement en programmation. "},{"id":16,"href":"/inf1220-hugo/docs/environnement/","title":"Programmation Java en ligne","section":"Docs","content":" Programmation Java en ligne # Pour commencer à programmer dans cet environnement Java en ligne, familiarisez-vous avec son interface intuitive. La page principale affiche une zone où vous pouvez ajouter des fichiers Java ou texte. Cliquez sur « Ajouter un fichier Java » pour créer un fichier avec l\u0026rsquo;extension .java, ou « Ajouter un fichier texte » pour un fichier .txt. Chaque fichier apparaît dans une boîte avec un champ pour le nom et un éditeur de texte. Pour les fichiers Java, l\u0026rsquo;éditeur offre une coloration syntaxique et des numéros de ligne, facilitant la lecture et l\u0026rsquo;écriture du code. Vous pouvez aussi sélectionner des exemples prédéfinis (comme « Bonjour le monde » ou « Fibonacci ») via le menu déroulant « Exemples » pour charger automatiquement des fichiers modèles. Une fois vos fichiers prêts, cliquez sur « Exécuter » pour compiler et exécuter le code.\nLorsque vous exécutez votre programme, l\u0026rsquo;environnement tente de compiler et d\u0026rsquo;exécuter votre code. Le résultat s\u0026rsquo;affiche dans la zone « Résultat » en bas de la page. Si le programme s\u0026rsquo;exécute correctement, vous verrez la sortie attendue, comme du texte affiché par System.out.println. En cas d\u0026rsquo;erreur de compilation, le message d\u0026rsquo;erreur apparaît avec des détails précis, et les lignes problématiques dans vos fichiers Java sont surlignées en rouge dans l\u0026rsquo;éditeur. Passez la souris sur ces lignes pour voir le message d\u0026rsquo;erreur complet dans la barre d\u0026rsquo;état sous l\u0026rsquo;éditeur. Vous pouvez modifier le code directement dans l\u0026rsquo;éditeur et réexécuter pour tester vos corrections. Pour supprimer un fichier, cliquez sur le « × » en haut à droite de sa boîte.\nJava en ligne Exemples : Sélectionner un exemple... Affichage d'un fichier texte (2 Java + 1 texte) Bonjour le monde (simple) Fibonacci (package, commentaires FR) Mario Exécuter Ajouter un fichier Java Ajouter un fichier texte (c) Daniel Lemire Pour optimiser votre expérience, suivez ces conseils. Assurez-vous que les noms de fichiers Java correspondent au nom de la classe publique qu\u0026rsquo;ils contiennent (par exemple, Main.java pour public class Main). Si vous utilisez des packages, indiquez le chemin correct dans le nom du fichier, comme ca/teluq/informatique/Fibo.java pour un fichier dans le package ca.teluq.informatique. Testez d\u0026rsquo;abord avec les exemples fournis pour comprendre comment l\u0026rsquo;environnement gère les entrées et sorties. Si vous travaillez avec des fichiers texte, comme dans l\u0026rsquo;exemple d\u0026rsquo;affichage de fichier, vérifiez que le nom du fichier texte correspond à celui utilisé dans votre code Java. Enfin, consultez la version de Java affichée en bas de la page pour vous assurer que votre code est compatible. Cet environnement est idéal pour apprendre et tester des programmes Java simples sans installer de logiciel.\nL\u0026rsquo;environnement est limité pour les besoins du cours. Nous vous suggérons de n\u0026rsquo;inclure qu\u0026rsquo;une seule classe ayant une méthode main. Par ailleurs, vous ne pouvez pas construire d\u0026rsquo;interface graphiques ou de serveurs web. L\u0026rsquo;environnement ne permet pas non plus d\u0026rsquo;exécuter des programmes arbitraires. L\u0026rsquo;exécution doit être brève et ne pas nécessiter trop de mémoire.\n"},{"id":17,"href":"/inf1220-hugo/docs/modules/module1/robot/","title":"Robot conversationnel et intelligence artificielle","section":"Module 1: Algorithme et pseudocode","content":" Robot conversationnel et intelligence artificielle # L\u0026rsquo;intelligence artificielle (IA) transforme profondément le domaine de la programmation, redéfinissant la manière dont les développeurs conçoivent, écrivent et maintiennent le code. Les outils basés sur l\u0026rsquo;IA, comme les assistants de codage (par exemple, GitHub Copilot), permettent d\u0026rsquo;automatiser des tâches répétitives, telles que la génération de code boilerplate ou la complétion automatique de fonctions. Ces outils s\u0026rsquo;appuient sur des modèles de langage avancés, entraînés sur d\u0026rsquo;immenses bases de données de code, pour proposer des suggestions contextuelles précises. Cette assistance accélère le processus de développement, permettant aux programmeurs de se concentrer sur des aspects plus créatifs et complexes de leurs projets, tout en réduisant les erreurs humaines.\nAu-delà de l\u0026rsquo;écriture de code, l\u0026rsquo;IA joue un rôle croissant dans le débogage et l\u0026rsquo;optimisation. Les systèmes d\u0026rsquo;IA peuvent analyser des programmes pour identifier des bugs, des vulnérabilités de sécurité ou des inefficacités, souvent plus rapidement qu\u0026rsquo;un humain. Par exemple, des outils comme DeepCode ou SonarQube utilisent l\u0026rsquo;apprentissage automatique pour détecter des anomalies dans le code et suggérer des corrections. De plus, l\u0026rsquo;IA aide à optimiser les performances en proposant des algorithmes plus efficaces ou en ajustant automatiquement les configurations des systèmes. Cette capacité à diagnostiquer et améliorer le code renforce la qualité des logiciels et réduit le temps consacré à la maintenance.\nL\u0026rsquo;IA démocratise également la programmation en abaissant les barrières à l\u0026rsquo;entrée. Les interfaces conversationnelles et les outils no-code/low-code, alimentés par l\u0026rsquo;IA, permettent à des non-programmeurs de créer des applications en décrivant leurs besoins en langage naturel. Des plateformes comme Bubble ou OutSystems exploitent l\u0026rsquo;IA pour traduire ces descriptions en code fonctionnel. Cette évolution ouvre la programmation à un public plus large, favorisant l\u0026rsquo;innovation dans des domaines variés, mais soulève aussi des questions sur la dépendance aux outils automatisés et la compréhension réelle des concepts sous-jacents par les utilisateurs.\nJe vous invite à regarder cette vidéo sur YouTube à ce sujet. YouTube offre une version avec sous-titres traduits et je vous offre une transcription en français.\nTranscription traduite en français Hum, d\u0026rsquo;accord, je suis enthousiaste d\u0026rsquo;être ici aujourd\u0026rsquo;hui pour vous parler du logiciel à l\u0026rsquo;ère de l\u0026rsquo;IA. On m\u0026rsquo;a dit que beaucoup d\u0026rsquo;entre vous sont étudiants, en licence, master, doctorat, et ainsi de suite, et que vous êtes sur le point d\u0026rsquo;entrer dans l\u0026rsquo;industrie. Je pense que c\u0026rsquo;est un moment extrêmement unique et très intéressant pour rejoindre l\u0026rsquo;industrie en ce moment. Fondamentalement, la raison en est que le logiciel change à nouveau. Je dis « à nouveau » parce que j\u0026rsquo;ai déjà donné cette conférence, mais le problème est que le logiciel ne cesse de changer. J\u0026rsquo;ai donc beaucoup de matériel pour créer de nouvelles conférences, et je pense que ce changement est assez fondamental. Grossièrement, le logiciel n\u0026rsquo;a pas beaucoup changé à un niveau aussi fondamental depuis 70 ans, puis il a changé, je pense, deux fois de manière assez rapide ces dernières années. Il y a donc une énorme quantité de travail à faire, une énorme quantité de logiciels à écrire et à réécrire.\nLe paysage du logiciel\nExaminons peut-être le domaine du logiciel. Si nous considérons cela comme une carte du logiciel, il existe un outil vraiment cool appelé « Map of GitHub ». C\u0026rsquo;est un peu comme tout le logiciel qui a été écrit, des instructions pour l\u0026rsquo;ordinateur afin d\u0026rsquo;exécuter des tâches dans l\u0026rsquo;espace numérique. Si vous zoomez, ce sont tous différents types de dépôts, et c\u0026rsquo;est tout le code qui a été écrit. Il y a quelques années, j\u0026rsquo;ai observé que le logiciel changeait, qu\u0026rsquo;il y avait un nouveau type de logiciel, et je l\u0026rsquo;ai appelé « logiciel 2.0 » à l\u0026rsquo;époque. L\u0026rsquo;idée était que le logiciel 1.0 est le code que vous écrivez pour l\u0026rsquo;ordinateur, tandis que le logiciel 2.0 concerne les réseaux neuronaux, en particulier les poids d\u0026rsquo;un réseau neuronal. Vous n\u0026rsquo;écrivez pas ce code directement, vous ajustez plutôt les ensembles de données, puis vous exécutez un optimiseur pour créer les paramètres de ce réseau neuronal. À l\u0026rsquo;époque, les réseaux neuronaux étaient perçus comme un simple classificateur différent, comme un arbre de décision ou quelque chose comme ça. Je pense que ce cadre était beaucoup plus approprié.\nMaintenant, nous avons l\u0026rsquo;équivalent de GitHub dans le domaine du logiciel 2.0. Je pense que Hugging Face est fondamentalement l\u0026rsquo;équivalent de GitHub pour le logiciel 2.0. Il y a aussi Model Atlas, où vous pouvez visualiser tout le code écrit, si vous êtes curieux. D\u0026rsquo;ailleurs, le grand cercle au centre représente les paramètres de Flux, le générateur d\u0026rsquo;images. Chaque fois que quelqu\u0026rsquo;un ajuste un modèle au-dessus de Flux, vous créez en quelque sorte un « commit » dans cet espace, et vous obtenez un générateur d\u0026rsquo;images différent.\nEn résumé, le logiciel 1.0 est le code informatique qui programme un ordinateur, le logiciel 2.0 sont les poids qui programment les réseaux neuronaux. Voici un exemple avec AlexNet, un réseau neuronal de reconnaissance d\u0026rsquo;images. Jusqu\u0026rsquo;à récemment, tous les réseaux neuronaux que nous connaissions étaient des ordinateurs à fonction fixe, comme de l\u0026rsquo;image aux catégories. Ce qui a changé, et je pense que c\u0026rsquo;est un changement fondamental, c\u0026rsquo;est que les réseaux neuronaux sont devenus programmables avec les grands modèles de langage (LLM). Je vois cela comme quelque chose de nouveau et unique, un nouveau type d\u0026rsquo;ordinateur. À mon avis, cela mérite une nouvelle désignation : le logiciel 3.0. Vos invites (prompts) sont maintenant des programmes qui programment le LLM, et, chose remarquable, ces invites sont écrites en anglais, ce qui en fait un langage de programmation très intéressant.\nExemple : classification de sentiments\nPour illustrer la différence, si vous faites une classification de sentiments, vous pouvez imaginer écrire une certaine quantité de code Python pour effectuer cette classification, ou entraîner un réseau neuronal, ou encore utiliser une invite pour un grand modèle de langage. Voici une invite courte, et vous pouvez imaginer la modifier pour programmer l\u0026rsquo;ordinateur d\u0026rsquo;une manière légèrement différente. Nous avons donc le logiciel 1.0, le logiciel 2.0, et je pense que nous voyons maintenant que beaucoup de code sur GitHub n\u0026rsquo;est plus seulement du code, il y a aussi beaucoup de texte en anglais entrelacé avec le code. Une nouvelle catégorie de code émerge, non seulement un nouveau paradigme de programmation, mais aussi, ce qui est remarquable, dans notre langue native, l\u0026rsquo;anglais.\nQuand cela m\u0026rsquo;a frappé il y a quelques années, j\u0026rsquo;ai tweeté à ce sujet, et cela a capté l\u0026rsquo;attention de beaucoup de monde. C\u0026rsquo;est actuellement mon tweet épinglé : nous programmons maintenant les ordinateurs en anglais. Chez Tesla, nous travaillions sur le pilote automatique, et nous essayions de faire conduire la voiture. J\u0026rsquo;ai montré une diapositive à l\u0026rsquo;époque où les entrées de la voiture passaient par une pile logicielle pour produire la direction et l\u0026rsquo;accélération. J\u0026rsquo;avais observé qu\u0026rsquo;il y avait une tonne de code C++ dans le pilote automatique, qui était du logiciel 1.0, et qu\u0026rsquo;il y avait aussi des réseaux neuronaux pour la reconnaissance d\u0026rsquo;images. Au fil du temps, à mesure que nous améliorions le pilote automatique, le réseau neuronal gagnait en capacité et en taille, et tout le code C++ était supprimé. Beaucoup des capacités et fonctionnalités initialement écrites en 1.0 ont été migrées vers le 2.0. Par exemple, l\u0026rsquo;assemblage des informations entre les images des différentes caméras et dans le temps était effectué par un réseau neuronal, ce qui nous a permis de supprimer beaucoup de code. La pile logicielle 2.0 a littéralement dévoré la pile logicielle du pilote automatique.\nJe trouvais cela vraiment remarquable à l\u0026rsquo;époque, et je pense que nous voyons la même chose aujourd\u0026rsquo;hui, où un nouveau type de logiciel dévore la pile. Nous avons trois paradigmes de programmation complètement différents, et si vous entrez dans l\u0026rsquo;industrie, il est très utile d\u0026rsquo;être à l\u0026rsquo;aise avec chacun d\u0026rsquo;eux, car ils ont tous leurs avantages et inconvénients. Vous devrez décider si une fonctionnalité doit être programmée en 1.0, 2.0 ou 3.0. Allez-vous entraîner un réseau neuronal, simplement utiliser une invite pour un LLM, ou écrire un code explicite ? Nous devons tous prendre ces décisions et potentiellement passer fluidement d\u0026rsquo;un paradigme à l\u0026rsquo;autre.\nLes grands modèles de langage (LLM)\nPassons maintenant à la première partie, où je veux parler des LLM, de la manière de penser à ce nouveau paradigme et à son écosystème. Qu\u0026rsquo;est-ce que cet nouvel ordinateur, à quoi ressemble-t-il, et à quoi ressemble l\u0026rsquo;écosystème ? J\u0026rsquo;ai été frappé par une citation d\u0026rsquo;Andrew Ng, il y a plusieurs années, qui disait que l\u0026rsquo;IA est la nouvelle électricité. Je pense que cela capture quelque chose de très intéressant, car les LLM ont actuellement des propriétés d\u0026rsquo;utilité publique. Les laboratoires de LLM, comme OpenAI, Gemini, Anthropic, etc., investissent des capitaux pour entraîner les LLM, ce qui équivaut à construire un réseau. Ensuite, il y a des dépenses opérationnelles pour fournir cette intelligence via des API à nous tous, à travers un accès mesuré où nous payons par million de jetons ou quelque chose comme ça. Nous avons beaucoup d\u0026rsquo;exigences similaires à celles d\u0026rsquo;une utilité publique : faible latence, haute disponibilité, qualité constante, etc.\nDans l\u0026rsquo;électricité, vous auriez un commutateur de transfert pour passer de la grille à l\u0026rsquo;énergie solaire, une batterie ou un générateur. Dans les LLM, nous avons peut-être OpenRouter, qui permet de basculer facilement entre différents types de LLM existants. Comme les LLM sont des logiciels, ils ne rivalisent pas pour l\u0026rsquo;espace physique, donc il est acceptable d\u0026rsquo;avoir, disons, six fournisseurs d\u0026rsquo;électricité, et vous pouvez passer de l\u0026rsquo;un à l\u0026rsquo;autre, car ils ne concurrencent pas de manière aussi directe. Ce qui est aussi fascinant, c\u0026rsquo;est que récemment, plusieurs LLM ont connu des pannes, et les gens se sont retrouvés bloqués, incapables de travailler. Quand les LLM de pointe tombent en panne, c\u0026rsquo;est comme une baisse d\u0026rsquo;intelligence dans le monde, un peu comme une tension instable dans le réseau, et la planète devient simplement moins intelligente. Plus nous dépendons de ces modèles, ce qui est déjà dramatique, plus cela va croître.\nMais les LLM n\u0026rsquo;ont pas seulement des propriétés d\u0026rsquo;utilité publique. Ils ont aussi des propriétés de fabriques (fabs), car les investissements nécessaires pour construire un LLM sont considérables, pas seulement comme construire une centrale électrique. La technologie évolue rapidement, avec des arbres technologiques complexes, de la recherche et du développement, et des secrets centralisés dans les laboratoires de LLM. Cependant, l\u0026rsquo;analogie devient un peu floue, car, comme je l\u0026rsquo;ai mentionné, il s\u0026rsquo;agit de logiciel, et le logiciel est moins défendable car il est très malléable.\nJe pense que l\u0026rsquo;analogie qui a le plus de sens est que les LLM ont de fortes similitudes avec les systèmes d\u0026rsquo;exploitation. Ce n\u0026rsquo;est pas juste de l\u0026rsquo;électricité ou de l\u0026rsquo;eau qui sort d\u0026rsquo;un robinet comme une commodité. Ce sont des écosystèmes logiciels de plus en plus complexes, pas juste des commodités simples comme l\u0026rsquo;électricité. L\u0026rsquo;écosystème se forme de manière très similaire, avec quelques fournisseurs à source fermée, comme Windows ou Mac OS, et une alternative open source comme Linux. Pour les LLM, nous avons quelques fournisseurs à source fermée en compétition, et peut-être que l\u0026rsquo;écosystème LLaMA est actuellement une approximation de quelque chose qui pourrait devenir comme Linux. C\u0026rsquo;est encore très tôt, car ce ne sont que des LLM simples, mais nous commençons à voir qu\u0026rsquo;ils vont devenir beaucoup plus compliqués, avec l\u0026rsquo;utilisation d\u0026rsquo;outils, la multimodalité, et comment tout cela fonctionne.\nQuand j\u0026rsquo;ai réalisé cela il y a un moment, j\u0026rsquo;ai essayé de le schématiser, et il m\u0026rsquo;a semblé que les LLM sont comme un nouveau système d\u0026rsquo;exploitation. Le LLM est une sorte d\u0026rsquo;équivalent du CPU, les fenêtres de contexte sont comme la mémoire, et le LLM orchestre la mémoire et le calcul pour résoudre des problèmes, en utilisant toutes ces capacités. Cela ressemble beaucoup à un système d\u0026rsquo;exploitation de ce point de vue.\nPour donner un exemple, si je veux télécharger une application, disons VS Code, je peux le télécharger et l\u0026rsquo;exécuter sur Windows, Linux ou Mac. De la même manière, je peux prendre une application LLM comme Cursor et l\u0026rsquo;exécuter sur GPT, Claude ou la série Gemini, juste en sélectionnant une option dans un menu déroulant. Nous sommes dans une ère, disons des années 1960, où le calcul des LLM est encore très coûteux pour ce nouveau type d\u0026rsquo;ordinateur, ce qui oblige les LLM à être centralisés dans le cloud. Nous sommes tous des clients qui interagissent avec eux via le réseau, et aucun de nous n\u0026rsquo;a une utilisation complète de ces ordinateurs. Cela rend logique d\u0026rsquo;utiliser le partage de temps, où nous sommes tous une dimension du lot quand ils exécutent l\u0026rsquo;ordinateur dans le cloud. C\u0026rsquo;est ainsi que les ordinateurs fonctionnaient à cette époque : les systèmes d\u0026rsquo;exploitation étaient dans le cloud, tout était diffusé, et il y avait du traitement par lots.\nLa révolution de l\u0026rsquo;informatique personnelle n\u0026rsquo;a pas encore eu lieu, car ce n\u0026rsquo;est pas économique, ça n\u0026rsquo;a pas de sens. Mais certaines personnes essaient, et il s\u0026rsquo;avère que les Mac Minis, par exemple, sont très adaptés pour certains LLM, car si vous faites une inférence par lot, tout est très limité par la mémoire. Cela fonctionne, et ce sont peut-être des signes précoces de l\u0026rsquo;informatique personnelle, mais cela n\u0026rsquo;a pas vraiment eu lieu. Ce n\u0026rsquo;est pas clair à quoi cela ressemblera. Peut-être que certains d\u0026rsquo;entre vous inventeront ce que c\u0026rsquo;est, comment ça fonctionne, ou ce que ça devrait être.\nUne autre analogie : chaque fois que je parle à ChatGPT ou à un LLM directement en texte, j\u0026rsquo;ai l\u0026rsquo;impression de parler à un système d\u0026rsquo;exploitation via le terminal. C\u0026rsquo;est du texte, c\u0026rsquo;est un accès direct au système d\u0026rsquo;exploitation. Une interface graphique (GUI) n\u0026rsquo;a pas encore été inventée de manière générale. Est-ce que ChatGPT devrait avoir une GUI différente des simples bulles de texte ? Certaines applications ont des GUI, mais il n\u0026rsquo;y a pas de GUI générale pour toutes les tâches.\nLes LLM diffèrent des systèmes d\u0026rsquo;exploitation de manière assez unique. J\u0026rsquo;ai écrit sur une propriété qui me semble très différente cette fois-ci : les LLM inversent la direction de la diffusion technologique, qui est généralement présente dans la technologie. Par exemple, avec l\u0026rsquo;électricité, la cryptographie, l\u0026rsquo;informatique, l\u0026rsquo;aviation, l\u0026rsquo;internet, le GPS, beaucoup de technologies transformatrices nouvelles et coûteuses étaient d\u0026rsquo;abord utilisées par les gouvernements et les entreprises, avant de se diffuser aux consommateurs. Mais avec les LLM, c\u0026rsquo;est l\u0026rsquo;inverse. Avec les premiers ordinateurs, il s\u0026rsquo;agissait de balistique et d\u0026rsquo;usage militaire, mais avec les LLM, il s\u0026rsquo;agit de savoir comment faire bouillir un œuf. C\u0026rsquo;est fascinant que nous ayons un nouvel ordinateur magique qui m\u0026rsquo;aide à faire bouillir un œuf, et non à aider le gouvernement à faire quelque chose de fou comme de la balistique militaire ou une technologie spéciale. Les entreprises et les gouvernements sont en retard sur l\u0026rsquo;adoption de ces technologies par rapport à nous tous. Cela informe peut-être certaines utilisations de la technologie, comme où se trouvent les premières applications.\nRésumé\nLes LLM sont des systèmes d\u0026rsquo;exploitation complexes, comparables à l\u0026rsquo;informatique des années 1960, et nous refaisons l\u0026rsquo;informatique à nouveau. Ils sont actuellement disponibles via le partage de temps et distribués comme une utilité publique. Ce qui est nouveau et sans précédent, c\u0026rsquo;est qu\u0026rsquo;ils ne sont pas entre les mains de quelques gouvernements et entreprises, mais entre les mains de nous tous, car nous avons tous un ordinateur, et c\u0026rsquo;est juste du logiciel. ChatGPT a été envoyé à nos ordinateurs, à des milliards de personnes, instantanément et du jour au lendemain, ce qui est insensé. Maintenant, c\u0026rsquo;est à nous d\u0026rsquo;entrer dans l\u0026rsquo;industrie et de programmer ces ordinateurs. C\u0026rsquo;est assez remarquable.\nPsychologie des LLM\nAvant de programmer les LLM, nous devons réfléchir à ce qu\u0026rsquo;ils sont. J\u0026rsquo;aime parler de leur psychologie. Je vois les LLM comme des esprits humains, des simulations stochastiques de personnes, où le simulateur est un transformateur autorégressif. C\u0026rsquo;est un réseau neuronal qui avance token par token, avec presque la même quantité de calcul pour chaque token. Ce simulateur est ajusté à tout le texte que nous avons sur internet, et ainsi de suite, ce qui lui donne une psychologie émergente semblable à celle des humains.\nLa première chose que vous remarquez, c\u0026rsquo;est que les LLM ont une connaissance encyclopédique et une mémoire impressionnante. Ils peuvent se souvenir de beaucoup plus de choses qu\u0026rsquo;un individu humain, car ils ont lu énormément. Cela me rappelle le film Rain Man, que je recommande vivement. Dustin Hoffman y joue un savant autiste avec une mémoire presque parfaite, capable de lire un annuaire téléphonique et de se souvenir de tous les noms et numéros. Les LLM sont similaires : ils peuvent se souvenir de hachages SHA et de toutes sortes de choses très facilement. Ils ont donc des superpouvoirs à certains égards.\nMais ils ont aussi des déficits cognitifs. Ils hallucinent beaucoup, inventent des choses, et n\u0026rsquo;ont pas un très bon modèle interne de connaissance de soi, bien que cela s\u0026rsquo;améliore. Ils affichent une intelligence inégale : ils sont surhumains dans certains domaines de résolution de problèmes, mais font des erreurs qu\u0026rsquo;aucun humain ne ferait, comme insister que 9.11 est supérieur à 9.9 ou qu\u0026rsquo;il y a deux « r » dans « strawberry ». Ce sont des exemples célèbres, mais il y a des aspérités sur lesquelles on peut trébucher.\nIls souffrent aussi d\u0026rsquo;une sorte d\u0026rsquo;amnésie rétrograde. Si un collègue rejoint votre organisation, il apprendra au fil du temps à connaître l\u0026rsquo;organisation, gagnera du contexte, rentrera chez lui, dormira, consolidera ses connaissances et développera une expertise. Les LLM ne le font pas nativement, et ce n\u0026rsquo;est pas quelque chose qui a été résolu dans la recherche et développement des LLM. Les fenêtres de contexte sont comme une mémoire de travail, et vous devez programmer cette mémoire de travail assez directement, car ils ne deviennent pas plus intelligents par défaut. Beaucoup de gens se trompent sur ces analogies. Je recommande de regarder les films Memento et 50 First Dates, où les protagonistes ont leurs poids fixés et leurs fenêtres de contexte effacées chaque matin, ce qui rend le travail ou les relations problématiques.\nIl y a aussi des limitations liées à la sécurité. Les LLM sont assez crédules, vulnérables aux risques d\u0026rsquo;injection de prompts, et peuvent divulguer vos données. Il y a donc de nombreuses considérations liées à la sécurité.\nEn résumé, vous devez considérer cette chose surhumaine avec des déficits cognitifs et des problèmes, tout en étant extrêmement utile. Comment les programmer et contourner leurs déficits tout en profitant de leurs superpouvoirs ?\nOpportunités avec les LLM\nPassons maintenant aux opportunités d\u0026rsquo;utilisation de ces modèles et à certaines des plus grandes opportunités. Ce n\u0026rsquo;est pas une liste exhaustive, juste quelques éléments que je trouve intéressants pour cette conférence.\nApplications à autonomie partielle\nJe suis enthousiaste à propos de ce que j\u0026rsquo;appelle les applications à autonomie partielle. Prenons l\u0026rsquo;exemple du codage. Vous pouvez aller directement sur ChatGPT, copier-coller du code, des rapports de bogues, obtenir du code et tout copier-coller. Pourquoi faire cela ? Pourquoi aller directement au système d\u0026rsquo;exploitation ? Il est beaucoup plus logique d\u0026rsquo;avoir une application dédiée. Beaucoup d\u0026rsquo;entre vous utilisent probablement Cursor, que j\u0026rsquo;utilise aussi. Cursor est un très bon exemple d\u0026rsquo;une application LLM précoce avec des propriétés utiles pour toutes les applications LLM.\nVous remarquerez que nous avons une interface traditionnelle qui permet à un humain de faire tout le travail manuellement comme avant, mais en plus, nous avons cette intégration LLM qui permet d\u0026rsquo;avancer par plus gros morceaux. Voici quelques propriétés des applications LLM que je trouve utiles à souligner :\nLes LLM gèrent une grande partie de la gestion du contexte.\nIls orchestrent plusieurs appels aux LLM. Dans le cas de Cursor, il y a des modèles d\u0026rsquo;embedding pour tous vos fichiers, des modèles de chat, des modèles qui appliquent des différences au code, et tout cela est orchestré pour vous.\nUne interface graphique spécifique à l\u0026rsquo;application est très importante. Vous ne voulez pas parler directement au système d\u0026rsquo;exploitation en texte. Le texte est difficile à lire, interpréter et comprendre, et vous ne voulez pas prendre certaines actions nativement en texte. Il est beaucoup plus facile de voir une différence en rouge et vert, de voir ce qui est ajouté ou soustrait, et d\u0026rsquo;utiliser des commandes comme Cmd+Y pour accepter ou Cmd+N pour rejeter, plutôt que de devoir l\u0026rsquo;écrire en texte. Une interface graphique permet à un humain d\u0026rsquo;auditer le travail de ces systèmes faillibles et d\u0026rsquo;aller plus vite.\nCe que j\u0026rsquo;appelle le curseur d\u0026rsquo;autonomie. Dans Cursor, vous pouvez faire une complétion par tabulation, où vous êtes principalement en charge. Vous pouvez sélectionner un morceau de code et utiliser Cmd+K pour modifier juste ce morceau, Cmd+L pour modifier tout le fichier, ou Cmd+I pour laisser l\u0026rsquo;application faire ce qu\u0026rsquo;elle veut dans tout le dépôt, ce qui est la version agentique à pleine autonomie. Vous contrôlez ce curseur d\u0026rsquo;autonomie, et selon la complexité de la tâche, vous pouvez ajuster le niveau d\u0026rsquo;autonomie que vous êtes prêt à céder.\nUn autre exemple d\u0026rsquo;application LLM réussie est Perplexity. Elle possède des fonctionnalités similaires à celles que j\u0026rsquo;ai mentionnées pour Cursor. Elle regroupe beaucoup d\u0026rsquo;informations, orchestre plusieurs LLM, et a une interface graphique qui permet d\u0026rsquo;auditer une partie de son travail, comme citer des sources que vous pouvez inspecter. Elle a aussi un curseur d\u0026rsquo;autonomie : vous pouvez faire une recherche rapide, une recherche approfondie, ou une recherche très approfondie et revenir 10 minutes plus tard. Ce sont différents niveaux d\u0026rsquo;autonomie que vous cédez à l\u0026rsquo;outil.\nJe me demande à quoi cela ressemble si beaucoup de logiciels deviennent partiellement autonomes. Pour ceux d\u0026rsquo;entre vous qui maintiennent des produits et services, comment allez-vous rendre vos produits et services partiellement autonomes ? Un LLM peut-il voir tout ce qu\u0026rsquo;un humain peut voir ? Un LLM peut-il agir de toutes les manières dont un humain pourrait agir ? Les humains peuvent-ils superviser et rester dans la boucle de cette activité, car ce sont des systèmes faillibles qui ne sont pas encore parfaits ? À quoi ressemble une différence dans Photoshop, par exemple ? Beaucoup de logiciels traditionnels ont actuellement des interrupteurs et des éléments conçus pour les humains. Tout cela doit changer et devenir accessible aux LLM.\nUn point que je veux souligner avec beaucoup de ces applications LLM, qui ne reçoit peut-être pas autant d\u0026rsquo;attention qu\u0026rsquo;il le devrait, est que nous coopérons maintenant avec des IA. Habituellement, elles génèrent, et nous, humains, vérifions. Il est dans notre intérêt de faire tourner cette boucle le plus rapidement possible pour accomplir beaucoup de travail. Il y a deux façons principales d\u0026rsquo;y parvenir :\nAccélérer la vérification. Les interfaces graphiques sont extrêmement importantes pour cela, car elles exploitent le GPU de votre vision par ordinateur dans votre tête. Lire du texte est laborieux et pas amusant, mais regarder des choses est amusant et constitue une autoroute vers votre cerveau. Les interfaces graphiques sont donc très utiles pour auditer les systèmes et pour les représentations visuelles en général.\nGarder l\u0026rsquo;IA en laisse. Beaucoup de gens s\u0026rsquo;emballent trop avec les agents IA. Ce n\u0026rsquo;est pas utile de recevoir une différence de 10 000 lignes de code dans mon dépôt. Je reste le goulot d\u0026rsquo;étranglement, même si ces 10 000 lignes sortent instantanément. Je dois m\u0026rsquo;assurer que cela n\u0026rsquo;introduit pas de bogues, que c\u0026rsquo;est correct, et qu\u0026rsquo;il n\u0026rsquo;y a pas de problèmes de sécurité. Il est dans notre intérêt de faire tourner ce flux très rapidement et de garder l\u0026rsquo;IA en laisse, car elle devient trop réactive.\nQuand je fais du codage assisté par IA, si je code tranquillement, tout va bien, mais si j\u0026rsquo;essaie d\u0026rsquo;avancer dans mon travail, ce n\u0026rsquo;est pas génial d\u0026rsquo;avoir un agent trop réactif qui fait tout. Je travaille toujours sur de petits morceaux incrémentiels, je veux m\u0026rsquo;assurer que tout va bien, je veux faire tourner cette boucle très rapidement, et je travaille sur des choses concrètes et uniques. Beaucoup d\u0026rsquo;entre vous développent probablement des façons similaires de travailler avec les LLM. J\u0026rsquo;ai aussi vu plusieurs articles de blog qui tentent de développer ces meilleures pratiques pour travailler avec les LLM. J\u0026rsquo;en ai lu un récemment qui était assez bon, discutant de certaines techniques, notamment sur la manière de garder l\u0026rsquo;IA en laisse. Par exemple, si votre invite est vague, l\u0026rsquo;IA pourrait ne pas faire exactement ce que vous vouliez, et la vérification échouera. Vous demanderez autre chose, et si la vérification échoue, vous commencerez à tourner en rond. Il est donc plus logique de passer un peu plus de temps à être plus précis dans vos invites, ce qui augmente la probabilité d\u0026rsquo;une vérification réussie, et vous pouvez avancer.\nDans mon propre travail, je m\u0026rsquo;intéresse actuellement à ce que l\u0026rsquo;éducation pourrait être avec l\u0026rsquo;IA et les LLM. Beaucoup de mes réflexions portent sur la manière de garder l\u0026rsquo;IA en laisse. Je ne pense pas que cela fonctionne de dire à ChatGPT « Hey, enseigne-moi la physique ». L\u0026rsquo;IA se perd dans les bois. Pour moi, ce sont deux applications distinctes : une pour un enseignant qui crée des cours, et une qui prend ces cours et les sert aux étudiants. Dans les deux cas, nous avons cet artefact intermédiaire d\u0026rsquo;un cours qui est auditable, nous pouvons nous assurer qu\u0026rsquo;il est bon, cohérent, et l\u0026rsquo;IA est gardée en laisse par rapport à un certain programme, une certaine progression de projets, etc. C\u0026rsquo;est une façon de garder l\u0026rsquo;IA en laisse, et je pense que cela a beaucoup plus de chances de fonctionner.\nUne autre analogie à laquelle je fais référence est mon expérience chez Tesla, où j\u0026rsquo;ai travaillé pendant cinq ans sur un produit à autonomie partielle, qui partage beaucoup de caractéristiques. Par exemple, dans le tableau de bord, il y a l\u0026rsquo;interface graphique du pilote automatique, qui montre ce que le réseau neuronal voit. Nous avions le curseur d\u0026rsquo;autonomie, et au fil de mon temps là-bas, nous faisions de plus en plus de tâches autonomes pour l\u0026rsquo;utilisateur. Une petite histoire : la première fois que j\u0026rsquo;ai conduit un véhicule autonome, c\u0026rsquo;était en 2013. Un ami qui travaillait chez Waymo m\u0026rsquo;a proposé de faire un tour à Palo Alto. J\u0026rsquo;ai pris une photo avec Google Glass à l\u0026rsquo;époque – beaucoup d\u0026rsquo;entre vous sont si jeunes que vous ne savez peut-être même pas ce que c\u0026rsquo;est. Nous sommes montés dans la voiture, avons fait un trajet d\u0026rsquo;environ 30 minutes sur les autoroutes et les rues de Palo Alto, et ce trajet était parfait, sans aucune intervention. C\u0026rsquo;était en 2013, il y a 12 ans, et cela m\u0026rsquo;a frappé, car à l\u0026rsquo;époque, après ce trajet parfait, j\u0026rsquo;ai pensé que la conduite autonome était imminente. Mais nous sommes en 2025, et nous travaillons toujours sur l\u0026rsquo;autonomie, sur les agents de conduite. Même maintenant, nous n\u0026rsquo;avons pas vraiment résolu le problème. Vous voyez peut-être des Waymo circuler sans conducteur, mais il y a encore beaucoup de téléopération et d\u0026rsquo;humains dans la boucle. Nous n\u0026rsquo;avons pas encore déclaré le succès, mais je pense que cela va réussir à ce stade, mais cela a pris beaucoup de temps.\nLe logiciel est vraiment complexe, tout comme la conduite. Quand je vois des affirmations comme « 2025 est l\u0026rsquo;année des agents », je m\u0026rsquo;inquiète. Je pense que c\u0026rsquo;est la décennie des agents, et cela va prendre du temps. Nous avons besoin d\u0026rsquo;humains dans la boucle, nous devons le faire prudemment. Soyons sérieux, c\u0026rsquo;est du logiciel.\nUne autre analogie que je considère toujours est l\u0026rsquo;armure d\u0026rsquo;Iron Man. J\u0026rsquo;adore Iron Man, je pense que c\u0026rsquo;est tellement juste à bien des égards concernant la technologie et comment elle va se déployer. Ce que j\u0026rsquo;aime dans l\u0026rsquo;armure d\u0026rsquo;Iron Man, c\u0026rsquo;est qu\u0026rsquo;elle est à la fois une augmentation – Tony Stark peut la piloter – et un agent. Dans certains films, l\u0026rsquo;armure est assez autonome, peut voler et trouver Tony, etc. C\u0026rsquo;est le curseur d\u0026rsquo;autonomie : nous pouvons construire des augmentations ou des agents, et nous voulons faire un peu des deux. Mais à ce stade, en travaillant avec des LLM faillibles, je dirais qu\u0026rsquo;il s\u0026rsquo;agit moins de robots Iron Man et plus de combinaisons Iron Man. Il s\u0026rsquo;agit moins de construire des démos flashy d\u0026rsquo;agents autonomes et plus de construire des produits à autonomie partielle. Ces produits ont des interfaces graphiques personnalisées et une expérience utilisateur, conçus pour que la boucle de génération-vérification humaine soit très rapide, tout en gardant à l\u0026rsquo;esprit qu\u0026rsquo;il est en principe possible d\u0026rsquo;automatiser ce travail. Il devrait y avoir un curseur d\u0026rsquo;autonomie dans votre produit, et vous devriez réfléchir à comment faire glisser ce curseur pour rendre votre produit plus autonome avec le temps.\nProgrammation en anglais\nPassons à une autre dimension que je trouve très unique. Non seulement il y a un nouveau type de langage de programmation qui permet l\u0026rsquo;autonomie dans les logiciels, mais comme je l\u0026rsquo;ai mentionné, il est programmé en anglais, qui est une interface naturelle. Soudain, tout le monde est programmeur, car tout le monde parle une langue naturelle comme l\u0026rsquo;anglais. C\u0026rsquo;est extrêmement optimiste et très intéressant pour moi, et totalement sans précédent. Avant, il fallait passer cinq à dix ans à étudier pour pouvoir faire quelque chose en logiciel. Ce n\u0026rsquo;est plus le cas.\nQuelqu\u0026rsquo;un a-t-il entendu parler du « vibe coding » ? C\u0026rsquo;est un tweet qui a introduit ce concept, et on m\u0026rsquo;a dit que c\u0026rsquo;est maintenant un mème majeur. Une anecdote amusante : je suis sur Twitter depuis environ 15 ans, et je n\u0026rsquo;ai toujours aucune idée de quel tweet va devenir viral et lequel va passer inaperçu. Je pensais que ce tweet allait être dans la deuxième catégorie, juste une pensée spontanée, mais il est devenu un mème total. Je ne peux pas vraiment prévoir, mais je suppose qu\u0026rsquo;il a touché une corde sensible et donné un nom à quelque chose que tout le monde ressentait mais ne pouvait pas exprimer en mots. Maintenant, il y a même une page Wikipédia pour ça.\nTom Wolf de Hugging Face a partagé une vidéo magnifique que j\u0026rsquo;adore, montrant des enfants en train de faire du vibe coding. Je trouve cette vidéo tellement saine. Comment peut-on regarder cette vidéo et se sentir mal à propos de l\u0026rsquo;avenir ? L\u0026rsquo;avenir est prometteur. Je pense que cela deviendra une porte d\u0026rsquo;entrée vers le développement logiciel. Je ne suis pas pessimiste quant à l\u0026rsquo;avenir de cette génération.\nJ\u0026rsquo;ai aussi essayé le vibe coding, car c\u0026rsquo;est tellement amusant. C\u0026rsquo;est génial quand vous voulez construire quelque chose de super personnalisé qui n\u0026rsquo;existe pas et que vous voulez juste tenter le coup un samedi. J\u0026rsquo;ai construit une application iOS, et je ne sais pas programmer en Swift, mais j\u0026rsquo;ai été choqué de pouvoir construire une application super basique. Je ne vais pas l\u0026rsquo;expliquer, c\u0026rsquo;est vraiment idiot, mais c\u0026rsquo;était juste une journée de travail, et ça fonctionnait sur mon téléphone le même jour. J\u0026rsquo;étais comme « Wow, c\u0026rsquo;est incroyable ». Je n\u0026rsquo;ai pas eu à lire des manuels sur Swift pendant cinq jours pour commencer.\nJ\u0026rsquo;ai aussi fait du vibe coding pour une application appelée MenuGen, qui est en ligne sur menu.app. J\u0026rsquo;avais ce problème où j\u0026rsquo;arrive dans un restaurant, je lis le menu, et je n\u0026rsquo;ai aucune idée de ce que sont les plats, et j\u0026rsquo;ai besoin d\u0026rsquo;images. Ça n\u0026rsquo;existait pas, alors je me suis dit « Je vais le coder en mode vibe ». Vous allez sur menu.app, prenez une photo d\u0026rsquo;un menu, et MenuGen génère les images. Tout le monde reçoit 5 $ de crédits gratuits en s\u0026rsquo;inscrivant, ce qui est un centre de coûts majeur dans ma vie. Cette application me fait perdre beaucoup d\u0026rsquo;argent.\nCe qui est fascinant avec MenuGen, c\u0026rsquo;est que coder la partie vibe coding était la partie facile. La plupart des difficultés sont survenues quand j\u0026rsquo;ai essayé de la rendre réelle, avec l\u0026rsquo;authentification, les paiements, le nom de domaine, et le déploiement sur Vercel. Tout cela n\u0026rsquo;était pas du code, c\u0026rsquo;était du DevOps, cliquer sur des choses dans le navigateur, et c\u0026rsquo;était extrêmement lent, ça a pris une autre semaine. J\u0026rsquo;avais une démo de MenuGen fonctionnant sur mon ordinateur portable en quelques heures, mais il m\u0026rsquo;a fallu une semaine pour la rendre réelle, car c\u0026rsquo;était vraiment agaçant. Par exemple, ajouter une connexion Google à votre page web implique une énorme quantité d\u0026rsquo;instructions d\u0026rsquo;une bibliothèque comme Clerk, me disant d\u0026rsquo;aller à telle URL, de cliquer sur tel menu déroulant, de choisir ceci, d\u0026rsquo;aller là et de cliquer sur ça. C\u0026rsquo;est comme si un ordinateur me disait quoi faire. Pourquoi est-ce que je fais ça ? Fais-le toi-même !\nConstruire pour les agents\nLa dernière partie de ma conférence se concentre sur la possibilité de construire pour les agents. Je ne veux pas faire ce travail, les agents peuvent-ils le faire ? Grossièrement, je pense qu\u0026rsquo;il y a une nouvelle catégorie de consommateurs et de manipulateurs d\u0026rsquo;informations numériques. Avant, c\u0026rsquo;étaient juste les humains via les interfaces graphiques ou les ordinateurs via les API. Maintenant, nous avons une chose complètement nouvelle : les agents. Ce sont des ordinateurs, mais ils sont un peu comme des humains, des esprits humains sur internet, et ils doivent interagir avec notre infrastructure logicielle. Pouvons-nous construire pour eux ? C\u0026rsquo;est une nouveauté.\nPar exemple, vous pouvez avoir un fichier robots.txt sur votre domaine pour indiquer aux robots d\u0026rsquo;indexation comment se comporter sur votre site. De la même manière, vous pourriez avoir un fichier llm.txt, un simple fichier Markdown expliquant à un LLM de quoi parle ce domaine. C\u0026rsquo;est très lisible pour un LLM. S\u0026rsquo;il devait récupérer le HTML de votre page web et essayer de le parser, ce serait très sujet aux erreurs et difficile. Nous pouvons parler directement aux LLM, ça vaut le coup.\nUne grande quantité de documentation est actuellement écrite pour les humains, avec des listes, du texte en gras, des images, ce qui n\u0026rsquo;est pas directement accessible aux LLM. Certains services commencent à transformer leurs documentations pour qu\u0026rsquo;elles soient spécifiquement destinées aux LLM. Vercel et Stripe, par exemple, sont des pionniers ici, mais j\u0026rsquo;en ai vu d\u0026rsquo;autres. Ils proposent leur documentation en Markdown, qui est super facile à comprendre pour les LLM. C\u0026rsquo;est génial.\nUn exemple simple de mon expérience : certains d\u0026rsquo;entre vous connaissent peut-être 3Blue1Brown, qui fait de magnifiques vidéos d\u0026rsquo;animation sur YouTube. Il a écrit une bibliothèque appelée Manim, et je voulais faire mes propres animations. Il y a une documentation extensive sur l\u0026rsquo;utilisation de Manim, mais je ne voulais pas la lire. J\u0026rsquo;ai donc copié-collé tout le contenu dans un LLM, décrit ce que je voulais, et ça a fonctionné directement. Le LLM m\u0026rsquo;a créé une animation exactement comme je le voulais, et j\u0026rsquo;étais comme « Wow, c\u0026rsquo;est incroyable ». Si nous rendons les documentations lisibles pour les LLM, cela va débloquer une énorme quantité d\u0026rsquo;utilisations, et je pense que c\u0026rsquo;est merveilleux et que ça devrait se faire plus souvent.\nMalheureusement, il ne s\u0026rsquo;agit pas seulement de prendre vos documentations et de les mettre en Markdown, ce qui est la partie facile. Il faut aussi modifier les documentations, car chaque fois qu\u0026rsquo;elles disent « cliquez ici », c\u0026rsquo;est mauvais. Un LLM ne peut pas nativement prendre cette action pour le moment. Vercel, par exemple, remplace chaque occurrence de « cliquez » par une commande curl équivalente que votre agent LLM pourrait exécuter à votre place. Je trouve cela très intéressant. Il y a aussi le protocole de contexte de modèle d\u0026rsquo;Anthropic, une autre façon de parler directement aux agents en tant que nouveaux consommateurs et manipulateurs d\u0026rsquo;informations numériques. Je suis très optimiste sur ces idées.\nJ\u0026rsquo;aime aussi plusieurs petits outils ici et là qui aident à ingérer des données dans des formats très adaptés aux LLM. Par exemple, quand je vais sur un dépôt GitHub comme mon dépôt nanoGPT, je ne peux pas le donner à un LLM et poser des questions, car c\u0026rsquo;est une interface humaine sur GitHub. Mais si vous changez l\u0026rsquo;URL de GitHub à GetIngest, cela concatène tous les fichiers en un seul texte géant, crée une structure de répertoire, etc., et c\u0026rsquo;est prêt à être copié-collé dans votre LLM préféré. Un exemple encore plus frappant est DeepWiki, où ce n\u0026rsquo;est pas juste le contenu brut des fichiers. Devon, par exemple, analyse le dépôt GitHub et construit toute une page de documentation pour votre dépôt, ce qui est encore plus utile à copier-coller dans votre LLM.\nJ\u0026rsquo;adore tous ces petits outils où vous changez simplement l\u0026rsquo;URL, et ça rend quelque chose accessible à un LLM. C\u0026rsquo;est très bien, et il devrait y en avoir beaucoup plus. Une note supplémentaire : il est tout à fait possible que dans le futur – et même aujourd\u0026rsquo;hui – les LLM puissent naviguer et cliquer sur des choses. Mais je pense toujours qu\u0026rsquo;il vaut la peine de rencontrer les LLM à mi-chemin et de faciliter leur accès à toutes ces informations, car c\u0026rsquo;est encore assez coûteux et beaucoup plus difficile. Il y aura une longue traîne de logiciels qui ne s\u0026rsquo;adapteront pas, car ce ne sont pas des dépôts ou des infrastructures numériques très actifs. Nous aurons besoin de ces outils, mais pour tous les autres, je pense qu\u0026rsquo;il vaut la peine de trouver un point de rencontre.\nConclusion\nQuel moment incroyable pour entrer dans l\u0026rsquo;industrie ! Nous devons réécrire une tonne de code, qui sera écrit par des professionnels et des codeurs. Les LLM sont un peu comme des utilités publiques, un peu comme des fabriques, mais surtout comme des systèmes d\u0026rsquo;exploitation. C\u0026rsquo;est tellement tôt, c\u0026rsquo;est comme les années 1960 des systèmes d\u0026rsquo;exploitation, et beaucoup d\u0026rsquo;analogies se croisent. Ces LLM sont comme des esprits humains faillibles avec lesquels nous devons apprendre à travailler. Pour le faire correctement, nous devons ajuster notre infrastructure en conséquence.\nQuand vous construisez des applications LLM, j\u0026rsquo;ai décrit certaines façons de travailler efficacement avec ces LLM et certains outils qui rendent cela possible, ainsi que comment faire tourner cette boucle très rapidement pour créer des produits à autonomie partielle. Beaucoup de code devra aussi être écrit plus directement pour les agents. En revenant à l\u0026rsquo;analogie de l\u0026rsquo;armure d\u0026rsquo;Iron Man, je pense que sur la prochaine décennie, nous allons faire glisser le curseur d\u0026rsquo;autonomie de gauche à droite, et il sera très intéressant de voir à quoi cela ressemble. J\u0026rsquo;ai hâte de le construire avec vous tous. Merci.\nRobot # Dans ce cours, vous êtes encouragé à utiliser l\u0026rsquo;intelligence artificielle pour mieux apprendre à programmer. L\u0026rsquo;Université TÉLUQ met à votre disposition un robot conversationnel dédié au cours. Ce robot, basé sur des technologies avancées d\u0026rsquo;IA, vous permettra d\u0026rsquo;obtenir des réponses personnalisées à vos questions, de clarifier des concepts complexes et de recevoir des exemples de code pertinents. En interagissant avec cet outil, vous pourrez approfondir votre compréhension des notions abordées, pratiquer vos compétences en programmation et progresser à votre rythme, tout en bénéficiant d\u0026rsquo;un soutien adapté à vos besoins. Vous pouvez aussi utiliser d\u0026rsquo;autres outils comme ChatGTP, copilot, Grok, etc.\nLe cours INF 1220 a probablement été le premier cours au Québec à disposer d\u0026rsquo;un robot conversationnel. Je vous invite à consulter cet article par madame Roy de Radio-Canada:\nIA à l’université : mieux comprendre pour mieux se préparer Pour maximiser l’efficacité de ces outils d’intelligence artificielle, il est recommandé de poser des questions précises et bien formulées. Par exemple, demandez des explications sur des erreurs de code spécifiques, des suggestions pour optimiser vos programmes ou des éclaircissements sur des concepts théoriques. Ces outils peuvent également vous aider à explorer des approches alternatives pour résoudre des problèmes de programmation, renforçant ainsi votre créativité et votre autonomie. En combinant l’utilisation de ces ressources avec les activités du cours, vous développerez des compétences solides et une meilleure confiance en vos capacités de programmation.\n"},{"id":18,"href":"/inf1220-hugo/docs/modules/module1/autoevaluation/","title":"Autoévaluation","section":"Module 1: Algorithme et pseudocode","content":" Autoévaluation # Avant de débuter le cours, il est important de faire le point sur votre préparation. Je vous invite donc à faire une autoévaluation.\nConnaissances technologiques # Le cours ne nécessite pas une connaissance approfondie du fonctionnement des ordinateurs, mais il est utile d'avoir une certaine connaissance de base. Vous devriez savoir que les ordinateurs disposent d'un processeur, de mémoire, de disques, etc. et qu'ils fonctionnent à l'aide d'un système d'exploitation. Si vous ne vous êtes jamais intéressés à ces concepts de base, il peut être utile que vous preniez un peu de votre temps pour faire des recherches sur ces questions. Il peut être difficile de suivre ce cours si vous ne savez vraiment pas ce qu'est un processeur ou de la mémoire informatique.\nMathématiques # Pour pouvoir faire de l\u0026rsquo;informatique, il convient de connaître les mathématiques. La division euclidienne, par exemple, offre une perspective fondamentale sur la décomposition des nombres. Elle ne se limite pas à un calcul, mais exprime une relation entre un dividende, un diviseur, un quotient et un reste. Considérons \\( 75 \\div 8 \\) : le quotient est \\( 9 \\) et le reste \\( 3 \\), car \\( 8 \\times 9 = 72 \\) et \\( 75 - 72 = 3 \\). De même, pour \\( 20 \\div 6 \\), le quotient est \\( 3 \\) et le reste \\( 2 \\). Le reste, toujours inférieur au diviseur, capture l’excédent d’une division imparfaite. Cette idée devient puissante lorsqu’on remarque, par exemple, que si \\( x \\div y \\) laisse un reste de \\( 1 \\), alors \\( x - 1 \\) est un multiple de \\( y \\), révélant une propriété intrinsèque de divisibilité. Les nombres se déclinent en catégories – entiers, réels, rationnels, irrationnels – chacune porteuse de propriétés distinctes. Le nombre \\( \\sqrt{2} \\), réel et irrationnel, défie toute représentation fractionnaire, incarnant une rupture avec les nombres rationnels. Le théorème fondamental de l’arithmétique, quant à lui, établit que tout entier positif supérieur à \\( 1 \\) se factorise de manière unique en nombres premiers. Ainsi, \\( 28 = 2^2 \\times 7 \\). Si \\( x \\) divise un nombre impair \\( z \\), alors \\( x \\) est nécessairement impair, car un diviseur pair engendrerait un résultat pair, contredisant l’hypothèse. Les opérations algébriques, régies par un ordre de priorité, reflètent une logique de structuration des calculs. Les parenthèses redéfinissent cet ordre, comme dans \\( (2 + 3) \\times 5 = 25 \\), où l’addition prime, contrairement à \\( 2 + 3 \\times 5 = 17 \\), où la multiplication domine. Les exposants et les logarithmes sont un exemple de fonction inverse : nous avons que \\( \\log_3(81) = 4 \\) car \\( 3^4 = 81 \\). La propriété \\( \\frac{\\log x}{\\log b} = \\log_b x \\) est fort utile. La factorielle, comme \\( 4! = 4 \\times 3 \\times 2 \\times 1 = 24 \\), quantifie les arrangements possibles. Pour la probabilité d’obtenir une somme de \\( 7 \\) avec deux dés, on recense les cas favorables \\( (1,6), (2,5), (3,4), (4,3), (5,2), (6,1) \\), soit 6, sur 36 résultats, donnant \\( \\frac{6}{36} = \\frac{1}{6} \\). On peut trier les objects selon différents ordres. L’ordre lexicographique, appliqué à des nombres comme \\( 3, 30, 4 \\), les trie comme des chaînes \\( 3, 30, 4 \\), illustrant une logique de classement importée du langage. La notion de nombre en base \\( b \\) désigne la manière dont un nombre est représenté dans un système de numération où \\( b \\) est le nombre d\u0026rsquo;unités distinctes utilisées, appelées chiffres. Nous utilisons normalement des nombres en base 10, mais d\u0026rsquo;autres bases sont utilisées en informatique.\nSi vous n'avez pas fait les mathématiques du collégial ou pris un cours d'appoint équivalent, vous ne pouvez pas suivre INF 1220. Si on vous demande de suivre un cours d'appoint en mathématiques, vous devez suivre ce cours d'appoint avant de vous inscrire à INF 1220. Il est de votre responsabilité d'y voir.\nSi vous avez réussi les mathématiques du collégial il y a trop longtemps, vous devez soit les réviser, soit prendre un cours d'appoint. On s'attend à ce que les étudiants de ce cours, et les étudiants qui adoptent un cheminement en informatique généralement, aient de longue date une aisance mathématique. Par exemple, si vous avez complété vos études secondaires au Québec récemment, on s'attend à ce que vous apparteniez aux profils Technico-Science ou Sciences Naturelles plutôt que Culture, Société et Technique.\nAutoévaluation (mathématiques) # Faites l'autoévaluation mathématique suivante avant de continuer au sein du cours. Ces questions devraient être faciles, même évidentes, si vous avez une préparation adéquate. Quiz de mathématiques Répondez à chaque question pour tester vos connaissances. Un retour vous sera fourni après chaque réponse.\nScore : 0 / 0 Soumettre Recommencer Si ces questions ne sont pas faciles pour vous, ne continuez pas dans ce cours!!! Vous devez soit réviser vos mathématiques de base, et peut-être suivre un cours d'appoint tout en poursuivant des études complémentaires sur une base autonome.\nCertains étudiants qui n'ont pas la préparation suffisante décident de tout de même poursuivre dans le cours sans pour autant prévoir du temps supplémentaire pour l'étude de la matière vue au secondaire et au collégial. Malheureusement pour eux, ils se rendent souvent compte qu'ils vont faire face à des difficultés alors qu'il n'est plus possible d'abandonner le cours sans pénalité. Parfois, ces étudiants s'attendaient à tort que le cours leur permette de combler les failles dans leur préparation, ou bien alors ils ne prennent pas sérieusement nos avertissements. Soyez responsable et évitez donc les ennuis: assurez-vous d'avoir une préparation adéquate avant de poursuivre dans le cours !\nAutoévaluation (aptitude en programmation) # Pour se préparer au cours INF 1220, il est crucial de développer une rigueur intellectuelle et une capacité à raisonner de manière abstraite, deux qualités indispensables à la programmation. Programmer ne se limite pas à écrire des lignes de code : c’est un exercice de pensée structurée qui exige de décomposer un problème en étapes logiques, de les traduire en instructions précises et de vérifier méticuleusement leur exactitude. Un programme fonctionne ou échoue sans demi-mesure, ce qui impose une discipline constante : écrire, tester, corriger, puis tester à nouveau. La patience et l’attention aux détails sont essentielles, car une simple erreur, comme une virgule mal placée, peut compromettre un programme entier. S’entraîner à résoudre des problèmes logiques, comme déterminer qui de Jean ou Pierre arrive en premier au travail dans un énoncé où Jean est immédiatement suivi par Pierre, aide à affûter cette précision. Si de tels énoncés semblent opaques ou exigent un effort disproportionné, il peut être utile de renforcer ses bases en logique avant d’aborder le cours.\nQuestion 1 # Jean et Pierre travaillent ensemble. Jean s\u0026rsquo;assure d\u0026rsquo;être toujours immédiatement suivi par Pierre quand ils arrivent au travail. Qui arrive le premier au travail ?\nProblème de logique : qui arrive le premier ? Jean et Pierre travaillent ensemble. Jean s’assure d’être toujours immédiatement suivi par Pierre quand ils arrivent au travail. Qui arrive le premier au travail ?\nJean Pierre Les deux Soumettre Si cet énoncé ne vous semble pas clair et que vous ne trouvez pas immédiatement la bonne réponse, il est probable que vous ne devriez pas suivre le cours INF 1220.\nQuestion 2 # Supposons que vous disposiez d\u0026rsquo;un livre ayant des pages numérotées (1, 2, 3, \u0026hellip;). Vous souhaitez lire toutes les pages. Vous appliquez la recette suivante.\nVous disposez d\u0026rsquo;un calepin (effaçable) où vous pouvez écrire un nombre entier, et un seul nombre entier. Vous écrivez sur le calepin le nombre zéro (0). Vous passez ensuite à l\u0026rsquo;étape A.\nÉtape A : Vous prenez le calepin, vous consultez le nombre qui y est écrit, vous lui ajoutez un, et vous écrivez le résultat sur le calepin. Par exemple, si la valeur lue est \u0026ldquo;0\u0026rdquo;, vous la remplacez par \u0026ldquo;1\u0026rdquo;. Vous passez ensuite à l\u0026rsquo;étape B. Étape B : Vous prenez le calepin, vous consultez le nombre qui y est écrit, vous allez à la page correspondante au nombre lu dans le livre, vous lisez la page en question. Vous passez ensuite à l\u0026rsquo;étape C. Étape C : Vous prenez le calepin, vous consultez le nombre qui y est écrit. Si le nombre lu excède le nombre de pages du livre, vous terminez la recette et vous fermez définitivement le livre. Autrement, vous retournez à l\u0026rsquo;étape A. Essayez d\u0026rsquo;appliquer cette recette avec un livre comptant cinq pages. Que constatez-vous ?\nUtilisez cette application pour explorer le problème.\nSimulation de l'algorithme de lecture Étape : Initialisation\nCalepin : 0\nPages lues : Aucune Prochaine étape Réinitialiser Cette recette est erronée. Si vous êtes incapable de voir l\u0026rsquo;erreur rapidement, ou si ça vous demande beaucoup d\u0026rsquo;effort, il est possible que vous n\u0026rsquo;ayez pas de bonnes aptitudes pour la programmation et que le cours INF 1220 ne soit pas pour vous. Cela ne signifie pas que vous ne puissiez pas apprendre à programmer, mais le cours INF 1220 a été pensé en fonction d\u0026rsquo;étudiants qui ont un certain degré de préparation.\nSi vous n\u0026rsquo;avez pas les aptitudes requises, le cours peut vous paraître inaccessible. Il est possible que vous deviez consacrer beaucoup plus que 9 heures par semaine pour réussir le cours. Vous devez garder à l\u0026rsquo;esprit que le cours INF 1220 est un cours d\u0026rsquo;informatique universitaire offert au sein d\u0026rsquo;un cursus scientifique menant à des diplômes en informatique.\nMaîtrise de l\u0026rsquo;anglais # Le site web du cours, ses travaux, ses vidéos et ses exercices, ainsi que notre manuel (Java pas à pas) et notre manuel de référence sont tous en français. Par contre, l'anglais est un incontournable en informatique. De temps en temps, nous allons donc vous offrir des liens vers des ressources (optionnelles) en anglais.\nSi vous ne maîtrisez pas l'anglais, vous devez savoir qu'il est essentiellement impossible de faire carrière ou d'avancer dans le domaine de l'informatique sans une maîtrise élémentaire de l'anglais.\nL'informatique s'est développée d'abord et avant tout dans les pays anglophones (principalement la Grande-Bretagne et les États-Unis). La grande puissance Américaine domine le domaine de l'informatique. S'il est possible d'utiliser des ordinateurs sans maîtriser l'anglais, il n'est pas envisageable de développer du logiciel sans maîtriser l'anglais.\nUn cours difficile ? # Le cours est un cours d'informatique universitaire, il conçu de manière à vous préparer à suivre une formation plus poussée en informatique. Il ne s'agit donc pas d'un cours technique qui vise à vous former pour un travail pratique et immédiat. On ne cherche pas à apprendre la programmation le plus rapidement possible, mais bien à établir des bases solides en étudiant les principes de base comme la notion d'algorithme. Notre objectif premier est de vous préparer à des cours plus avancés en informatique. Il ne s'agit donc pas d'un cours grand public. Nous y utilisons une terminologie propre à l'informatique. Nous n'évitons pas les mathématiques. Le contenu du cours, la charge de travail, l'ampleur de travaux et la composition de l'examen sont comparables à ce que vous trouvez au sein de cours d'introduction à la programmation dans les universités québécoises. Il s'agit tout de même d'un cours d'introduction: si avez pris des cours de programmation auparavant, ou que vous avez une longue expérience avec la programmation informatique, ce cours n'est sans doute pas pour vous.\nLa quasi-totalité des nos étudiants au sein du cours INF 1220 viennent de trois programmes: développement logiciel (0127), informatique appliquée (4128) et majeure en informatique (6010). Sur 250 étudiants par année, il y a environ 5 échecs et 20 abandons. Nous travaillons continuellement pour améliorer le taux de réussite de nos étudiants, mais rien ne peut remplacer un engagement sérieux de la part des étudiants. Ceci étant dit, nous sommes fiers du fait que parmi les étudiants qui terminent le cours, la grande majorité apprécient beaucoup le cours. Il s'agit souvent d'un des cours les mieux évalués au sein de notre université.\nVoici quelques commentaires de nos étudiants : INF 1220 une vraie initiation au paradigme OO pour moi, et j'ai aussi réalisé que mon cours sur Udemy était insuffisant, voire médiocre... J'ai un bac en administration et ce cours est de loin le cours le plus difficile que j'ai suivi. Il a parfois fallu que je cherche longtemps sur Internet, et j'ai souvent été frustré par le Java, mais maintenant que j'ai terminé le cours, j'ai vraiment l'impression d'avoir appris à programmer. Le taux de réussite du cours est d'environ 80%. En d'autres termes, de tous les étudiants qui s'inscrivent et cheminent dans le cours, 80% auront la note de passage.\nNous croyons que si vous vous engagez pleinement dans le cours et que vous avez la préparation et les aptitudes nécessaires, vous serez satisfait de votre expérience.\n"},{"id":19,"href":"/inf1220-hugo/docs/modules/module5/exercices-5-1/","title":"Exercices sur l’héritage et le polymorphisme","section":"Module 5. La programmation orientée objet: héritage et le polymorphisme","content":" Exercices sur l\u0026rsquo;héritage et le polymorphisme. # Questions/Réponses # Veuillez répondre mentalement, sur papier ou bien en créant le code nécessaire pour répondre à ces questions avant de regarder la réponse.\nPrenez note qu'il est permis d'utiliser le robot conversationnel du cours lors des exercises. Cependant vous devriez vous entraîner à produire vos propres réponses.\nRéponses uniques? # Les exercices comportent une solution vous permettant de comparer votre approche avec la nôtre. Il n'y a pas de solution unique aux problèmes en général. Vous pouvez arriver avec une solution qui est préférable ou moins bonne que celle que nous offrons. Pour faire ces questions, vous devez avoir fait toutes les lectures préalables. Vous disposez alors toujours des fondements nécessaires pour faire les exercices. Nous vous encourageons tout de même à faire vos propres recherches en complément de vos lectures. Dans certains cas, au sein de la solution que nous offrons, nous pouvons utiliser des notions techniques qui n'ont pas été vues directement dans le cours, mais qui devraient vous être facilement accessibles.\nQuestion 1 # Pourquoi le code suivant entraîne t-il une erreur à la compilation?\npublic class Test extends JFrame, Thread { String test; public Test(String test) { this.test = test; } public void run() { System.out.println(test); } } Réponse En Java, il est impossible de faire de l'héritage multiple, il faut donc soit hériter de JFrame ou de Thread, mais pas les deux à la fois. Une façon de contourner le problème serait d'implémenter l'interface Runnable, puis de passer en paramètre cette classe à un thread.\nQuestion 2 # Voici ci dessous, une classe permettant de lire une image de type PNG et d'en extraire les occurrences de gradients de couleur :\npublic class PNGGradientExtractor { int[][] gradientMatrix; public PNGGradientExtractor(File file) { // Lit le fichier et charge loadImage(file); } public void loadImage(File file) { //Charge l\u0026#39;image et la met en format \u0026#34;raw\u0026#34; dans la matrice gradientMatrix return; } public HashMap getGradientMap() { // Retourne une hashmap avec l\u0026#39;occurence de gradient dans l\u0026#39;image return null; } } À l'aide de l'héritage et des classes abstraites, veuillez implémenter les classes qui permettront de : a. Créer une classe abstraite GradientExtractor; b. Créer une classe GIFGradientExtractor; c. modifier PNGGradientExtractor pour tenir compte des changements précédent. Pour simplifier l'exercice, ce qui diffère le GIF du PNG est le chargement de l'image dans la matrice gradientMatrix. VOUS DEVEZ FAIRE SEULEMENT LA STRUCTURE (CLASSES ET MÉTHODES) SANS IMPLÉMENTATION!\nRéponse public abstract class GradientExtractor { protected int [][] gradientMatrix; public HashMap getGradientMap() { // Retourne une hashmap avec l\u0026#39;occurence de gradient dans l\u0026#39;image return null; } public abstract void loadImage(File file); } public class GIFGradientExtractor extends GradientExtractor { public GIFGradientExtractor(File file) { // Lit le fichier et charge loadImage(file); } public void loadImage(File file) { //Charge l\u0026#39;image et la met en format \u0026#34;raw\u0026#34; dans la matrice gradientMatrix return; } } public class PNGGradientExtractor extends GradientExtractor { public PNGGradientExtractor(File file) { // Lit le fichier et charge loadImage(file); } public void loadImage(File file) { //Charge l\u0026#39;image et la met en format \u0026#34;raw\u0026#34; dans la matrice gradientMatrix return; } } Question 3 # Voici une classe permettant de calculer la regression linéaire d'une série temporelle d'entier\u0026nbsp;:\npublic class SerieTemporelle { int[] serie; public SerieTemporelle(int[] serie) { this.serie = serie; } public void calculerRegressionLineaire() { int MAXN = 1000; double[] x = new double[MAXN]; double[] y = new double[MAXN]; // first pass: read in data, compute xbar and ybar double sumx = 0.0, sumy = 0.0, sumx2 = 0.0; for (int i = 0; i \u0026lt; serie.length; i++) { x[i] = i; y[i] = serie[i]; sumx += x[i]; sumx2 += x[i] * x[i]; sumy += y[i]; } double xbar = sumx / serie.length; double ybar = sumy / serie.length; // second pass: compute summary statistics double xxbar = 0.0, yybar = 0.0, xybar = 0.0; for (int i = 0; i \u0026lt; serie.length; i++) { xxbar += (x[i] - xbar) * (x[i] - xbar); yybar += (y[i] - ybar) * (y[i] - ybar); xybar += (x[i] - xbar) * (y[i] - ybar); } double beta1 = xybar / xxbar; double beta0 = ybar - beta1 * xbar; // print results System.out.println(\u0026#34;y = \u0026#34; + beta1 + \u0026#34; * x + \u0026#34; + beta0); // analyze results int df = serie.length - 2; double rss = 0.0; // residual sum of squares double ssr = 0.0; // regression sum of squares for (int i = 0; i \u0026lt; serie.length; i++) { double fit = beta1*x[i]+beta0; rss += (fit - y[i]) * (fit - y[i]); ssr += (fit - ybar) * (fit - ybar); } double R2 = ssr / yybar; double svar = rss / df; double svar1 = svar / xxbar; double svar0 = svar/serie.length + xbar*xbar*svar1; System.out.println(\u0026#34;R^2 = \u0026#34; + R2); System.out.println(\u0026#34;std error of beta_1 = \u0026#34; + Math.sqrt(svar1)); System.out.println(\u0026#34;std error of beta_0 = \u0026#34; + Math.sqrt(svar0)); svar0 = svar * sumx2 / (serie.length * xxbar); System.out.println(\u0026#34;std error of beta_0 = \u0026#34; + Math.sqrt(svar0)); System.out.println(\u0026#34;SSTO = \u0026#34; + yybar); System.out.println(\u0026#34;SSE = \u0026#34; + rss); System.out.println(\u0026#34;SSR = \u0026#34; + ssr); } public static void main(String[] args) { int[] serie = {100, 22, 55, 10, 5, 66, 71, 8, 91}; SerieTemporelle serieTemporelle = new SerieTemporelle(serie); serieTemporelle.calculerRegressionLineaire(); } } À l'aide du polymorphisme paramétrique (les templates), veuillez modifier le code afin de permettre des séries temporelles de plusieurs classes (ex. Double, Integer, etc.).\nRéponse SerieTemporelle.java public class SerieTemporelle\u0026lt;T\u0026gt; { T[] serie; public SerieTemporelle(T[] serie) { this.serie = serie; } public void calculerRegressionLineaire() { int MAXN = 1000; double[] x = new double[MAXN]; double[] y = new double[MAXN]; // first pass: read in data, compute xbar and ybar double sumx = 0.0, sumy = 0.0, sumx2 = 0.0; for(int i = 0; i \u0026lt; serie.length; i\u0026#43;\u0026#43;) { x[i] = i; y[i] = Double.parseDouble(serie[i].toString()); sumx \u0026#43;= x[i]; sumx2 \u0026#43;= x[i] * x[i]; sumy \u0026#43;= y[i]; } double xbar = sumx / serie.length; double ybar = sumy / serie.length; // second pass: compute summary statistics double xxbar = 0.0, yybar = 0.0, xybar = 0.0; for (int i = 0; i \u0026lt; serie.length; i\u0026#43;\u0026#43;) { xxbar \u0026#43;= (x[i] - xbar) * (x[i] - xbar); yybar \u0026#43;= (y[i] - ybar) * (y[i] - ybar); xybar \u0026#43;= (x[i] - xbar) * (y[i] - ybar); } double beta1 = xybar / xxbar; double beta0 = ybar - beta1 * xbar; // print results System.out.println(\u0026#34;y = \u0026#34; \u0026#43; beta1 \u0026#43; \u0026#34; * x \u0026#43; \u0026#34; \u0026#43; beta0); // analyze results int df = serie.length - 2; double rss = 0.0; // residual sum of squares double ssr = 0.0; // regression sum of squares for (int i = 0; i \u0026lt; serie.length; i\u0026#43;\u0026#43;) { double fit = beta1*x[i] \u0026#43; beta0; rss \u0026#43;= (fit - y[i]) * (fit - y[i]); ssr \u0026#43;= (fit - ybar) * (fit - ybar); } double R2 = ssr / yybar; double svar = rss / df; double svar1 = svar / xxbar; double svar0 = svar/serie.length \u0026#43; xbar*xbar*svar1; System.out.println(\u0026#34;R^2 = \u0026#34; \u0026#43; R2); System.out.println(\u0026#34;std error of beta_1 = \u0026#34; \u0026#43; Math.sqrt(svar1)); System.out.println(\u0026#34;std error of beta_0 = \u0026#34; \u0026#43; Math.sqrt(svar0)); svar0 = svar * sumx2 / (serie.length * xxbar); System.out.println(\u0026#34;std error of beta_0 = \u0026#34; \u0026#43; Math.sqrt(svar0)); System.out.println(\u0026#34;SSTO = \u0026#34; \u0026#43; yybar); System.out.println(\u0026#34;SSE = \u0026#34; \u0026#43; rss); System.out.println(\u0026#34;SSR = \u0026#34; \u0026#43; ssr); } public static void main(String[] args) { Double[] serie = {100.0,22.0,55.0,10.0,5.0,66.0,71.0,8.0,91.0}; SerieTemporelle serieTemporelle = new SerieTemporelle(serie); serieTemporelle.calculerRegressionLineaire(); } } Exécuter Question 4 # À partir du code suivant, veuillez en extraire une classe supérieure qui sera héritée et deux interfaces :\npublic class VoitureEssence { public boolean isRunning() { return false; } public void addGaz(int litres) { } public double getSpeed() { return 0; } } public class VoitureElectrique { public boolean isRunning() { return false; } public void chargeBattery(int mah) { } public double getSpeed() { return 0; } } Réponse public class Voiture { public boolean isRunning() { return false; } public double getSpeed() { return 0; } } public class VoitureElectrique extends Voiture implements MoteurElectrique { @Override public void chargeBattery(int mah) { } } public class VoitureEssence extends Voiture implements MoteurEssence { @Override public void addGaz(int litres) { } } public interface MoteurElectrique { void chargeBattery(int mah); } public interface MoteurEssence { void addGaz(int litres); } Question 5 # Dans le code ci-dessous, quel est le type de polymorphisme utilisé?\npublic class Classe1 { public void uneMethode(String arg) { } public void uneMethode(StringBuffer arg) { } } Réponse Il s'agit du polymorphisme ad hoc. Question 6 # Dans le code ci-dessous, quel est le type de polymorphisme utilisé?\npublic class Classe1 { public void uneMethode() { } } public class Classe2 extends Classe1 { public void uneMethode() { } public static void main(String[] args) { Classe2 uneClase = new Classe2(); ((Classe1) uneClase).uneMethode(); } } Réponse Il s'agit du polymorphisme par héritage (ou d'héritage). Question 7 # Considérons la classe Point suivante :\npublic class Point { public Point (int abs, int ord) { x = abs; y = ord; } public void deplace (int dx, byte dy) { x += dx; y += dy; } public void deplace (byte dx, int dy) { x += dx; y += dy; } int x, y; } On voit que la classe Point a deux méthodes qui portent le même nom : Quelle technique est mise en œuvre pour y parvenir ici ? Quel est le résultat de la compilation de chacune des deux classes suivantes ? Expliquez chacun de ces résultats. public class Test1 { public static void main (String args[]) { int n=1; byte b=1; Point a = new Point(n,n); a.deplace(b, b); } } public class Test2 { public static void main (String args[]) { int n=1; byte b=1; Point a = new Point(n,n); a.deplace (2*b, b); } } Réponse Il s’agit de la surdéfinition ou surcharge, car les deux méthodes ont des signatures différentes. Test1 génère une erreur de compilation à cause de l’ambiguïté dans le choix de la méthode deplace à appeler. Cette ambiguïté est liée au fait que chacune des deux méthodes peut être appelée, compte tenu des conversions implicites de byte en int. Test2 compile normalement, l’ambiguïté soulignée ci-dessus est levée par le fait que 2*b force d’office la conversion du premier paramètre réel en int, et donc c’est la méthode déplace (int dx, byte dy) qui est appelée. Question 8 # On suppose qu’il existe une classe A dotée d’un constructeur par défaut.\nSoient les trois instructions suivantes :\nA a = new A(); Object o = new Object(); o=a; A l’issue de ces trois instructions, on a :\ndeux variables de même type et contenant les mêmes références ; deux variables de type différent contenant les mêmes références ; deux variables de même type contenant des références différentes ; rien de tout cela car une erreur est générée. Réponse Bonne réponse : 2. Question 9 # On dispose d’une interface I mettant en œuvre plusieurs méthodes. Soit\ninterface I { void methode1(); void methode2(); void methode3(); void methode4(); } On voudrait faire partager cette interface par deux classes ClasseA et ClasseB pouvant être regroupées dans une classe de base ClasseDeBase et partageant au moins une méthode (methodeDifferee) présente dans cette classe de base mais non encore définie. De plus, ClasseA ne doit implémenter que methode1 et methode2 de I, alors que ClasseB doit implémenter methode3 et methode4 de I.\nUn programmeur songe à la solution suivante :\nabstract class ClasseDeBase { abstract public void methodeDifferee(); } public class ClasseA extends ClasseDeBase implements I { public void methodeDifferee() { System.out.print(\u0026#34;instructions de la méthode différée ici\u0026#34;); } void methode1() { System.out.print(\u0026#34;instructions de méthode1 ici\u0026#34;); } void methode2() { System.out.print(\u0026#34;instructions de méthode2 ici\u0026#34;); } } public class ClasseB extends ClasseDeBase implements I { public void methodeDifferee() { System.out.print(\u0026#34;instructions de la méthode différée ici\u0026#34;); } void methode3() { System.out.print(\u0026#34;instructions de méthode3 ici\u0026#34;); } void methode4() { System.out.print(\u0026#34;instructions de méthode4 ici\u0026#34;); } } Réponse Le problème avec la solution est que chacune des classes ClasseA et ClasseB doit impérativement implémenter toutes les méthodes de l’interface I, et pas seulement certaines.\nUne solution c’est de faire implémenter l’interface plutôt par la classe abstraite ClasseDeBase. C’est-à-dire :\nabstract class ClasseDeBase implements I { abstract public void methodeDifferee(); void methode1() { System.out.print(\u0026#34;instructions même à redéfinir plus tard de méthode1 ici\u0026#34;); } void methode2() { System.out.print(\u0026#34;instructions même à redéfinir plus tard de méthode2 ici\u0026#34;); } void methode3() { System.out.print(\u0026#34;instructions même à redéfinir plus tard de méthode3 ici\u0026#34;); } void methode4() { System.out.print(\u0026#34;instructions même à redéfinir plus tard de méthode4 ici\u0026#34;); } } public class ClasseA extends ClasseDeBase { public void methodeDifferee() { System.out.print(\u0026#34;instructions de la méthode différée ici\u0026#34;); } void methode1() { System.out.print(\u0026#34;instructions de méthode1 ici\u0026#34;); } void methode2() { System.out.print(\u0026#34;instructions de méthode2 ici\u0026#34;); } } public class ClasseB extends ClasseDeBase { public void methodeDifferee() { System.out.print(\u0026#34;instructions de la méthode différée ici\u0026#34;); } void methode3() { System.out.print(\u0026#34;instructions de méthode3 ici\u0026#34;); } void methode4() { System.out.print(\u0026#34;instructions de méthode4 ici\u0026#34;); } } Question 10 # On dispose de différentes classes d’animaux (Poissons, Reptiles, Oiseaux, Mammifères) qui partagent en commun la méthode seDeplace. On voudrait effectuer un traitement qui consiste juste pour chaque animal d’une classe à afficher comment il se déplace. Ainsi, pour un Poisson p, p.seDeplace doit afficher « je suis un poisson, je nage » ; un Reptile « je suis un reptile, je rampe » ; un Oiseau « je suis un oiseau, je vole » ; un Mammifère « je suis un mammifère, je marche, je vole et je nage ». Proposer une solution en utilisant un seul tableau d’objets.\nRéponse public class Main { public static void main(String[] args) { Animaux[] tableau = new Animaux[4]; tableau[0] = new Oiseaux(); tableau[1] = new Poissons(); tableau[2] = new Reptiles(); tableau[3] = new Mammiferes(); for(int i=0; i\u0026lt;tableau.length;i++) { tableau[i].seDeplace(); } }} abstract class Animaux { abstract void seDeplace(); } class Oiseaux extends Animaux { void seDeplace() { System.out.println(\u0026#34;je suis un oiseau, je vole\u0026#34;); } } class Poissons extends Animaux { void seDeplace() { System.out.println(\u0026#34;je suis un poisson, je nage\u0026#34;); } } class Reptiles extends Animaux { void seDeplace() { System.out.println(\u0026#34;je suis un reptile, je rampe\u0026#34;); } } class Mammiferes extends Animaux { void seDeplace() { System.out.println(\u0026#34;je suis un mammifère, je nage, je vole ou je marche\u0026#34;); } } Question 11 # Expliquez la différence entre l’héritage simple et l’implémentation d’interfaces en Java.\nRéponse L’héritage simple permet à une classe de dériver d’une seule classe parente, héritant de ses méthodes et attributs. L’implémentation d’interfaces permet à une classe d’adopter plusieurs comportements en implémentant plusieurs interfaces, ce qui contourne l’absence d’héritage multiple en Java.\nQuestion 12 # Écrivez une interface Java nommée Volant avec une méthode void voler(), puis une classe Oiseau qui implémente cette interface.\nRéponse interface Volant { void voler(); } class Oiseau implements Volant { public void voler() { System.out.println(\u0026#34;L’oiseau vole.\u0026#34;); } } Question 13 # Expliquez la différence entre la redéfinition (override) et la surcharge (overload) de méthodes en Java.\nRéponse La redéfinition (override) consiste à fournir une nouvelle version d’une méthode héritée dans une sous-classe, avec la même signature. La surcharge (overload) consiste à définir plusieurs méthodes du même nom dans une même classe, mais avec des paramètres différents.\nQuestion 14 # Écrivez une classe Personne avec un attribut nom et une méthode afficherNom(). Créez une sous-classe Etudiant qui ajoute un attribut matricule et redéfinit la méthode afficherNom() pour afficher le nom et le matricule.\nRéponse class Personne { String nom; Personne(String nom) { this.nom = nom; } void afficherNom() { System.out.println(nom); } } class Etudiant extends Personne { String matricule; Etudiant(String nom, String matricule) { super(nom); this.matricule = matricule; } void afficherNom() { System.out.println(nom + \u0026#34; (\u0026#34; + matricule + \u0026#34;)\u0026#34;); } } Question 15 # Écrivez une classe Java Animal avec une méthode parler() qui affiche \"Je suis un animal\". Créez deux sous-classes Chien et Chat qui redéfinissent la méthode parler() pour afficher respectivement \"Wouf\" et \"Miaou\".\nRéponse class Animal { void parler() { System.out.println(\u0026#34;Je suis un animal\u0026#34;); } } class Chien extends Animal { void parler() { System.out.println(\u0026#34;Wouf\u0026#34;); } } class Chat extends Animal { void parler() { System.out.println(\u0026#34;Miaou\u0026#34;); } } Question 16 # Expliquez à quoi sert l’interface Serializable en Java et donnez un exemple de situation où il est nécessaire de l’utiliser.\nRéponse L’interface Serializable en Java permet de marquer une classe dont les objets peuvent être sérialisés, c’est-à-dire convertis en un flux d’octets pour être facilement stockés ou transmis. Par exemple, il est nécessaire de l’utiliser lors de la sauvegarde de l’état d’un objet dans un fichier ou lors de l’envoi d’un objet à travers un réseau.\nQuestion 17 # Écrivez un exemple de classe Java qui implémente l’interface Comparable pour permettre le tri naturel d’objets selon un attribut.\nRéponse import java.util.*; class Etudiant implements Comparable\u0026lt;Etudiant\u0026gt; { String nom; int note; Etudiant(String nom, int note) { this.nom = nom; this.note = note; } public int compareTo(Etudiant autre) { return Integer.compare(this.note, autre.note); } public String toString() { return nom + \u0026#34;: \u0026#34; + note; } public static void main(String[] args) { List\u0026lt;Etudiant\u0026gt; liste = new ArrayList\u0026lt;\u0026gt;(); liste.add(new Etudiant(\u0026#34;Alice\u0026#34;, 85)); liste.add(new Etudiant(\u0026#34;Bob\u0026#34;, 70)); liste.add(new Etudiant(\u0026#34;Charlie\u0026#34;, 95)); Collections.sort(liste); for (Etudiant e : liste) { System.out.println(e); } } } Question 18 # Quelle est la différence entre Comparable et Comparator en Java ? Donnez un exemple d’utilisation de Comparator pour trier une liste d’objets selon un critère différent du tri naturel.\nRéponse L’interface Comparable impose un ordre naturel à une classe d’objets en définissant la méthode compareTo(), tandis que l’interface Comparator permet de définir des ordres de tri alternatifs à l’aide de la méthode compare(). Voici un exemple d’utilisation de Comparator :\nimport java.util.*; class Etudiant { String nom; int note; Etudiant(String nom, int note) { this.nom = nom; this.note = note; } public String toString() { return nom + \u0026#34;: \u0026#34; + note; } public static void main(String[] args) { List\u0026lt;Etudiant\u0026gt; liste = new ArrayList\u0026lt;\u0026gt;(); liste.add(new Etudiant(\u0026#34;Alice\u0026#34;, 85)); liste.add(new Etudiant(\u0026#34;Bob\u0026#34;, 70)); liste.add(new Etudiant(\u0026#34;Charlie\u0026#34;, 95)); // Tri par ordre alphabétique Collections.sort(liste, new Comparator\u0026lt;Etudiant\u0026gt;() { public int compare(Etudiant e1, Etudiant e2) { return e1.nom.compareTo(e2.nom); } }); for (Etudiant e : liste) { System.out.println(e); } } } Question 19 # Donnez un exemple d’instanciation anonyme d’une interface Comparator en Java.\nRéponse // Exemple d\u0026#39;instanciation anonyme d\u0026#39;un Comparator pour trier une liste d\u0026#39;entiers par ordre décroissant List\u0026lt;Integer\u0026gt; liste = Arrays.asList(5, 2, 9, 1); Collections.sort(liste, new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer a, Integer b) { return b - a; // ordre décroissant } }); System.out.println(liste); // Affiche [9, 5, 2, 1] Ici, on crée une instance anonyme de l\u0026rsquo;interface Comparator directement dans l\u0026rsquo;appel à Collections.sort, sans créer de classe séparée.\nQuestion 20 # Pourquoi est-il utile d’utiliser des classes anonymes ou des expressions lambda pour implémenter des interfaces fonctionnelles en Java ? Donnez un exemple de cas où cela simplifie le code.\nRéponse Les classes anonymes et les expressions lambda permettent d’implémenter des interfaces fonctionnelles de manière concise et sans avoir à créer une classe nommée séparée. Cela simplifie le code, surtout pour des implémentations ponctuelles. Par exemple :\nimport java.util.*; public class Exemple { public static void main(String[] args) { List\u0026lt;String\u0026gt; liste = Arrays.asList(\u0026#34;un\u0026#34;, \u0026#34;deux\u0026#34;, \u0026#34;trois\u0026#34;, \u0026#34;quatre\u0026#34;); // Tri avec une expression lambda Collections.sort(liste, (a, b) -\u0026gt; b.compareTo(a)); liste.forEach(element -\u0026gt; System.out.println(element)); } } Question 21 # Expliquez le principe de substitution de Liskov (Liskov Substitution Principle, LSP) en programmation orientée objet. Donnez un exemple simple en Java illustrant une violation de ce principe.\nRéponse Le principe de substitution de Liskov stipule que toute classe dérivée doit pouvoir être utilisée à la place de sa classe parente sans altérer le bon fonctionnement du programme. Autrement dit, les objets d’une sous-classe doivent pouvoir remplacer les objets de la superclasse sans que le code client ait à se soucier des différences.\nExemple de violation :\nclass Rectangle { protected int largeur, hauteur; public void setLargeur(int l) { largeur = l; } public void setHauteur(int h) { hauteur = h; } public int getAire() { return largeur * hauteur; } } class Carre extends Rectangle { @Override public void setLargeur(int l) { largeur = hauteur = l; } @Override public void setHauteur(int h) { largeur = hauteur = h; } } // Utilisation Rectangle r = new Carre(); r.setLargeur(5); r.setHauteur(10); System.out.println(r.getAire()); // Affiche 100, mais on s’attendrait à 50 pour un rectangle Ici, la classe Carre (carré) viole le principe de substitution de Liskov car elle modifie le comportement attendu de la classe Rectangle : un carré impose que la largeur et la hauteur soient toujours égales, ce qui n’est pas le cas d’un rectangle. Le code client utilisant un Rectangle ne peut plus raisonner correctement si on lui passe un Carre.\nQuestion 22 # Expliquez comment l’utilisation d’une interface peut simplifier le code en Java. Donnez un exemple concret où l’interface permet d’écrire du code plus flexible et réutilisable.\nRéponse L’utilisation d’une interface permet de définir un contrat commun à plusieurs classes, sans imposer d’héritage d’implémentation. Cela favorise la flexibilité, la réutilisation et le découplage du code. Grâce aux interfaces, on peut écrire des méthodes ou des classes qui manipulent des objets de types différents, à condition qu’ils respectent le même contrat (interface).\nExemple :\ninterface Affichable { void afficher(); } class Personne implements Affichable { public void afficher() { System.out.println(\u0026#34;Je suis une personne.\u0026#34;); } } class Voiture implements Affichable { public void afficher() { System.out.println(\u0026#34;Je suis une voiture.\u0026#34;); } } // Méthode générique void afficherTout(Affichable[] objets) { for (Affichable obj : objets) { obj.afficher(); } } // Utilisation Affichable[] tab = { new Personne(), new Voiture() }; afficherTout(tab); Ici, la méthode afficherTout peut traiter n’importe quel objet qui implémente l’interface Affichable, ce qui rend le code plus générique, flexible et facile à étendre.\nQuestion 23 # Expliquez la différence entre l’opérateur == et la méthode equals() en Java. Donnez un exemple où l’utilisation de l’un ou de l’autre change le résultat.\nRéponse L’opérateur `==` compare les références (adresses mémoire) pour les objets, tandis que la méthode `equals()` compare le contenu (la valeur logique) si elle est redéfinie. Pour les types primitifs, `==` compare directement les valeurs.\nExemple :\nPoint p1 = new Point(1, 2); Point p2 = new Point(1, 2); System.out.println(p1 == p2); // false (références différentes) System.out.println(p1.equals(p2)); // true (contenu identique) Question 24 # Qu’est-ce que la méthode hashCode() ? Pourquoi est-il important de la redéfinir lorsqu’on redéfinit equals() ?\nRéponse La méthode `hashCode()` retourne un entier représentant le code de hachage d’un objet. Elle est utilisée dans les structures de données comme `HashMap` ou `HashSet` pour organiser et retrouver rapidement les objets. Si deux objets sont égaux selon `equals()`, ils doivent obligatoirement avoir le même `hashCode()`. Sinon, les collections basées sur le hachage ne fonctionneront pas correctement.\nQuestion 25 # Peut-on utiliser les méthodes equals() et hashCode() avec des types primitifs comme int ou double ? Expliquez pourquoi.\nRéponse Non, les types primitifs (`int`, `double`, etc.) ne sont pas des objets et ne possèdent donc pas de méthodes comme `equals()` ou `hashCode()`. Ces méthodes existent uniquement pour les objets. Pour comparer des valeurs primitives, on utilise directement les opérateurs (`==`, `!=`, etc.). Si on veut utiliser des méthodes comme `equals()` ou `hashCode()` avec des valeurs numériques, il faut utiliser les classes enveloppes (`Integer`, `Double`, etc.).\nQuestion 26 # Qu’est-ce qu’un record en Java ? Expliquez ses avantages et donnez un exemple d’utilisation.\nRéponse Un record est un type spécial de classe introduit en Java 16 pour représenter des données immuables de façon concise. Un record déclare automatiquement les champs, le constructeur, les méthodes `equals()`, `hashCode()` et `toString()`, ce qui simplifie la création de classes « porteuses de données » (data classes). Les records sont particulièrement utiles pour les objets dont l’identité est définie uniquement par leurs valeurs, comme les points, coordonnées, ou résultats de calculs.\nExemple :\nrecord Point(int x, int y) {} Point p1 = new Point(1, 2); Point p2 = new Point(1, 2); System.out.println(p1.equals(p2)); // true System.out.println(p1); // Point[x=1, y=2] Ici, il n’est pas nécessaire d’écrire le constructeur ou de redéfinir `equals()` et `hashCode()` : tout est généré automatiquement par le compilateur.\nQuestion 27 # Comment peut-on transformer un tableau d’entiers en une liste d’entiers en utilisant les streams ?\nRéponse On peut utiliser Arrays.stream() et boxed() pour convertir un tableau primitif en stream d’objets, puis collecter dans une liste :\nint[] tab = {1, 2, 3}; List\u0026lt;Integer\u0026gt; l = Arrays.stream(tab).boxed().collect(Collectors.toList()); "},{"id":20,"href":"/inf1220-hugo/docs/modules/module4/exercices-4-1/","title":"Exercices sur les flux","section":"Module 4: Les entrées et sorties","content":" Exercices sur les flux # Questions/Réponses Veuillez répondre mentalement, sur papier ou bien en créant le code nécessaire pour répondre à ces questions avant de regarder la réponse.\nSi vous ne faites pas honnêtement les exercices et les lectures dans ce cours, il est possible que vous n'arriviez pas alors à faire les travaux notés et les examens.\nPrenez note qu'il est permis d'utiliser le robot conversationnel du cours lors des exercises. Cependant vous devriez vous entraîner à produire vos propres réponses.\nRéponses uniques? Les exercices comportent une solution vous permettant de comparer votre approche avec la nôtre. Il n'y a pas de solution unique aux problèmes en général. Vous pouvez arriver avec une solution qui est préférable ou moins bonne que celle que nous offrons. Pour faire ces questions, vous devez avoir fait toutes les lectures préalables. Vous disposez alors toujours des fondements nécessaires pour faire les exercices. Nous vous encourageons tout de même à faire vos propres recherches en complément de vos lectures. Dans certains cas, au sein de la solution que nous offrons, nous pouvons utiliser des notions techniques qui n'ont pas été vues directement dans le cours, mais qui devraient vous être facilement accessibles.\nQuestion 1 Le programme suivant permet-il de lire deux lignes entrées au clavier ?\nimport java.util.Scanner; class TestIn { public static void main(String[] args) { Scanner scanner = new Scanner (System.in); System.out.println(\u0026#34;==\u0026gt; Taper deux lignes\u0026#34;); System.out.print(\u0026#34;?\u0026#34;); String ligne1 = scanner.nextLine(); System.out.print(\u0026#34;?\u0026#34;); String ligne2 = scanner.nextLine(); System.out.println(\u0026#34;==\u0026gt; Les deux lignes lues sont:\\n==\u0026gt; \u0026#34; + ligne1 + \u0026#34;\\n==\u0026gt; \u0026#34; + ligne2); } } Réponse Oui, la classe Scanner avec en paramètre l'entrée de la console, permet de lire des entrées au clavier. Le code fait la lecture de deux lignes de données au clavier.\nNotez qu'on évite délibérément d'appeler scanner.close() puisque cela aurait pour conséquence la fermeture de System.in ce qui n'est généralement pas souhaitable. La ressource System.in est automatiquement fermée à la fin du programme dans tous les cas, il n'est donc pas nécessaire de s'en préoccuper.\nQuestion 2 Que fait ce programme ?\nimport java.io.*; import java.util.*; class TestFichOut { public static void main(String[] args) { File fichier = new File(\u0026#34;Lasortie.txt\u0026#34;); try ( FileOutputStream streamFich = new FileOutputStream(fichier); DataOutputStream d = new DataOutputStream(streamFich); PrintStream out = new PrintStream(d); Scanner sc = new Scanner(System.in); ) { String ligne = \u0026#34;\u0026#34;; System.out.println(\u0026#34;==\u0026gt; Taper des lignes terminées par ctrl-D\u0026#34;); System.out.print(\u0026#34;?\u0026#34;); while(sc.hasNextLine()) { out.println(\u0026#34;\u0026#34; + sc.nextLine()); System.out.print(\u0026#34;?\u0026#34;); } System.out.println(); } catch (java.io.IOException e) { System.out.println(\u0026#34;Il y a une erreur de lecture ou écriture\u0026#34;); } finally {} } } Réponse Il prend chaque ligne saisie par l'utilisateur et il l'écrit dans un fichier. Par ailleurs, notez que la variable ligne est inutilisée.\nQuestion 3 En supposant que vous avez les droits d’écriture et de lecture appropriés, créez un fichier séquentiel binaire (monFichier) dans un répertoire (monRepertoire) sur la racine. On suppose que le fichier et le répertoire n’existent pas déjà. Ecrire dans ce fichier les nombres entiers de 0 à 9.\nRéponse import java.io.*; import java.nio.file.*; public class Exercice1M4{ public static void main(String args[]) throws IOException { String s = File.separator; File monRepertoire = new File(s + \u0026#34;monRepertoire\u0026#34;); if (monRepertoire.mkdirs()) { System.out.println(\u0026#34;*** répertoire créé correctement***\u0026#34;); File monFichier = new File(monRepertoire, \u0026#34;monFichier\u0026#34;); if (monFichier.createNewFile()) { System.out.println(\u0026#34;***fichier créé correctement***\u0026#34;); DataOutputStream sortie = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(monFichier))); for (int i = 0; i \u0026lt; 10; i++) { sortie.writeInt(i); } sortie.close(); } else { System.out.println(\u0026#34;***le fichier n\u0026#39;a pas été créé***\u0026#34;); } } else{ System.out.println(\u0026#34;*** le répertoire n\u0026#39;a pas été créé**}\u0026#34;); } } } Question 4 Ecrire un programme qui affiche le contenu du fichier de l’exercice précédent, puis ajoute à ce fichier le double des entiers impairs de 0 à 9. Les noms de répertoire et de fichier devront être fournis par l’utilisateur qui les saisira au clavier.\nRéponse import java.io.*; import java.nio.file.*; import java.util.Scanner; public class Exercice2M4 { public static void main(String[] args) throws IOException { String nomFichier, nomRepertoire; String s = File.separator; int n = 0; Scanner scanner = new Scanner(System.in); System.out.print(\u0026#34;donnez le nom du répertoire à lire : \u0026#34;); nomRepertoire = scanner.next(); File monRepertoire = new File(s + nomRepertoire); if (monRepertoire.exists() \u0026amp;\u0026amp; monRepertoire.isDirectory()) { scanner = new Scanner(System.in); // intentionellement, nous n\u0026#39;appelerons pas scanner.close afin de ne pas // fermer System.in inutilement. System.out.println(\u0026#34;***ce répertoire existe***\u0026#34;); System.out.print(\u0026#34;donnez le nom du fichier à traiter : \u0026#34;); nomFichier = scanner.next(); File monFichier = new File(monRepertoire, nomFichier); if (monFichier.exists()) { System.out.println(\u0026#34;*** ce fichier existe et voici son contenu***\u0026#34;); DataInputStream entree = new DataInputStream(new BufferedInputStream(new FileInputStream(monFichier))); boolean eof = false; while (!eof) { try { n = entree.readInt(); } catch (EOFException e) { eof = true; } if (!eof) System.out.println(n); } entree.close(); DataOutputStream sortie = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(monFichier, true))); for (int i = 0; i \u0026lt; 10; i++) { if (i % 2 \u0026gt;= 1) { sortie.writeInt(2 * i); } } sortie.close(); } else { System.out.println(\u0026#34;***ce fichier n\u0026#39;existe pas***\u0026#34;); } } else { System.out.println(\u0026#34;*** ce répertoire n\u0026#39;existe pas***\u0026#34;); } } } Question 5 En poursuivant avec le même exemple que les deux exercices précédents, écrire un programme qui affiche le contenu du fichier, puis modifie ce fichier en remplaçant les nombres entiers impairs par leur double. Les noms de répertoire et de fichier devront être fournis par l’utilisateur qui les saisira au clavier.\nQuelle est la différence entre cet exercice et l’exercice précédent du point de vue des types d’accès et des possibilités qui y sont liées?\nRéponse import java.io.*; import java.nio.file.*; import java.util.Scanner; public class Exercice3M4 // Exercice3M4 { public static void main(String args[]) throws IOException { String nomFichier, nomRepertoire, s = File.separator; int n = 0; Scanner scanner = new Scanner(System.in); System.out.print(\u0026#34;donnez le nom du répertoire à lire : \u0026#34;); nomRepertoire = scanner.next(); File monRepertoire = new File(s + nomRepertoire); if (monRepertoire.exists() \u0026amp;\u0026amp; monRepertoire.isDirectory()) { scanner = new Scanner(System.in); System.out.println(\u0026#34;***ce répertoire existe***\u0026#34;); System.out.print(\u0026#34;donnez le nom du fichier à traiter : \u0026#34;); nomFichier = scanner.next(); File monFichier = new File(monRepertoire, nomFichier); if (monFichier.exists()) { System.out.println(\u0026#34;*** ce fichier existe et voici son contenu***\u0026#34;); DataInputStream entree = new DataInputStream(new BufferedInputStream(new FileInputStream(monFichier))); boolean eof = false; while (!eof) { try { n = entree.readInt(); } catch (EOFException e) { eof = true; } if (!eof) System.out.println(n); } entree.close(); System.out.println(\u0026#34;***il va maintenant être modifié si necessaire*** \u0026#34;); // DataOutputStream sortie = new DataOutputStream(newBufferedOutputStream(new // FileOutputStream(monFichier, true)); RandomAccessFile sortie = new RandomAccessFile(s + nomRepertoire + s + nomFichier, \u0026#34;rw\u0026#34;); long taille = sortie.length(); int i = 0; do { sortie.seek(4 * i); n = sortie.readInt(); if (n % 2 \u0026gt;= 1) { sortie.seek(4 * i); sortie.writeInt(2 * n); System.out.println(taille + \u0026#34; l\u0026#39;ancienne valeur de n est: \u0026#34; + n + \u0026#34; et la nouvelle valeur de n est: \u0026#34; + 2 * n); } i = i + 1; } while (i * 4 \u0026lt; taille); sortie.close(); } else { System.out.println(\u0026#34;***ce fichier n\u0026#39;existe pas***\u0026#34;); } } else { System.out.println(\u0026#34;*** ce répertoire n\u0026#39;existe pas***\u0026#34;); } } } La différence réside en ceci que l’accès direct nous facilite la mise à jour du fichier. Si nous devrions faire cette mise à jour lors d’un accès séquentiel, ce serait extrêmement laborieux (une solution consistant à utiliser un flux de sortie et un flux d’entrée en même temps). Il ne faut pas confondre cette mise à jour des données déjà présentes dans le fichier avec l’ajout de nouveaux éléments dans le même fichier tel que ce qui est fait à l’exercice précédent par exemple.\nQuestion 6 Créez un fichier texte nommé unFichier dans le répertoire courant et écrivez-y « Bonjour, je suis bien créé ». Ce nom sera fourni par l’utilisateur sous forme chaîne « unFichier.txt ».\nRéponse import java.io.*; import java.util.Scanner; public class Exercice4M4 { //Exercice4M4 public static void main(String args[]) throws IOException { String nomFichier; Scanner scanner = new Scanner(System.in); System.out.print(\u0026#34;Donnez le nom du fichier a creer avec son extension .txt: \u0026#34;); nomFichier = scanner.next(); PrintWriter sortie = new PrintWriter(new BufferedWriter(new FileWriter(nomFichier))); sortie.println(\u0026#34; Bonjour, je suis bien créé \u0026#34;); sortie.close(); System.out.println(\u0026#34;*** le fichier \u0026#34; + nomFichier + \u0026#34; a été bien créé \u0026#34; + \u0026#34;***\u0026#34;); } } Question 7 Ecrire un code qui prend en paramètre le nom du fichier de l’exercice précédent (unFichier.txt), et affiche son chemin d’accès (c’est-à-dire le répertoire courant) ainsi que le contenu du fichier.\nOn suppose dans cet exercice qu’on reste dans le même répertoire courant qu’à l'exercice précédent.\nRéponse import java.io.*; import java.util.Scanner; public class Exercice5M4 { // Exercice5M4 public static void main(String args[]) throws IOException { String nomFichier, ligne; Scanner scanner = new Scanner(System.in); System.out.print(\u0026#34;Donnez le nom du fichier : \u0026#34;); nomFichier = scanner.next(); try (BufferedReader entree = new BufferedReader(new FileReader(nomFichier));) { System.out.println(\u0026#34;*** voici le contenu du fichier qui est situé dans le répertoire***\\n \u0026#34; + System.getProperty(\u0026#34;user.dir\u0026#34;) + \u0026#34;\\n \u0026#34;); do { ligne = entree.readLine(); if (ligne != null) System.out.println(ligne); } while (ligne != null); entree.close(); System.out.println(\u0026#34;\\n\u0026#34; + \u0026#34;*** fin du contenu ***\u0026#34;); } catch (java.io.IOException e) { System.out.println(\u0026#34;le fichier n\u0026#39;existe pas\u0026#34;); } finally { } } } Question 8 # Écrivez un programme Java qui compte le nombre de voyelles dans une chaîne de caractères saisie par l’utilisateur.\nRéponse import java.util.Scanner; public class CompteVoyelles { public static void main(String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); int compteur = 0; for (char c : s.toLowerCase().toCharArray()) { if (\u0026#34;aeiouy\u0026#34;.indexOf(c) != -1) compteur++; } System.out.println(\u0026#34;Nombre de voyelles : \u0026#34; + compteur); } } Question 9 # Écrivez un programme Java qui lit un fichier texte ligne par ligne et affiche chaque ligne précédée de son numéro (exemple : 1: première ligne, 2: deuxième ligne, etc.).\nRéponse import java.io.*; public class LireFichier { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(\u0026#34;monfichier.txt\u0026#34;)); String ligne; int num = 1; while ((ligne = br.readLine()) != null) { System.out.println(num + \u0026#34;: \u0026#34; + ligne); num++; } br.close(); } } Question 10 # Écrivez un programme Java qui demande à l’utilisateur un nom de fichier, puis affiche le nombre de caractères dans ce fichier.\nRéponse Il est possible de procéder caractère par caractère :\nimport java.io.*; import java.util.Scanner; public class CompteCaracteres { public static void main(String[] args) throws IOException { Scanner sc = new Scanner(System.in); System.out.print(\u0026#34;Nom du fichier : \u0026#34;); String nom = sc.nextLine(); FileReader fr = new FileReader(nom); int compteur = 0; while (fr.read() != -1) compteur++; fr.close(); System.out.println(\u0026#34;Nombre de caractères : \u0026#34; + compteur); } } Il est possible de procéder plus rapidement :\nimport java.nio.file.Files; import java.nio.file.Paths; import java.io.IOException; public class FileSize { public static void main(String[] args) throws IOException { String filePath = \u0026#34;monfichier.txt\u0026#34;; long size = Files.size(Paths.get(filePath)); System.out.println(\u0026#34;Nombre de caractères : \u0026#34; + size); } } Question 11 Le code suivant lit un fichier texte ligne par ligne et concatène toutes les lignes dans une seule chaîne :\nimport java.io.*; String resultat = \u0026#34;\u0026#34;; BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;fichier.txt\u0026#34;)); String ligne; while ((ligne = reader.readLine()) != null) { resultat = resultat + ligne; } reader.close(); Réécrivez ce code de façon plus performante. Expliquez pourquoi votre version est préférable.\nRéponse On peut utiliser un StringBuilder pour éviter de créer de nombreuses chaînes intermédiaires, ce qui améliore l’efficacité (temps et mémoire) :\nimport java.io.*; StringBuilder resultat = new StringBuilder(); BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;fichier.txt\u0026#34;)); String ligne; while ((ligne = reader.readLine()) != null) { resultat.append(ligne); } reader.close(); Avec StringBuilder, on évite la création répétée de nouvelles chaînes à chaque itération, ce qui rend le code beaucoup plus rapide et économe en mémoire, surtout pour de gros fichiers.\nQuestion Y Le code suivant lit un fichier caractère par caractère sans utiliser de buffer :\nimport java.io.*; FileReader reader = new FileReader(\u0026#34;fichier.txt\u0026#34;); int c; while ((c = reader.read()) != -1) { // Traitement du caractère c } reader.close(); Expliquez pourquoi ce code peut être lent pour de gros fichiers. Proposez une version optimisée utilisant un buffer, et expliquez pourquoi elle est préférable.\nRéponse Lire caractère par caractère sans buffer entraîne de nombreux accès disque, ce qui ralentit la lecture. Utiliser un BufferedReader permet de lire des blocs de caractères en mémoire, ce qui accélère le traitement :\nimport java.io.*; BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;fichier.txt\u0026#34;)); int c; while ((c = reader.read()) != -1) { // Traitement du caractère c } reader.close(); Le BufferedReader réduit le nombre d’appels au système en lisant de grands blocs à la fois, ce qui améliore nettement la performance, surtout pour les gros fichiers.\n"},{"id":21,"href":"/inf1220-hugo/docs/modules/module2/typeoperateur/","title":"Introduction aux types de base et à leurs opérateurs","section":"Module 2: Introduction au langage Java","content":" Introduction aux types de base et à leurs opérateurs # Mise en garde pédagogique # Si on prend un cours de Mandarin, on ne s'attend pas à comprendre tout le Mandarin lu ou écouté du premier coup ou même du deuxième. Il en va de même lorsqu'on étudie un langage de programmation, surtout s'il s'agit du premier langage de programmation appris. La première fois, la seconde fois, ou même la troisième fois que vous verrez un bout de code, il est parfaitement normal de ne pas le comprendre entièrement. C'est d'autant plus vrai que le langage Java a un syntaxe plutôt lourde avec beaucoup de mots réservés à la signification abstraite. Vous verrez beaucoup de mots comme \"class\", \"public\", \"static\", \"void\" dans ce cours. Si ça vous semble être du jargon, c'est parce que c'est exactement ce dont il s'agit. Monter un programme en Java n'est pas chose aisée, il faut comprendre que les \"classes\" vont dans des fichiers avec un nom correspondant à la classe, il faut comprendre que seule la méthode \"public static void main(String[])\" est exécutable, etc., etc. Il est impossible d'absorber tout ça en un jour, en une semaine ou même en quelques courtes semaines. Ça prend du temps avant de s'y retrouver.\nEt c'est pire que vous pouvez peut-être l'imaginer. Même après avoir fait du Java pendant 30 années, on ne comprend pas tout. La grammaire, la syntaxe, est lourde, complexe, nuancée. C'est pire encore avec certains langages comme C++ que peu de gens au monde maîtrisent entièrement. Et même quand on comprend la syntaxe, comprendre ce que fait le code n'est pas toujours évident. Ce n'est pas parce qu'on connaît la grammaire française qu'on sait lire tous les textes en français.\nC'est là que l'intérêt du concept de pseudo-code prend tout son sens. Au coeur de la programmation, on trouve l'écriture d'algorithmes, et un algorithme existe indépendamment du langage de programmation. Le pseudo-code l'illustre parfaitement.\nIl n'est donc pas nécessaire, pour programmer, de tout savoir et de tout comprendre. Vous ne terminerez pas le cours INF 1220 avec une maîtrise intégrale du Java. Plusieurs aspects resteront mystérieux à vos yeux. C'est normal.\nUtilisez donc l'approche suivante. Quand vous rencontrez un nouveau code Java, ne le prenez pas dans son ensemble tout d'un coup. Faites comme vous le feriez en français : lisez une ligne à la fois. N'insistez pas pour tout comprendre. Développez une intuition pour les variables, les méthodes, etc. Allez-y par étape ! Prenez votre temps ! Prenez des notes. Il en va de même quand vous écrivez du code. Commencez par le plus simple, et progressez lentement, en prenant des notes, en vous laissant des commentaires. Souvent il est utile d'écrire le pseudo-code avant d'écrire le code en Java.\nLe modèle pédagogique est donc fondé sur la répétition et pars du principe que la première fois que nous rencontrons une notion, celle-ci nous échappe au moins partiellement. Ce n\u0026rsquo;est qu\u0026rsquo;en revenant plusieurs fois sur les mêmes idées que nous pouvons vraiment maîtriser une notion. Sur le site web du cours, nous revenons plusieurs fois sur les mêmes concepts, mais de manières de manières différentes. Par ailleurs, nous vous demandons de lire nombre de manuel où les choses sont expliquées et présentées différemment. Nous offrons aussi des vidéos où vous trouverez d\u0026rsquo;autres explications. Par ailleurs, nous vous demandons de faire de nombreux exercices, à la fois dans le manuel et sur le site web du cours.\nEnvironnement de développement (rappel) # Si vous devez compiler des classes Java sur votre PC, faites les choses simplement. Essayez d'utiliser les outils les plus élémentaires. Concentrez-vous sur le Java, et non pas sur les environnements et les outils. Une erreur fréquente des débutants est de perdre beaucoup de temps au sein de systèmes qu'ils ne maîtrisent pas à essayer de programmer dans un langage qu'ils ne maîtrisent pas. Il y faut y aller pas à pas.\nLes variables et les types # Une variable permet de manipuler des données et des valeurs. Elle se caractérise par un nom et un type. Le nom sert à repérer un emplacement mémoire dans lequel la valeur de la variable sera stockée. Quant au type, il permet de déterminer la façon dont la valeur de la variable est traduite en code binaire, ainsi que la taille de son emplacement mémoire. Par exemple, le type \"int\" permet de stocker une valeur numérique de type entière (ex. 1, 3, 33, 56, etc.). Une variable peut également stocker en mémoire l'instance d'un objet, par exemple une chaîne de caractères avec une instance de la classe \"String\" (ex. String exemple = \"Exemple\";). Voici un exemple de déclaration et assignation d'une valeur à une variable dans une classe :\nExemple1.java public class Exemple1 { public static void main(String[] args) { // Création d\u0026#39;une variable de type int int entier = 33; // Création d\u0026#39;une variable de type booléenne boolean test = false; } } Exécuter Il est important d'utiliser les guillemets droits (ASCII) \" pour délimiter les chaînes de caractères. Certains environnements (comme le site Web du cours INF 1220 ou Microsoft Word) peuvent parfois convertir automatiquement les guillemets droits en guillemets à la française (« »). En tant que programmeur, c'est à vous de faire la correction lorsque vous recopiez le code informatique.\nLes noms des variables # Dans la déclaration des noms des variables, il est fortement conseillé d'utiliser des noms indicatifs. Il s'agit donc d'utiliser le nom qui évoque le mieux l'information stockée. Les contraintes suivantes sont à respecter dans l'écriture des noms de variables :\nLe premier caractère d'une variable ne doit pas être un chiffre. Aucun espace ne peut être présent dans le nom. Un nom de variable qui contient une lettre majuscule est différent du même nom écrit en minuscule. Les caractères suivants : \u0026amp;, {, }, [, ], #, %, \\, ï, ¤, !, /, @,^, =, ', \u0026lt;, \u0026gt;, ; et , ne peuvent être utilisés dans l'écriture d'un nom de variable. Il est possible d'utiliser des caractères accentués (éù) ou même des caractères asiatiques or arabes. La norme de programmation veut que l'on commence une variable par une minuscule. S'il est nécessaire de décrire celle-ci avec plusieurs mots, nous vous suggérer d'utiliser une transition minuscule-majuscule pour séparer les mots. Exemple : \"uneAutreVariable\", \"entierResultatMultiplication\", etc. Le nombre de lettres composant le nom d'une variable est indéfini. Néanmoins, l'objectif principal d'un nom de variable est de renseigner le programmeur sur son contenu.\nLa notion de type # Lors de l'écriture d'un programme, le programmeur doit définir les variables. C'est ainsi que le programmeur explique à l'ordinateur la nature de chaque donnée. Cette explication passe par la notion de type. Le type d'une valeur permet de déterminer la nature de l'information stockée dans une variable. À chaque type sont associés les éléments suivants :\nUn code spécifique permettant de traduire l'information en binaire et réciproquement. Un ensemble d'opérations réalisables en fonction du type de variable utilisé; il est possible de diviser deux variables du type numérique alors qu'il est impossible de diviser deux variables de type caractère. Un intervalle de valeurs possibles qui dépendent du codage utilisé. Donc, à chaque type de variable correspond un nombre d'octets, et par conséquent, un nombre limité de valeurs différentes. En effet, un octet est un regroupement de 8 bits, et un bit ne peut être qu'un 0 ou un 1. Une donnée codée sur un octet peut prendre 256 valeurs. Les types de base en Java # Comme la plupart des langages de programmation, Java propose des types de base permettant la manipulation de valeurs numériques entières ou de caractères. En principe, comme le Java est un langage OO, tous les éléments devraient être des objets (ex. String, Serializer, HashMap, etc.). Or, à la création du langage, les concepteurs ont décidé de créer des types \"non-objet\" afin de faciliter l'usage et réduire la complexité pour les types de base. Ces types sont donc représentés par des mots-clés, prédéfinis par le langage. Ils sont également dits simples, car à un instant donné, ces types de variables ne peuvent contenir qu'une seule valeur. Le tableau ci-dessous représente les différents types en Java.\nType Désignation Domaine Constantes Opérations entiers byte (8 bits)\nshort (16 bits)\nint (32 bits)\nlong (64 bits) -128 à 127\n-32768 à 32767\n-2147483648 à 2147483647\n-9223372036854775808 à 9223372036854775807 323 (décimale)\n0xF2 (hexadécimale)\n0777 (octale)\n323l (long) unaire : +, -\nbinaire : +, -, *, /, % réels float (simple précision, 32 bits)\ndouble (double précision, 64 bits) ±3.40282346638528860e+38\n±1.40129846432481707e-45\n±1.79769313486231570e+308\n±4.94065645841246544e-324 2.f, .32f, 2.33f, 2e4f, 2.e4f, .3e4f\n2., .32, 2.33, 2e4, 2.e4, .3e4 unaire : +, -\nbinaire : +, -, *, / caractère char codage Unicode (valeurs entières sur 16 bits) \u0026lsquo;a\u0026rsquo;, \u0026lsquo;A\u0026rsquo;, \u0026lsquo;\\n\u0026rsquo; (retour à la ligne), \u0026lsquo;\\t\u0026rsquo; (tabulation) booléen boolean true, false true, false \u0026amp;\u0026amp; (et logique), || (ou logique), ! (négation) N.B. Les chaînes de caractères ne correspondent pas à un type de données mais à une classe; ceci signifie qu'une chaîne de caractère est un objet possédant des attributs et des méthodes. Une chaîne peut donc être déclarée de la façon suivante :\nString s = \u0026#34;Chaîne de caractères\u0026#34;; Dans ce cours, il n'est pas nécessaire de devenir un expert dans les types du Java. Vous devez tout de même avoir les bases:\nIl y a plusieurs types pour représenter les entiers (byte, short, int, long) utilisant une quantité variable de mémoire, et pouvant représenter des nombres plus ou moins volumineux. À l'exception du type « char » qui peut être considéré comme un type représentant des entiers (de 0 à 65536), les types entiers en Java sont toujours signés (ils permettent de représenter à la fois les nombres positifs et négatifs). Notez qu'il y a toujours une valeur négative de plus grande amplitude que n'importe quelle valeur positive (par exemple, -128, -32768, -2147483648, etc.) ce qui signifie qu'on ne peut toujours prendre la valeur absolue d'un entier en Java dans le sens où, par exemple, la valeur 2147483648 ne peut pas être représentée par un « int » alors que -2147483648 est parfaitement légitime. Les types entiers n'ont qu'une seule valeur zéro. Les nombres à virgule flottantes ont deux zéros (-0 et +0). Nous avons que les valeurs zéros sont égales (+0 == -0). Par contre, les deux zéros sont distincts: 1/-0 donne l'infini négatif (1/-0.0 == Double.NEGATIVE_INFINITY) alors que 1/+0 donne l'infini positif (1/0.0 == Double.POSITIF_INFINITY). En informatique, on définit l'ensemble des nombres positifs comme étant les nombres plus grands que zéro. Les nombres négatifs sont les nombres plus petits que zéro. En Java, la fonction Math.signum retourne -1, 0 ou 1 selon que le nombre est négatif, nul ou positif. En Java, on ne peut pas représenter les valeurs réelles. On utilise plutôt des nombres à virgule flottante. Ainsi donc, on peut utiliser des « double » pour consacrer 64 bits afin de représenter des nombres. On utilise alors la norme « binary64 » qui accorde 53 bits à la mantisse d'une représentation binaire. En d'autres mots, on peut pratiquement représenter n'importe quel nombre de la forme m x 2p tant que m n'excède pas 253. En particulier, le type « double » en Java peut représenter tous les entiers (positifs et négatifs) qui n'excèdent pas une magnitude de 253. Quand un nombre ne peut pas être être représenté, Java va trouver le nombre à virgule flottante le plus proche. Si jamais nous arrivons exactement entre deux nombres à virgule flottante, comme c'est le cas avec le nombre 9000000000000002.5, Java va choisir le nombre le plus proche qui a une mantisse paire (ici 9000000000000002). Débordements # Les types ont des limites qu'il faut connaître. En 2021, on pouvait lire ceci dans les journaux:\nLe cours de l’action Berkshire Hathaway Inc de Warren Buffett est passé à plus de 400 000 $ par action de catégorie A. Mais l’impressionnante course de 41 ans de l’action pourrait bientôt s’arrêter brutalement si la bourse américaine Nasdaq ne met pas à niveau ses systèmes informatiques bientôt, a rapporté le Wall Street Journal. La raison en est que le cours de l’action Berkshire Hathaway est très proche du nombre le plus élevé que les ordinateurs du Nasdaq peuvent gérer. Le Nasdaq et quelques autres opérateurs du marché utilisent des systèmes 32 bits pour stocker les données en nombres binaires, qui comprennent des uns et des zéros. Par conséquent, le plus grand nombre possible est de deux à la 32e puissance moins un, soit 4 294 967 295. Les cours des actions sont généralement affichés jusqu’à quatre décimales, de sorte que le prix le plus élevé possible est de 429 496,7295 $, selon le rapport du WSJ. Pour représenter les entiers signés, la méthode du complément à deux est couramment utilisée. Dans ce système, le bit le plus significatif (à gauche) indique le signe : 0 pour un nombre positif ou nul, 1 pour un nombre négatif. Pour obtenir la représentation d’un nombre négatif, on prend la représentation binaire de sa valeur absolue, on inverse tous les bits (complément à un), puis on ajoute 1. Par exemple, pour représenter -5 avec 8 bits : la valeur absolue 5 s’écrit 00000101 ; son complément à un est 11111010 ; en ajoutant 1, on obtient 11111011, qui représente -5. Ce système permet une gestion cohérente des nombres positifs et négatifs dans les calculs.\nLes débordements se produisent lorsqu’une opération arithmétique sur des entiers dépasse la capacité du type de données utilisé. Par exemple, pour un type int (32 bits) en Java, les valeurs sont comprises entre -2³¹ et 2³¹-1. Si l’addition de deux grands nombres dépasse 2³¹-1, le résultat \u0026ldquo;déborde\u0026rdquo; et revient vers les valeurs négatives, ou inversement pour une soustraction. En Java, les débordements ne déclenchent pas d’exception ; ils sont gérés silencieusement par un comportement de \u0026ldquo;retour circulaire\u0026rdquo; (wrap-around). Par exemple, si l’on additionne Integer.MAX_VALUE (2³¹-1) et 1, le résultat sera Integer.MIN_VALUE (-2³¹). Pour détecter ou éviter les débordements, Java propose des méthodes comme Math.addExact(int, int), qui lance une ArithmeticException en cas de débordement, ou l’utilisation de types plus grands comme long ou BigInteger pour des calculs nécessitant une plage plus large.\nEn Java, les types numériques pour les entiers sont soit signés, soit non signés. Les types signés, qui utilisent le complément à deux pour représenter les nombres négatifs, sont : byte (8 bits), short (16 bits), int (32 bits) et long (64 bits). Le type char (16 bits), bien qu’utilisé principalement pour les caractères, est non signé, représentant des valeurs de 0 à 65 535.\nPour mieux comprendre les débordements, essayez d\u0026rsquo;en créer un avec l\u0026rsquo;application suivante. Créez un débordement vers une valeur positive puis vers une valeur négative.\nError: Code file not found at static/webapps/debordement.html\nBinaire, décimal, hexadécimal # La représentation binaire, décimale et hexadécimale des entiers permet d’exprimer des nombres dans différents systèmes de numération. En binaire (base 2), un entier est représenté par une séquence de 0 et de 1, où chaque position correspond à une puissance de 2. Par exemple, le nombre 13 s’écrit 1101 en binaire, car 1×2³ + 1×2² + 0×2¹ + 1×2⁰ = 8 + 4 + 0 + 1 = 13. En décimal (base 10), les chiffres de 0 à 9 sont utilisés, et chaque position représente une puissance de 10 ; ainsi, 13 s’écrit simplement 13. En hexadécimal (base 16), les chiffres vont de 0 à 9, complétés par les lettres A à F (où A = 10, B = 11, \u0026hellip;, F = 15), et chaque position correspond à une puissance de 16. Le nombre 13 s’écrit D en hexadécimal, car D représente 13 en base 16. L\u0026rsquo;avantage de l\u0026rsquo;hexadécimal est qu\u0026rsquo;il correspond plus directement à la représentation en mémoire. Chaque chiffre (0, 1, \u0026hellip;, 9, A, \u0026hellip;, F) correspond à 4 bits. On peut toujours représenter un char (16-bits) en utilisant exactement 4 chiffres.\nPour distinguer les notations hexadécimales, binaires et décimales, nous utilisons sont un préfixe: 0x pour hexadécimal et 0b pour binaire. L\u0026rsquo;expression Java int x = 0b1101; définit la valeur 13 en décimal. L\u0026rsquo;expression int x = 0x1101; représente plutôt le nombre 4353. Nous pouvons obtenir la repésentation binaire d\u0026rsquo;un nombre en Java avec un expression comme Integer.toBinaryString(x) et la représentation hexadécimale avec Integer.toHexString(x). Voici un exemple.\nNumberRepresentation.java public class NumberRepresentation { public static void main(String[] args) { int number = 42; // Binary representation String binary = Integer.toBinaryString(number); // Decimal representation String decimal = String.valueOf(number); // Hexadecimal representation String hexadecimal = Integer.toHexString(number); System.out.println(\u0026#34;Number: \u0026#34; \u0026#43; number); System.out.println(\u0026#34;Binary: \u0026#34; \u0026#43; binary); System.out.println(\u0026#34;Decimal: \u0026#34; \u0026#43; decimal); System.out.println(\u0026#34;Hexadecimal: \u0026#34; \u0026#43; hexadecimal); } } Exécuter Utilisez l\u0026rsquo;application suivante pour explorer les notations binaires, hexadécimales et décimales. Vos nombres doivent être non-négatifs.\nHex (0x) Décimal Binaire Trouvez le plus grand entier qui ne nécessite que deux chiffres en notation hexadécimale.\nMot-clé var # En Java, le mot-clé var permet de déclarer des variables locales avec une inférence de type, introduite dans Java 10. Il simplifie le code en évitant de spécifier explicitement le type d\u0026rsquo;une variable lorsque celui-ci peut être déduit par le compilateur à partir de l\u0026rsquo;expression d\u0026rsquo;initialisation. Cela améliore la lisibilité, surtout pour les types complexes comme les collections ou les classes génériques, tout en maintenant la sûreté du typage statique. Cependant, var ne peut être utilisé que pour des variables locales dans des blocs de code, comme les méthodes ou les blocs d\u0026rsquo;initialisation, et nécessite une initialisation immédiate. Il ne peut pas être utilisé pour les champs de classe, les paramètres de méthode ou les types de retour. De plus, son usage doit rester clair pour éviter de nuire à la compréhension du code.\nVarExample.java import java.util.ArrayList; public class VarExample { public static void main(String[] args) { var message = \u0026#34;Bonjour, Java!\u0026#34;; var numbers = new ArrayList\u0026lt;Integer\u0026gt;(); numbers.add(42); System.out.println(message); System.out.println(\u0026#34;Premier élément: \u0026#34; \u0026#43; numbers.get(0)); } } Exécuter Les types Record # En Java, les records, introduits dans Java 14 comme fonctionnalité expérimentale et finalisés dans Java 16, permettent de définir des classes immuables de manière concise pour représenter des données. Un record déclare automatiquement des champs privés finaux, un constructeur, et tous les autres champs requis réduisant ainsi le code répétitif. Ils sont idéaux pour les objets de transfert de données (DTO) ou les structures de données simples. Les records ne peuvent pas être modifiés après leur création, et leurs champs doivent être initialisés via le constructeur généré.\nRecordExample.java import java.util.ArrayList; public class RecordExample { public static void main(String[] args) { var personne = new Personne(\u0026#34;Alice\u0026#34;, 30); var listePersonnes = new ArrayList\u0026lt;Personne\u0026gt;(); listePersonnes.add(personne); System.out.println(personne); System.out.println(\u0026#34;Première personne: \u0026#34; \u0026#43; listePersonnes.get(0).nom()); } } record Personne(String nom, int age) {} Exécuter Les blocs de texte # Les blocs de texte (text blocks) en Java, introduits avec Java 15 , permettent de définir des chaînes de caractères multilignes de manière plus lisible et concise. Ils sont particulièrement utiles pour représenter des chaînes complexes comme du JSON, du HTML, du SQL ou tout autre contenu textuel nécessitant des retours à la ligne, sans avoir à utiliser des concaténations ou des caractères d\u0026rsquo;échappement.\nTextBlockExample.java public class TextBlockExample { public static void main(String[] args) { // Requête SQL avec un bloc de texte String sqlQuery = \u0026#34;\u0026#34;\u0026#34; SELECT id, nom, email FROM utilisateurs WHERE actif = true ORDER BY nom; \u0026#34;\u0026#34;\u0026#34;; System.out.println(\u0026#34;Requête SQL :\\n\u0026#34; \u0026#43; sqlQuery); // JSON avec un bloc de texte et formatage String nom = \u0026#34;Alice\u0026#34;; int age = 30; String json = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;nom\u0026#34;: \u0026#34;%s\u0026#34;, \u0026#34;age\u0026#34;: %d, \u0026#34;actif\u0026#34;: true } \u0026#34;\u0026#34;\u0026#34;.formatted(nom, age); System.out.println(\u0026#34;JSON :\\n\u0026#34; \u0026#43; json); } } Exécuter Les nombres à virgule flottante # Le standard IEEE 754 définit une représentation binaire pour les nombres à virgule flottante, largement utilisé dans les ordinateurs modernes. Un nombre à virgule flottante est structuré en trois parties : le signe, l\u0026rsquo;exposant et la mantisse. Par exemple, en simple précision (32 bits), 1 bit est alloué au signe (\\( s \\)), 8 bits à l\u0026rsquo;exposant (\\( e \\)) et 23 bits à la mantisse (\\( m \\)). Le nombre est exprimé par la formule suivante :\n\\[ (-1)^s \\times 1.m \\times 2^{e - \\text{bias}} \\]où \\( \\text{bias} = 127 \\) pour la simple précision. Le bit de signe détermine si le nombre est positif (\\( s = 0 \\)) ou négatif (\\( s = 1 \\)), l\u0026rsquo;exposant est stocké avec un décalage (bias) pour représenter des nombres très grands ou très petits, et la mantisse représente les chiffres significatifs normalisés (avec un 1 implicite pour les nombres normalisés).\nLes types IEEE 754 existent en plusieurs formats, notamment la simple précision (32 bits) et la double précision (64 bits, avec 1 bit de signe, 11 bits d\u0026rsquo;exposant et 52 bits de mantisse). La précision est limitée par la taille de la mantisse, ce qui entraîne des erreurs d\u0026rsquo;arrondi pour les calculs nécessitant une grande précision. Par exemple, en simple précision, la plus petite valeur non nulle (nombre dénormalisé) est de l\u0026rsquo;ordre de \\( 2^{-126} \\), et la plus grande valeur est environ \\( 2^{128} \\). Les nombres dénormalisés, utilisés lorsque l\u0026rsquo;exposant est minimal, permettent de représenter des valeurs très proches de zéro, mais avec une précision réduite :\n\\[ (-1)^s \\times 0.m \\times 2^{-126} \\]Cependant, des phénomènes comme la perte de précision (par exemple, lors de soustractions de nombres proches) ou les erreurs d\u0026rsquo;arrondi peuvent affecter les calculs.\nLe standard IEEE 754 gère également des cas spéciaux comme l\u0026rsquo;infini, les NaN (Not a Number) et les nombres dénormalisés. Par exemple, un exposant de \\( e = 255 \\) (tous les bits à 1) avec une mantisse nulle représente \\( \\pm \\infty \\), tandis qu\u0026rsquo;une mantisse non nulle indique un NaN. Ces cas sont essentiels pour gérer les erreurs mathématiques, comme la division par zéro. Le standard garantit une portabilité et une cohérence des calculs à virgule flottante sur différentes architectures, ce qui est crucial pour les applications scientifiques, les simulations numériques et les algorithmes d\u0026rsquo;apprentissage automatique, où la précision et la stabilité numérique sont critiques.\nLecture optionnelle dans le livre de référence (Delannoy) # Pour aller plus en profondeur sur les types (optionnel), vous pouvez lire dans Programmer en Java de Claude Delannoy, Chapitre 3:\nSection 1 : La notion de type Section 2 : Les types Entier Section 3 : Les types flottants Section 4 : Le type caractère Section 5 : Le type booléen Vidéos suggérées # La déclaration d\u0026rsquo;une variable dans une fonction. # La déclaration de la variable se fait de la même manière, quel que soit le type de donnée utilisé. Au cours de cette opération, le programmeur attribue le type et le nom de la variable. Pour déclarer une variable, il suffit d'écrire l'instruction selon la syntaxe suivante : Type nomdelavariable; ou type nomdelavariable1, nomdelavariable2; où le type représente un des types définis au tableau précédent.\nQuand plusieurs variables sont de même type, il faut les séparer par une virgule (,) (par contre, la norme ne recommande pas cette façon de déclarer les variables). Pour expliquer à l'ordinateur que l'instruction de déclaration est terminée pour le type donné, un point virgule (;) est placé obligatoirement à la fin de la ligne d'instruction.\nMain.java public class Main { // Exemple de déclaration de variable de fonctions public static void main(String[] args) { String messageDeBienvenue = \u0026#34;Bienvenue à INF1220\u0026#34;; String ajout = \u0026#34; de la TELUQ\u0026#34;; int a,b,c; a = 3; b = 4; c = a \u0026#43; b; System.out.println(messageDeBienvenue \u0026#43; ajout); } } Exécuter Les opérateurs de base # Les opérateurs sont des symboles qui agissent sur des valeurs ou des variables. Ils permettent d'effectuer des opérations arithmétiques, de comparaison, logiques, etc. Les opérateurs sont très nombreux dans le langage Java. Nous allons nous limiter ici aux opérateurs de base.\nLes opérateurs arithmétiques # Les opérateurs arithmétiques permettent d'effectuer des opérations mathématiques de base.\nOpérateur Signification Exemple + Addition 5 + 3 = 8 - Soustraction 5 - 3 = 2 * Multiplication 5 * 3 = 15 / Division 5 / 3 = 1.666\u0026hellip; % Modulo (reste de la division) 5 % 3 = 2 Les opérateurs de comparaison # Les opérateurs de comparaison permettent de comparer des valeurs entre elles. Ils retournent généralement un booléen (vrai ou faux).\nOpérateur Signification Exemple == Égal à 5 == 3 est faux != Différent de 5 != 3 est vrai \u0026gt; Plus grand que 5 \u0026gt; 3 est vrai \u0026lt; Plus petit que 5 \u0026lt; 3 est faux \u0026gt;= Plus grand ou égal à 5 \u0026gt;= 3 est vrai \u0026lt;= Plus petit ou égal à 5 \u0026lt;= 3 est faux Les opérateurs logiques # Les opérateurs logiques permettent de combiner des expressions booléennes.\nOpérateur Signification Exemple \u0026amp;\u0026amp; Et logique (5 \u0026gt; 3) \u0026amp;\u0026amp; (8 \u0026gt; 5) est vrai || Ou logique (5 \u0026gt; 3) ! Négation !(5 \u0026gt; 3) est faux Les opérateurs d\u0026rsquo;affectation # Les opérateurs d'affectation permettent d'assigner des valeurs à des variables.\nOpérateur Signification Exemple = Affectation simple int a = 5; += Affectation par addition a += 3; // a = a + 3; -= Affectation par soustraction a -= 2; // a = a - 2; *= Affectation par multiplication a *= 4; // a = a * 4; /= Affectation par division a /= 2; // a = a / 2; %= Affectation par modulo a %= 3; // a = a % 3; Les opérateurs ternaires # L'opérateur ternaire est un opérateur conditionnel qui permet de simplifier l'écriture de certaines expressions.\nOpérateur Signification Exemple ?: Si \u0026hellip; alors \u0026hellip; sinon int a = (b \u0026gt; c) ? b : c; Priorité des opérateurs # Les expressions sont généralement évaluées de la gauche vers la droite, en suivant la priorité des opérations. La priorité des opérateurs détermine l'ordre dans lequel les opérations sont effectuées dans une expression. Par exemple, dans l'expression 3 + 5 * 2, la multiplication est effectuée avant l'addition en raison de la priorité des opérateurs.\nVoici un tableau résumant la priorité des opérateurs que nous avons vus :\nNiveau Opérateurs Exemple 1 ++ \u0026ndash; a++ + ++a 2 * / % a * b / c 3 + - a + b - c 4 \u0026amp;\u0026amp; a \u0026amp;\u0026amp; b 5 || a 6 ?: a ? b : c 7 = += -= *= /= %= a = b + c Dans le cas où il s\u0026rsquo;agit de l\u0026rsquo;évaluation d\u0026rsquo;une valeur booléenne, Java évalue l\u0026rsquo;expression de manière paresseuse, en faisant le moins de travail possible. Il peut donc omettre l\u0026rsquo;évaluation d\u0026rsquo;une partie de l\u0026rsquo;expression. Par exemple, dans l\u0026rsquo;expresson true || a, Java va passer outre à l\u0026rsquo;évaluation de l\u0026rsquo;expression a puisque la réponse est nécessairement vraie.\nUtilisez l\u0026rsquo;application pour voir si vous avez compris.\nCalculateur de priorité des opérateurs Sélectionner ou entrer une expression Choisir un exemple... a + b * c (a + b) * c x - y / z ++ x / (y - z) p * q -- + r a % b + c - d x ++ * y / z -- (A + B) * (C - D) / E Calculer la priorité Exemple # Assurez-vous de bien comprendre cet exemple.\nMain.java public class Main { public static void main(String[] args) { // Déclaration de variables avec noms descriptifs int nombreEntier = 42; double nombreFlottant = 3.14159; boolean estPositif = nombreFlottant \u0026gt; 0; String messageResultat = \u0026#34;Résultat des calculs : \u0026#34;; // Opérations arithmétiques int somme = nombreEntier \u0026#43; 10; double produit = nombreFlottant * 2.0; int resteDivision = nombreEntier % 5; // Opérations de comparaison et logique boolean estGrand = nombreEntier \u0026gt; 40 \u0026\u0026 somme \u0026lt;= 100; boolean conditionOu = nombreEntier \u0026lt; 50 || !estPositif; // Opérateur ternaire pour déterminer le message String descriptionNombre = (nombreEntier % 2 == 0) ? \u0026#34;pair\u0026#34; : \u0026#34;impair\u0026#34;; // Démonstration des zéros distincts et infinis (IEEE 754) double zeroPositif = 0.0; double zeroNegatif = -0.0; boolean zerosEgaux = (zeroPositif == zeroNegatif); // true double infiniPositif = 1.0 / zeroPositif; // \u0026#43;Infini double infiniNegatif = 1.0 / zeroNegatif; // -Infini // Affichage des résultats System.out.println(messageResultat); System.out.println(\u0026#34;Nombre entier : \u0026#34; \u0026#43; nombreEntier \u0026#43; \u0026#34; est \u0026#34; \u0026#43; descriptionNombre); System.out.println(\u0026#34;Somme : \u0026#34; \u0026#43; somme \u0026#43; \u0026#34;, Produit : \u0026#34; \u0026#43; produit \u0026#43; \u0026#34;, Reste : \u0026#34; \u0026#43; resteDivision); System.out.println(\u0026#34;Est grand et dans la limite : \u0026#34; \u0026#43; estGrand); System.out.println(\u0026#34;Condition OU : \u0026#34; \u0026#43; conditionOu); System.out.println(\u0026#34;Zéros égaux (\u0026#43;0.0 == -0.0) : \u0026#34; \u0026#43; zerosEgaux); System.out.println(\u0026#34;1.0/\u0026#43;0.0 = \u0026#34; \u0026#43; infiniPositif); System.out.println(\u0026#34;1.0/-0.0 = \u0026#34; \u0026#43; infiniNegatif); } } Exécuter Les classes enveloppes des types primitifs # Les classes enveloppes (ou « wrapper classes ») permettent de manipuler les types primitifs (int, double, boolean, etc.) comme des objets. Chaque type primitif possède une classe enveloppe correspondante : Integer pour int, Double pour double, Boolean pour boolean, etc.\nExemples d’utilisation :\n// Création d’un Integer à partir d’un int int a = 5; Integer objA = Integer.valueOf(a); // Conversion automatique (autoboxing) Integer objB = 10; // Java convertit automatiquement int -\u0026gt; Integer // Récupérer la valeur primitive (unboxing) int b = objB; // Java convertit automatiquement Integer -\u0026gt; int // Méthodes utilitaires String s = \u0026#34;123\u0026#34;; int n = Integer.parseInt(s); // Convertit une chaîne en int System.out.println(n + 1); // Affiche 124 Les classes enveloppes sont notamment utiles pour bénéficier de méthodes utilitaires (parsing, conversion, etc.). Par exemple, les classes enveloppes fournissent des méthodes pratiques pour :\nConvertir une chaîne de caractères en valeur numérique (parsing) Convertir une valeur numérique en chaîne de caractères Comparer des valeurs Obtenir des constantes utiles (valeurs maximales, minimales, etc.) Exemples :\n// Parsing : convertir une chaîne en int String s = \u0026#34;123\u0026#34;; int n = Integer.parseInt(s); // n vaut 123 // Conversion inverse : int vers String int x = 42; String str = Integer.toString(x); // str vaut \u0026#34;42\u0026#34; // Comparaison int a = 5, b = 8; int res = Integer.compare(a, b); // renvoie -1 car a \u0026lt; b // Constantes utiles int max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; System.out.println(\u0026#34;int max : \u0026#34; + max + \u0026#34;, int min : \u0026#34; + min); Ces méthodes facilitent la manipulation et la conversion des données dans vos programmes Java.\nElles peuvent représenter une valeur, mais une fois cette valeur assignée, elle peut pas être modifiée. Par exemple :\nInteger a = 5; a = a + 1; // Cela crée un nouvel objet Integer, l’ancien n’est pas modifié System.out.println(a); // Affiche 6 Ici, l’objet Integer initial contenant 5 n’est pas modifié : l’opération crée un nouvel objet contenant 6, et la variable a pointe vers ce nouvel objet. Les classes enveloppes sont donc immuables : leur valeur ne peut pas être changée après création.\nPour comparer la valeur de deux objets issus de classes enveloppes (comme Integer, Double, etc.), il ne faut pas utiliser l’opérateur ==, qui compare les références (adresses en mémoire), mais la méthode equals(), qui compare le contenu (la valeur).\nExemple :\nInteger a = new Integer(5); Integer b = new Integer(5); System.out.println(a == b); // false (références différentes) System.out.println(a.equals(b)); // true (valeurs identiques) Dans cet exemple, a == b est faux car ce sont deux objets distincts, mais a.equals(b) est vrai car ils contiennent la même valeur. Nous reviendrons sur les classes enveloppes dans les autres modules du cours.\nString et operateur \u0026lsquo;+\u0026rsquo; # En Java, le type String représente une séquence de caractères. Les objets String sont immuables : une fois créés, ils ne peuvent pas être modifiés. Toute opération qui semble modifier une chaîne (comme la concaténation) crée en réalité un nouvel objet String.\nL’opérateur + permet de concaténer des chaînes facilement :\nString s1 = \u0026#34;Bonjour\u0026#34;; String s2 = \u0026#34; le monde\u0026#34;; String s3 = s1 + s2; // s3 vaut \u0026#34;Bonjour le monde\u0026#34; Attention : pour comparer le contenu de deux chaînes, il ne faut pas utiliser == (qui compare les références), mais la méthode equals() :\nEn Java, une référence est comme une « adresse » qui indique où un objet est stocké en mémoire. Quand on écrit a == b pour deux objets (ici, des chaînes), on demande si a et b pointent exactement vers le même objet, c’est-à-dire la même case mémoire. Deux chaînes différentes, même si elles contiennent le même texte, peuvent être stockées à des endroits différents en mémoire. Ainsi, == ne vérifie pas si le contenu des chaînes est identique, mais seulement si c’est le même objet. Pour vérifier que deux chaînes ont le même texte caractère par caractère, il faut utiliser equals(), qui compare le contenu des objets.\nString a = \u0026#34;Java\u0026#34;; String b = new String(\u0026#34;Java\u0026#34;); System.out.println(a == b); // false (références différentes) System.out.println(a.equals(b)); // true (contenu identique) Pour tester si une chaîne commence ou se termine par un certain texte, on peut utiliser startsWith() et endsWith() :\nString phrase = \u0026#34;Bonjour le monde\u0026#34;; System.out.println(phrase.startsWith(\u0026#34;Bon\u0026#34;)); // true System.out.println(phrase.endsWith(\u0026#34;monde\u0026#34;)); // true Il existe aussi d’autres méthodes utiles comme substring() (extraire une sous-chaîne), toUpperCase(), toLowerCase(), length(), etc.\nOn peut aussi concaténer une chaîne avec une valeur entière, un double ou tout autre type : Java convertit automatiquement la valeur en chaîne de caractères avant de faire la concaténation. Cela permet d’afficher facilement des résultats ou de construire dynamiquement des messages.\nExemples :\nint age = 25; String message = \u0026#34;J\u0026#39;ai \u0026#34; + age + \u0026#34; ans.\u0026#34;; // \u0026#34;J\u0026#39;ai 25 ans.\u0026#34; double prix = 19.99; String ticket = \u0026#34;Prix : \u0026#34; + prix + \u0026#34; €\u0026#34;; // \u0026#34;Prix : 19.99 €\u0026#34; boolean ok = true; String etat = \u0026#34;Succès : \u0026#34; + ok; // \u0026#34;Succès : true\u0026#34; Java convertit automatiquement les valeurs non String en chaîne lors de la concaténation avec l’opérateur + de gauche à droite.\nConstantes # En Java, le mot-clé final est utilisé pour déclarer qu\u0026rsquo;une variable, une méthode ou une classe ne peut pas être modifiée ou redéfinie après son initialisation. Lorsqu\u0026rsquo;il est appliqué à une variable, il garantit que sa valeur reste constante une fois qu\u0026rsquo;elle a été assignée. Une variable final doit être initialisée au moment de sa déclaration ou dans un bloc d\u0026rsquo;initialisation (pour les champs d\u0026rsquo;instance) ou un constructeur (pour les champs d\u0026rsquo;instance dans une classe). Si elle n\u0026rsquo;est pas initialisée, le compilateur génère une erreur.\npublic class Exemple { public static final double PI = 3.14159; } Enum # En Java, les enum (abréviations de \u0026ldquo;énumérations\u0026rdquo;) sont des types spéciaux utilisés pour définir un ensemble fixe de constantes nommées. Introduits dans Java 5, ils permettent de représenter des collections de valeurs prédéfinies, comme les jours de la semaine, les états d\u0026rsquo;un système ou des catégories spécifiques. Par exemple, une énumération pour les jours pourrait être déclarée ainsi : enum Jour { LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI, DIMANCHE }. Chaque constante d\u0026rsquo;une enum est en réalité une instance de la classe enum, ce qui signifie qu\u0026rsquo;elles sont immuables et que leur nombre est fixé à la compilation. Les enum offrent une alternative robuste aux constantes statiques de type int ou String, car elles garantissent la sécurité des types et empêchent l\u0026rsquo;utilisation de valeurs non valides.\nGestionCouleurs.java public class GestionCouleurs { // Définition de l\u0026#39;énumération enum Couleur { ROUGE, NOIR, BLEU } // Méthode utilisant l\u0026#39;enum public static String afficherCouleur(Couleur couleur) { return \u0026#34;La couleur sélectionnée est : \u0026#34; \u0026#43; couleur; } // Méthode principale pour tester public static void main(String[] args) { // Test avec différentes couleurs System.out.println(afficherCouleur(Couleur.ROUGE)); System.out.println(afficherCouleur(Couleur.NOIR)); System.out.println(afficherCouleur(Couleur.BLEU)); } } Exécuter Les enums ont plusieurs fonctions avancées. Il est possible d\u0026rsquo;ajouter des attributs aux différentes valeurs, et ainsi de suite. On peut notamment utiliser la méthode values() pour énumérer les enums.\nMain.java enum Jour { LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI, DIMANCHE } public class Main { public static void main(String[] args) { // Utilisation de values() pour obtenir un tableau de toutes les constantes de l\u0026#39;enum for (Jour jour : Jour.values()) { System.out.println(jour); } } } Exécuter La vidéo suivante (optionnelle) vous permettra d\u0026rsquo;en apprendre davantage.\nExercices # Voici quelques exercices pour pratiquer ce que vous venez d'apprendre :\nDéclarez des variables de différents types et assignez-leur des valeurs. Utilisez les opérateurs arithmétiques pour effectuer des calculs sur ces variables. Comparez les variables entre elles en utilisant les opérateurs de comparaison. Utilisez les opérateurs logiques pour combiner des expressions booléennes. Utilisez l'opérateur ternaire pour simplifier une expression conditionnelle. Pratiquez l'affectation de valeurs à des variables en utilisant les opérateurs d'affectation. Références :\nTypes de données (Oracle) Opérateurs (Oracle) "},{"id":22,"href":"/inf1220-hugo/docs/modules/module1/pasapas/","title":"Java pas à pas","section":"Module 1: Algorithme et pseudocode","content":" Java pas à pas # Nous vous invitons maintenant à lire le chapitre suivants Concepts de base (chapitre 1) du manuel Java pas à pas par Robert Godin et Daniel Lemire. Le chapitre comprend plusieurs exemples et exercices. Vous devez compléter les exercices du manuel.\nAprès votre lecture du chapitre, répondez aux questions suivantes.\nDécrivez les principales composantes matérielles d’un ordinateur typique, telles que le processeur, la mémoire centrale et les unités périphériques. Expliquez brièvement le rôle du bus dans la communication entre ces composantes. Expliquez le fonctionnement de base du processeur central (CPU) dans l’exécution d’un programme. Décrivez le cycle de traitement (chercher et exécuter une instruction) et donnez un exemple simple d’instruction que le processeur pourrait exécuter. Quelles sont les caractéristiques principales de la mémoire centrale (RAM) en termes de rapidité et de volatilité ? Expliquez pourquoi un programme doit être chargé dans la mémoire centrale avant son exécution et ce qui se passe en cas d’interruption de courant. Distinguez les périphériques d’entrée, de sortie et d’entrée/sortie. À l’aide d’exemples concrets (comme le clavier, l’écran ou le disque dur), expliquez comment ces périphériques permettent l’échange d’informations entre l’ordinateur et le monde extérieur. Quelle est la différence entre le matériel (hardware) et le logiciel (software) ? Décrivez le rôle du système d’exploitation dans la gestion des ressources d’un ordinateur, en citant un exemple de système d’exploitation mentionné dans le chapitre. Expliquez ce qu’est le langage binaire et pourquoi il est utilisé dans les ordinateurs. À l’aide d’un exemple, montrez comment l’entier décimal 42 est représenté en binaire sur 8 bits, en détaillant le calcul. Décrivez le processus de compilation dans le contexte de la programmation Java. Expliquez pourquoi il est nécessaire de traduire un programme Java en langage machine avant son exécution par le processeur. Expliquez ce qu’est un système de gestion de fichiers et son rôle dans l’organisation des données en mémoire secondaire. À l’aide d’un exemple de chemin de fichier sous Windows (comme C:\\Users\\Robert\\Documents\\HelloWorld.java), décrivez comment un fichier est localisé. Qu’est-ce que le pseudo-parallélisme dans un système monoprocesseur ? Expliquez comment le système d’exploitation crée l’illusion d’une exécution simultanée de plusieurs programmes, et précisez en quoi cela diffère du parallélisme réel dans un système multi-cœur. Plusieurs étudiants trouvent qu\u0026rsquo;il est plus aisé de faire les lectures dans le manuel Java pas à pas après avoir terminé la lecture du module sur notre site web. Vous pouvez choisir quand il vous convient le mieux d\u0026rsquo;utiliser le manuel Java pas à pas.\nVous avez accès au document PDF. Si vous devez lire un document PDF, nous vous encourageons à charger le fichier sur votre machine et à l\u0026rsquo;ouvrir au sein d\u0026rsquo;un outil dédié (par ex. Adobe Acrobat). Il n\u0026rsquo;est pas très pratique de lire un document PDF au sein d\u0026rsquo;un navigateur web.\nVous pouvez aussi acheter la version papier du manuel Java pas à pas chez Amazon:\n"},{"id":23,"href":"/inf1220-hugo/docs/modules/module3/activite-3-2/","title":"Les structures itératives","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" Les structures itératives # Les structures itératives permettent d'itérer un certain nombre de fois, basé sur des variables de contrôle. Elles permettent par exemple de chercher une valeur dans une structure de données (ex. un tableau d'entier), de lire un flux de données caractère par caractère, etc. Elles sont l'implémentation des \"tant que\", des \"pour i de 1 à 10 faire\", etc. Dans le langage Java, il existe trois structures itératives : le while, le for et le do-while.\nLa boucle while # L'instruction while (condition) permet d'exécuter les instructions dans sa portée, tant que la condition est vraie. Les instructions peuvent ne jamais s'exécuter si la condition n'est pas vérifiée dès l'entrée de la boucle.\nMain.java class Main { // Cette méthode imprimera 4 fois le char \u0026#34;*\u0026#34; public static void main(String arg[]) { int i = 1; // Itération tant que i est inférieur ou égal à 4 while (i \u0026lt;= 4) { System.out.print(\u0026#34;*\u0026#34;); i\u0026#43;\u0026#43;; } } } Exécuter Il est possible de terminer une itération, ou la boucle entière, grâce à deux instructions : continue et break. L'instruction continue permet de sauter toutes les instructions qui suivent et revenir au début de la boucle. Ainsi, le programme suivant arrêtera l'itération à i == 3:\nExecutionIteration.java public class ExecutionIteration { public static void main(String arg[]) { int i = 1; // Itération tant que i est inférieur ou égal à 4 while (i \u0026lt;= 4) { if(i==3) { break; } System.out.print(\u0026#34;*\u0026#34;); i\u0026#43;\u0026#43;; } } } Exécuter D'autre part, le mot-clé \"continue\" permet de \"sauter\" une partie de l'exécution du code d'une structure d'itération pour commencer une nouvelle itération. Ainsi, dans le code suivant, les nombres impairs ne seront pas affichés car l'exécution de la ligne System.out ne sera pas atteinte\u0026nbsp;:\nMain.java public class Main { public static void main(String arg[]) { int i = 0; while (i != 4) { i\u0026#43;\u0026#43;; if((i%2) != 0) { continue; } System.out.println(i); } } } Exécuter La boucle for # L'instruction for (initialisation; test_fin; itération) permet de répéter les instructions dans la portée en utilisant plusieurs valeurs pour certaines variables. Ces variables sont déclarées et initialisées dans l'expression init (plusieurs variables peuvent être séparées par des virgules). La fin de l'itération est indiquée par l'expression test_fin. L'expression itération est exécutée au début de chaque nouvelle itération (après la première). Voici un exemple de boucle for en réutilisant l'exemple précédent pour la boucle while :\nExecutionIteration.java public class ExecutionIteration { // affiche 2 et 4 public static void main(String arg[]) { // Itération tant que i est inférieur ou égal à 4 for(int i = 1; i \u0026lt;= 4; i\u0026#43;\u0026#43;) { if((i%2) != 0) { continue; } System.out.println(i); } } } Exécuter Nous n'avons pas encore vu les structures de données de base en programmation (ex. tableau, list, etc.) et le sujet sera abordé un peu plus loin, mais la structure d'itération for permet également de simplifier l'itération dans ce type de structure. Voici un exemple avec une chaîne de caractères :\nMain.java public class Main { public static void main(String arg[]) { String chaine = \u0026#34;veni vidi vici\u0026#34;; int nbVoyelle = 0; for(char c : chaine.toCharArray()) { if(c == \u0026#39;a\u0026#39; || c == \u0026#39;e\u0026#39; || c == \u0026#39;i\u0026#39; || c == \u0026#39;o\u0026#39; || c == \u0026#39;u\u0026#39; || c == \u0026#39;y\u0026#39; ) { nbVoyelle\u0026#43;\u0026#43;; } } System.out.println(nbVoyelle); } } Exécuter La boucle do-while # La boucle do-while est similaire à la boucle while, à la différence que le contrôle de valeurs se fait à la fin de l'itération du corps de la structure. Le do-while peut donc être utilisé à d'autres fins. Voici un exemple :\nExecutionIteration.java public class ExecutionIteration { public static void main(String arg[]) { int i = 1; do { System.out.print(\u0026#34;*\u0026#34;); i\u0026#43;\u0026#43;; } while (i \u0026lt;= 4); } } Exécuter Utilisation des structures d\u0026rsquo;itération # Les structures (ou boucles) d'itération sont utiles à plusieurs fins : analyser une suite de données, vérifier l'état d'un capteur, trouver une donnée dans une structure, etc. Il est possible d'imbriquer des boucles (et des structures de contrôle), mais attention à la complexité algorithmique (ex. le temps de calcul), l'espace mémoire généré, etc. Par exemple, supposons que nous voulons dénombrer la quantité d'un nombre entier donné (supposons 4) dans un tableau. Il sera nécessaire de faire une passe complète sur le tableau, donc de lire N données pour tableau d'une longueur de N. Ce qui correspond à une complexité algorithmique de O(N):\nTrouverEntier.java public class TrouverEntier { final static int NOMBRE_A_TROUVER = 4; public static void main(String[] args) { int nombre = 0; int[] tableau = {2,3,6,2,4,6,8,0,2,2}; for(int i = 0; i \u0026lt; tableau.length; i\u0026#43;\u0026#43;) { if(NOMBRE_A_TROUVER == tableau[i]) { nombre\u0026#43;\u0026#43;; } } System.out.println(\u0026#34;Nombre :\u0026#34; \u0026#43; nombre); } } Exécuter Maintenant, supposons que nous voulons faire la même chose, mais pour chacune des valeurs du tableau. La complexité algorithme devient quadratique, i.e. O(N^2), car nous devons maintenant pour N données, faire N passe dans le tableau. Pour un tableau de 10 données, il s'agit de 100 itérations totales, mais pour un tableau de 1000 données, il s'agit de 1 million d'itérations! : Main.java public class Main { public static void main(String[] args) { int[] nombres = new int[10]; int[] tableau = {2,3,6,2,4,6,8,0,2,2}; for(int i = 0; i \u0026lt; tableau.length; i\u0026#43;\u0026#43;) { for(int j = 0; j \u0026lt; tableau.length; j\u0026#43;\u0026#43;) { if(i != j \u0026\u0026 tableau[i] == tableau[j]) { nombres[i]\u0026#43;\u0026#43;; } } // Pour ajouter le nombre courant. nombres[i]\u0026#43;\u0026#43;; } for(int i = 0; i \u0026lt; tableau.length; i\u0026#43;\u0026#43;) { System.out.println(\u0026#34;Entier : \u0026#34; \u0026#43; tableau[i] \u0026#43; \u0026#34; quantité : \u0026#34; \u0026#43; nombres[i]); } } } Exécuter Comment choisir le type d\u0026rsquo;une boucle # Le choix du type de boucle dépend du contexte du problème à résoudre et de la structure de votre code.\nUtilisez une boucle for lorsque vous connaissez à l’avance le nombre d’itérations à effectuer, par exemple pour parcourir un tableau ou répéter une action un nombre précis de fois. La boucle for est idéale pour les situations où l’on a un compteur ou un indice qui évolue de façon prévisible.\nPrivilégiez une boucle while lorsque vous ne connaissez pas à l’avance le nombre d’itérations, mais que vous souhaitez répéter une action tant qu’une condition reste vraie. C’est le cas typique de la lecture d’entrées jusqu’à une valeur sentinelle, ou d’un processus qui doit s’arrêter dès qu’une condition est remplie.\nLa boucle do\u0026hellip;while est utile lorsque vous voulez que le bloc d’instructions soit exécuté au moins une fois, peu importe la condition (par exemple, afficher un menu et demander une saisie tant que l’utilisateur ne choisit pas de quitter).\nEn résumé : choisissez la boucle qui rend votre intention la plus claire et qui correspond le mieux à la logique du problème. Un code lisible et adapté au contexte est toujours préférable à une utilisation mécanique d’un seul type de boucle.\nLecture optionnelle dans le livre de référence (Delannoy) # Pour aller plus en profondeur sur les structures d'itération (optionnel), vous pouvez lire dans Programmer en Java de Claude Delannoy le chapitre 5.\nVidéo # "},{"id":24,"href":"/inf1220-hugo/docs/modules/module3/","title":"Module 3: Les structures de données, de contrôle et d'itération en Java","section":"Modules","content":" Module 3 # Le module 3 se concentre sur les structures essentielles de la programmation en Java, en abordant les structures de données, de contrôle et d’itération. Les structures de données, telles que les tableaux et les listes, permettent d’organiser et de manipuler des ensembles d’informations de manière efficace. Les structures de contrôle, comme les conditions et les branchements, offrent les outils nécessaires pour prendre des décisions logiques dans un programme. Quant aux structures d’itération, elles permettent d’exécuter des blocs de code de manière répétée, facilitant le traitement de données complexes. À travers des exemples pratiques et des exercices tirés du manuel Java pas à pas et du site du cours, ce module enseigne comment combiner ces structures pour créer des programmes robustes et bien organisés.\nCe module explore également la manipulation des chaînes de caractères, une compétence clé pour traiter des données textuelles en Java. Les apprenants découvrent comment utiliser les méthodes associées aux chaînes pour effectuer des opérations comme la concaténation, la recherche ou le remplacement de texte. Par ailleurs, le module met l’accent sur la mise en œuvre d’algorithmes à l’aide de boucles, permettant de résoudre des problèmes de manière systématique et efficace. En s’appuyant sur des activités pratiques, ce module aide à développer une compréhension approfondie des techniques algorithmiques et renforce la capacité à concevoir des solutions programmées adaptées à des besoins variés, tout en consolidant les compétences acquises dans les modules précédents.\nEn intégrant les principes de la programmation fonctionnelle, ce module introduit des concepts tels que l’immutabilité et l’utilisation de flux (streams) en Java. Vous apprendrez comment appliquer des approches fonctionnelles pour écrire un code plus concis, modulaire et prévisible, en s’appuyant sur des outils comme les expressions lambda et les interfaces fonctionnelles. Ces techniques permettent de manipuler des collections de données de manière déclarative, renforçant ainsi la lisibilité et la maintenabilité du code. À travers des activités pratiques, ce module aide à développer une compréhension approfondie des techniques algorithmiques, qu’elles soient impératives ou fonctionnelles, et renforce la capacité à concevoir des solutions programmées adaptées à des besoins variés, tout en consolidant les compétences acquises dans les modules précédents.\nObjectifs du module # À la fin de ce module, vous serez capable de :\nIdentifier et utiliser les principales structures de données en Java (tableaux, listes, chaînes de caractères). Mettre en œuvre des structures de contrôle (conditions, branchements) pour orienter l’exécution d’un programme. Employer efficacement les structures d’itération (boucles for, while, do-while) pour traiter des ensembles de données. Manipuler les chaînes de caractères à l’aide des méthodes de la classe String et des classes associées (StringBuilder). Concevoir et analyser des algorithmes utilisant des structures de contrôle et d’itération. Résoudre des problèmes concrets en combinant ces différentes structures dans des programmes Java robustes et lisibles. Comprendre et appliquer les notions de complexité algorithmique de base (notamment O(n), O(n²)). Manipuler des collections de données à l’aide des flux (streams) pour adopter une approche déclarative dans le traitement des données. "},{"id":25,"href":"/inf1220-hugo/docs/erreurs/","title":"Vous avez trouvé une erreur?","section":"Docs","content":" Amélioration continue du cours # Le site web de ce cours est continuellement mis à jour avec de nouveaux exemples, de nouvelles explications, de nouvelles références. Le manuel est aussi mis à jour quand nous trouvons des erreurs.\nVous pouvez, de manière anonyme, nous faire parvenir vos corrections lorsque vous trouvez des erreurs sur le site. Nous apprécions toujours vos commentaires constructifs.\nNote: plusieurs étudiants partagent avec nous des suggestions de sites ou de vidéos en anglais. Bien que le cours fait quelques liens vers des sites en anglais, nous évitons l'anglais autant que possible. Si vous avez des suggestions, essayez de rester en français.\nIl arrive qu'on se trompe! Quand ça se produit, prenez la peine de nous en informer. Nous corrigeons toujours rapidement nos erreurs.\n"},{"id":26,"href":"/inf1220-hugo/docs/modules/module4/web/","title":"Développement web","section":"Module 4: Les entrées et sorties","content":" Développement web en Java # Le développement web en Java repose sur l’utilisation de technologies et de frameworks ermettant de créer des applications accessibles via un navigateur. Java est largement utilisé côté serveur grâce à sa robustesse, sa portabilité et la richesse de son écosystème.\nDans ce cours, vous n\u0026rsquo;avez pas à maîtriser la programmation web. Nous vous présentons un exemple pour motiver votre apprentissage.\nConcepts de base # Un serveur web est un programme qui reçoit les requêtes des clients (navigateurs) et renvoie des réponses (pages HTML, données JSON, etc.). Le protocole de communication qui permet l’échange de données entre le navigateur (client) et le serveur web est le HTTP. Toutes les requêtes et réponses web transitent via HTTP ou HTTPS (version sécurisée).\nDans le protocole HTTP, les méthodes (ou « verbes ») définissent l’action à effectuer sur une ressource du serveur. Les principales méthodes sont :\nGET : Récupère une ressource ou des données depuis le serveur. Par exemple, accéder à une page web ou demander des informations via une API. POST : Envoie des données au serveur pour créer une nouvelle ressource ou déclencher un traitement (par exemple, soumettre un formulaire). PUT : Met à jour une ressource existante sur le serveur avec de nouvelles données. DELETE : Supprime une ressource du serveur. PATCH : Modifie partiellement une ressource existante. Chaque méthode a un usage précis et permet de structurer les échanges entre le client (navigateur ou application) et le serveur de façon claire et standardisée. Par exemple, une API REST utilisera GET pour lire des données, POST pour en créer, PUT ou PATCH pour les modifier, et DELETE pour les supprimer. La plupart des requêtes HTTP sont de type GET ou POST.\nHTML # Le HTML (HyperText Markup Language) est le langage de balisage standard utilisé pour structurer le contenu des pages web. Il permet de définir la hiérarchie des éléments (titres, paragraphes, listes, tableaux, images, liens, etc.) et d’organiser l’information de façon logique et accessible. Chaque élément HTML est représenté par des balises, généralement une balise ouvrante et une balise fermante, qui encadrent le contenu à afficher.\nLe HTML est interprété par le navigateur, qui transforme la structure décrite en une page visuelle. Il est possible d’ajouter des attributs aux balises pour préciser leur apparence ou leur comportement (par exemple, l’attribut href pour les liens ou src pour les images). Le HTML est la base de toute page web, et il peut être enrichi par des feuilles de style CSS et des scripts JavaScript.\nExemple de base :\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Ma première page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Bienvenue sur mon site\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Ceci est un paragraphe en HTML.\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;https://www.example.com\u0026#34;\u0026gt;Un lien\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript # JavaScript est un langage de programmation exécuté principalement côté client, c’est-à-dire dans le navigateur web. Il permet de rendre les pages web interactives et dynamiques : gestion des événements (clics, saisies clavier), modification du contenu de la page sans rechargement, animations, validation de formulaires, etc. JavaScript est devenu un standard incontournable du développement web moderne.\nGrâce à JavaScript, il est possible de manipuler le Document Object Model (DOM), c’est-à-dire la structure de la page HTML, pour ajouter, modifier ou supprimer des éléments à la volée. JavaScript peut aussi communiquer avec le serveur via des requêtes asynchrones (AJAX), ce qui permet de mettre à jour une partie de la page sans la recharger entièrement.\nExemple simple :\n\u0026lt;button onclick=\u0026#34;alert(\u0026#39;Bonjour !\u0026#39;)\u0026#34;\u0026gt;Cliquez-moi\u0026lt;/button\u0026gt; Exemple de modification du contenu :\n\u0026lt;p id=\u0026#34;demo\u0026#34;\u0026gt;Texte initial\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; document.getElementById(\u0026#39;demo\u0026#39;).innerText = \u0026#39;Texte modifié par JavaScript\u0026#39;; \u0026lt;/script\u0026gt; JSON # JSON (JavaScript Object Notation) est un format léger d’échange de données, facile à lire et à écrire pour les humains et les machines. Il est basé sur une syntaxe dérivée des objets JavaScript, mais il est utilisé par de nombreux langages de programmation. JSON est particulièrement populaire pour transmettre des données entre un serveur et une application web, notamment dans les API REST.\nUn document JSON est constitué de paires clé/valeur, de tableaux et d’objets imbriqués. Il ne supporte que quelques types de données : chaînes de caractères, nombres, booléens, tableaux, objets et null. JSON est plus compact et plus facile à manipuler que le XML, ce qui explique son adoption massive dans le développement web.\nExemple de structure JSON :\n{ \u0026#34;nom\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;estEtudiant\u0026#34;: false, \u0026#34;competences\u0026#34;: [\u0026#34;Java\u0026#34;, \u0026#34;HTML\u0026#34;, \u0026#34;JavaScript\u0026#34;] } Exemple d’utilisation en JavaScript :\nconst donnees = \u0026#39;{\u0026#34;nom\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30}\u0026#39;; const obj = JSON.parse(donnees); console.log(obj.nom); // Affiche \u0026#34;Alice\u0026#34; XML # XML (Extensible Markup Language) est un autre format d’échange de données, plus structuré et verbeux que JSON. Il utilise des balises personnalisables pour décrire les données, ce qui le rend très flexible et adapté à des applications nécessitant une structure complexe, comme les documents ou les configurations. XML est largement dans les fichiers de configuration, en bureautique (Microsoft Word stocke ses données en XML) ou les formats de documents. Contrairement à JSON, XML supporte les attributs dans les balises et permet l’inclusion de métadonnées, mais sa syntaxe plus lourde peut compliquer son traitement.\nExemple de structure XML :\n\u0026lt;personne\u0026gt; \u0026lt;nom\u0026gt;Alice\u0026lt;/nom\u0026gt; \u0026lt;age\u0026gt;30\u0026lt;/age\u0026gt; \u0026lt;estEtudiant\u0026gt;false\u0026lt;/estEtudiant\u0026gt; \u0026lt;competences\u0026gt; \u0026lt;competence\u0026gt;Java\u0026lt;/competence\u0026gt; \u0026lt;competence\u0026gt;HTML\u0026lt;/competence\u0026gt; \u0026lt;competence\u0026gt;JavaScript\u0026lt;/competence\u0026gt; \u0026lt;/competences\u0026gt; \u0026lt;/personne\u0026gt; CSS # Le CSS (Cascading Style Sheets) est un langage de style qui permet de contrôler l’apparence visuelle des pages web. Il sépare la présentation (couleurs, polices, marges, disposition, etc.) du contenu HTML, ce qui facilite la maintenance et la personnalisation des sites. Un fichier CSS est composé de règles de style, chacune ciblant un ou plusieurs éléments HTML à l’aide de sélecteurs. La structure de base d’une règle CSS est :\nsélecteur { propriété1: valeur1; propriété2: valeur2; /* ... */ } Le sélecteur indique quels éléments HTML seront affectés par la règle (par exemple, body, h1, .container). Les propriétés définissent les aspects visuels à modifier (couleur, police, marges, etc.), et chaque propriété est suivie de sa valeur. Pour cibler une classe (attribut class dans le HTML), on utilise un point devant le nom de la classe dans le sélecteur. Par exemple, .container cible tous les éléments ayant class=\u0026quot;container\u0026quot;.\nExemple :\n\u0026lt;div class=\u0026#34;message\u0026#34;\u0026gt;Ceci est un message\u0026lt;/div\u0026gt; .message { color: #d35400; font-weight: bold; } Ici, la règle .message s’applique à tous les éléments HTML ayant la classe message. On peut appliquer plusieurs classes à un même élément en les séparant par des espaces dans l’attribut class.\nLes fichiers CSS peuvent être inclus dans une page HTML via la balise \u0026lt;style\u0026gt; dans le \u0026lt;head\u0026gt;, ou bien dans un fichier externe référencé par \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;style.css\u0026quot;\u0026gt;. L’utilisation de classes permet de réutiliser facilement des styles sur plusieurs éléments et de structurer le design de façon modulaire et maintenable.\nAPI REST # Une API REST (Representational State Transfer) est une interface qui permet à différentes applications de communiquer entre elles via le protocole HTTP, en utilisant des méthodes standard comme GET, POST, PUT et DELETE. Les API REST sont largement utilisées pour exposer des services web, car elles sont simples, flexibles et compatibles avec de nombreux langages et plateformes. Les données échangées entre le client et le serveur sont généralement au format JSON, ce qui facilite leur traitement côté navigateur ou application mobile.\nLe principe de REST repose sur l’utilisation d’URL pour identifier les ressources (par exemple, /utilisateurs/123 pour accéder à l’utilisateur numéro 123) et sur l’utilisation des méthodes HTTP pour effectuer des opérations sur ces ressources (lecture, création, modification, suppression). Une API REST bien conçue est stateless (sans état côté serveur entre deux requêtes) et respecte des conventions claires pour la structure des URL et des réponses.\nExemple d’appel à une API REST en JavaScript :\nfetch(\u0026#39;https://api.exemple.com/utilisateurs/123\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)); Dans cet exemple, le client envoie une requête GET à l’URL de l’API, reçoit une réponse au format JSON, puis affiche les données reçues. Les API REST sont au cœur du développement web moderne, notamment pour les applications à architecture « front-end/back-end » séparée.\nDéveloppement d\u0026rsquo;un serveur web simple # Pour développer un serveur web simple, nous pouvons utiliser Javalin. Javalin est un framework web léger pour Java et Kotlin, conçu pour faciliter la création d’applications web. Il se distingue par sa simplicité d’utilisation, sa configuration minimale et sa rapidité de prise en main. Avec Javalin, il est possible de démarrer un serveur web en quelques lignes de code, de définir des routes HTTP (GET, POST, etc.), de gérer les requêtes et les réponses, et d’intégrer facilement des fonctionnalités comme le rendu de templates ou la gestion de fichiers statiques.\nPour faire des pages web, nous pouvons combiner Javaline avec un générateur de HTML. Nous utilisons généralement une approche par templates (modèles). Thymeleaf est un moteur de template moderne pour Java. Il permet de générer dynamiquement des pages HTML côté serveur, en injectant des variables et des structures de contrôle (conditions, boucles, etc.). Les templates Thymeleaf sont des fichiers HTML standards, enrichis de balises spécifiques (th:text, th:if, etc.), ce qui facilite leur édition et leur prévisualisation.\nConcevons un petit jeu web où l\u0026rsquo;utilisateur devra deviner un nombre. Commençons par présenter le template thymeleaf:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34; lang=\u0026#34;fr\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Jeu du cours INF 1220 : Devinez le nombre\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Jeu du cours INF 1220\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;subtitle\u0026#34;\u0026gt;Devinez le nombre choisi par le serveur (entre 1 et 100).\u0026lt;/div\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;/guess\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; name=\u0026#34;guess\u0026#34; min=\u0026#34;1\u0026#34; max=\u0026#34;100\u0026#34; required placeholder=\u0026#34;Votre nombre\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Deviner\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;div class=\u0026#34;message\u0026#34; th:text=\u0026#34;${message}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Ce code HTML est un exemple de template Thymeleaf utilisé pour générer dynamiquement une page web côté serveur. Les balises classiques du HTML sont enrichies d’attributs spécifiques à Thymeleaf, comme th:text=\u0026quot;${message}\u0026quot;, qui permet d’afficher dynamiquement un message provenant du serveur (par exemple, pour indiquer si la proposition de l’utilisateur est trop haute, trop basse ou correcte). Grâce à cette approche, le même template peut être réutilisé pour différents états du jeu, en fonction des variables transmises par le serveur Java.\nL’utilisation de Thymeleaf facilite la séparation entre la logique applicative (traitée en Java) et la présentation (gérée dans le template HTML). Les développeurs peuvent ainsi concevoir des pages web interactives et personnalisées, tout en gardant un code HTML lisible et modifiable par des non-programmeurs (par exemple, des designers ou des rédacteurs).\nDans le template Thymeleaf présenté, on retrouve plusieurs éléments HTML fondamentaux :\n\u0026lt;html xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot; lang=\u0026quot;fr\u0026quot;\u0026gt; : Balise racine qui indique le début du document HTML. L’attribut xmlns:th déclare l’espace de noms Thymeleaf pour activer ses fonctionnalités, et lang=\u0026quot;fr\u0026quot; précise la langue du document. \u0026lt;head\u0026gt; : Contient les métadonnées de la page (non affichées directement à l’écran). \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; : Définit l’encodage des caractères en UTF-8, indispensable pour afficher correctement les caractères spéciaux et accentués. \u0026lt;title\u0026gt; : Spécifie le titre de la page, affiché dans l’onglet du navigateur. \u0026lt;body\u0026gt; : Partie principale du document, qui contient tout le contenu visible par l’utilisateur. \u0026lt;h1\u0026gt; : Titre principal de la page, utilisé ici pour afficher le nom du jeu. \u0026lt;div class=\u0026quot;subtitle\u0026quot;\u0026gt; : Bloc de texte qui sert de sous-titre ou d’instruction à l’utilisateur. \u0026lt;form method=\u0026quot;post\u0026quot; action=\u0026quot;/guess\u0026quot;\u0026gt; : Formulaire HTML permettant à l’utilisateur de soumettre sa proposition. L’attribut method=\u0026quot;post\u0026quot; indique que les données seront envoyées en POST, et action=\u0026quot;/guess\u0026quot; précise l’URL de traitement côté serveur. \u0026lt;input type=\u0026quot;number\u0026quot; name=\u0026quot;guess\u0026quot; min=\u0026quot;1\u0026quot; max=\u0026quot;100\u0026quot; required placeholder=\u0026quot;Votre nombre\u0026quot;\u0026gt; : Champ de saisie pour entrer un nombre entre 1 et 100. Les attributs min, max et required imposent des contraintes de validation côté navigateur. \u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt; : Bouton pour envoyer le formulaire. \u0026lt;div class=\u0026quot;message\u0026quot; th:text=\u0026quot;${message}\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; : Bloc destiné à afficher dynamiquement un message (succès, erreur, indice) transmis par le serveur via Thymeleaf. L’attribut th:text est propre à Thymeleaf et permet d’injecter du texte calculé côté serveur. Tournons nous maintenant vers notre code Java utilisant Javalin.\nimport io.javalin.Javalin; import io.javalin.rendering.template.JavalinThymeleaf; import io.javalin.http.Context; import java.util.Random; import java.util.HashMap; import java.util.Map; public class GuessNumberApp { public static void main(String[] args) { int port = 7070; Javalin app = Javalin.create(config -\u0026gt; { config.fileRenderer(new JavalinThymeleaf()); }).start(port); app.get(\u0026#34;/\u0026#34;, GuessNumberApp::showGame); app.post(\u0026#34;/guess\u0026#34;, GuessNumberApp::handleGuess); } private static void showGame(Context ctx) { if (ctx.sessionAttribute(\u0026#34;number\u0026#34;) == null) { ctx.sessionAttribute(\u0026#34;number\u0026#34;, new Random().nextInt(100) + 1); } Map\u0026lt;String, Object\u0026gt; model = new HashMap\u0026lt;\u0026gt;(); model.put(\u0026#34;message\u0026#34;, \u0026#34;\u0026#34;); ctx.render(\u0026#34;templates/game.html\u0026#34;, model); } private static void handleGuess(Context ctx) { int number = ctx.sessionAttribute(\u0026#34;number\u0026#34;); int guess = Integer.parseInt(ctx.formParam(\u0026#34;guess\u0026#34;)); Map\u0026lt;String, Object\u0026gt; model = new HashMap\u0026lt;\u0026gt;(); if (guess \u0026lt; number) { model.put(\u0026#34;message\u0026#34;, \u0026#34;Trop petit ! Essayez encore.\u0026#34;); } else if (guess \u0026gt; number) { model.put(\u0026#34;message\u0026#34;, \u0026#34;Trop grand ! Essayez encore.\u0026#34;); } else { model.put(\u0026#34;message\u0026#34;, \u0026#34;Bravo ! Vous avez trouvé le nombre. Un nouveau nombre a été choisi.\u0026#34;); ctx.sessionAttribute(\u0026#34;number\u0026#34;, new Random().nextInt(100) + 1); } ctx.render(\u0026#34;templates/game.html\u0026#34;, model); } } Ce code Java met en œuvre un petit serveur web avec Javalin pour créer un jeu interactif « Devinez le nombre ». La classe principale GuessNumberApp configure le serveur sur le port 7070, active le moteur de templates Thymeleaf pour le rendu HTML, et définit deux routes : une pour afficher le jeu (/) et une pour traiter les propositions de l’utilisateur (/guess). L’utilisation de Javalin permet de démarrer le serveur et de gérer les requêtes HTTP en quelques lignes, rendant le développement web très accessible.\nLa méthode showGame initialise la session de l’utilisateur en choisissant un nombre aléatoire entre 1 et 100 s’il n’existe pas déjà, puis prépare un modèle (un dictionnaire de variables) transmis au template Thymeleaf pour afficher la page du jeu. La méthode handleGuess récupère la proposition envoyée par l’utilisateur via le formulaire, la compare au nombre à deviner, et met à jour le message affiché selon le résultat (trop petit, trop grand, ou trouvé). Si le nombre est trouvé, un nouveau nombre est choisi pour permettre de rejouer sans recharger la page.\nJavalin utilise la notion de route. Une « route » dans le contexte d’un serveur web désigne l’association entre une URL (ou un motif d’URL) et une fonction qui sera exécutée lorsque cette URL est demandée par un client (navigateur ou application). Chaque route correspond à une action précise du serveur, comme afficher une page, traiter un formulaire ou fournir des données via une API. Par exemple, dans le code du jeu, la route app.get(\u0026quot;/\u0026quot;, GuessNumberApp::showGame); indique que lorsqu’un utilisateur accède à la racine du site (/) avec une requête GET, la méthode showGame sera appelée pour générer la page. De même, la route app.post(\u0026quot;/guess\u0026quot;, GuessNumberApp::handleGuess); traite les soumissions du formulaire de jeu envoyées en POST à l’URL /guess. Les routes permettent ainsi de structurer clairement le comportement du serveur en fonction des différentes actions attendues par les utilisateurs.\nNotre fonction handleGuess reçoit un objet de type Context. Cet objet représente la requête HTTP en cours et fournit tous les outils nécessaires pour accéder aux données envoyées par l’utilisateur (comme les paramètres de formulaire), manipuler la session, et construire la réponse à renvoyer au client. Grâce à Context, on peut facilement lire les valeurs soumises, stocker des informations persistantes pour l’utilisateur (par exemple, le nombre à deviner), et rendre un template HTML avec des variables dynamiques. Cela simplifie grandement la gestion des interactions entre le serveur et le navigateur dans une application web Java.\nPour construire et lancer l\u0026rsquo;application, nous pouvons utiliser Maven. Maven est un outil de gestion de projet et d’automatisation de la compilation pour les projets Java. Il permet de décrire la structure du projet, les dépendances (bibliothèques externes comme Javalin ou Thymeleaf), les étapes de compilation, de test et de déploiement dans un fichier de configuration appelé pom.xml. Grâce à Maven, il suffit d’une commande (mvn package ou mvn exec:java) pour télécharger automatiquement toutes les dépendances nécessaires, compiler le code source, exécuter les tests et lancer l’application. Cela simplifie grandement le développement, la maintenance et le partage de projets Java, en garantissant que tous les développeurs utilisent les mêmes versions de bibliothèques et une structure cohérente. Le fichier pom.xml (Project Object Model) est au cœur de Maven. Il contient des sections clés comme les coordonnées du projet (groupId, artifactId, version), les dépendances avec leurs versions spécifiques, et les plugins qui personnalisent le cycle de vie du build. Par exemple, pour une application web utilisant Javalin, on ajoute la dépendance \u0026lt;dependency\u0026gt;\u0026lt;groupId\u0026gt;io.javalin\u0026lt;/groupId\u0026gt;\u0026lt;artifactId\u0026gt;javalin\u0026lt;/artifactId\u0026gt;\u0026lt;version\u0026gt;5.6.3\u0026lt;/version\u0026gt;\u0026lt;/dependency\u0026gt; dans le pom.xml. Maven télécharge alors cette bibliothèque depuis un dépôt central comme Maven Central. Les plugins, comme le plugin maven-compiler-plugin, permettent de configurer des options comme la version de Java à utiliser. Cette centralisation des configurations facilite la reproductibilité et réduit les erreurs liées à des environnements de développement différents. Maven offre également une gestion avancée des cycles de vie du projet, divisés en phases comme compile, test, package et install. Chaque phase exécute des tâches prédéfinies, mais vous pouvez les personnaliser via des plugins. Par exemple, avec le plugin exec-maven-plugin, vous pouvez exécuter directement votre application avec mvn exec:java. De plus, Maven supporte l’intégration avec des outils d’intégration continue comme Jenkins, permettant d’automatiser les déploiements. En structurant votre projet selon les conventions de Maven (dossiers src/main/java pour le code source et src/test/java pour les tests), vous gagnez en clarté et en compatibilité avec d’autres outils de l’écosystème Java, rendant votre application plus robuste et facile à maintenir. Une solution de recherche populaire à Maven est Gradle, un autre outil de build pour les projets Java. Gradle utilise un fichier de configuration nommé build.gradle, écrit en Groovy ou Kotlin, qui offre une syntaxe plus concise et flexible que le XML de Maven. Par exemple, pour ajouter Javalin, on écrit implementation \u0026lsquo;io.javalin:javalin:5.6.3\u0026rsquo; dans build.gradle. Gradle est particulièrement apprécié pour sa performance, grâce à un mécanisme de cache et une exécution incrémentale des tâches. Il suit un modèle de tâches personnalisables, où des commandes comme gradle build ou gradle run gèrent la compilation, les tests et l’exécution. Gradle est également bien intégré avec les IDE comme IntelliJ IDEA et supporte les mêmes conventions de structure de projet que Maven, tout en offrant plus de souplesse pour les projets complexes ou multi-modules.\nJe vous invite maintenant à consulter l\u0026rsquo;application web complète en ligne. Vous pouvez la charger sur votre machine et la déployer en suivant les instructions.\nVous devriez pouvoir utiliser l\u0026rsquo;application web sur votre PC. Comment la rendre disponible sur le web ? Je recommande d\u0026rsquo;utiliser une approche par container Docker. Malheureusement, ce sujet excède le cadre du présent cours.\nQuestions de révision # Qu’est-ce qu’une route dans le contexte d’un serveur web avec Javalin ? Donnez un exemple de route et expliquez son rôle. À quoi sert le moteur de templates Thymeleaf dans cette application ? Comment permet-il de séparer la logique et la présentation ? Expliquez le rôle de l’objet Context dans la gestion d’une requête HTTP avec Javalin. Quelles sont ses principales utilisations dans le jeu « Devinez le nombre » ? Pourquoi utilise-t-on Maven pour construire et lancer l’application Java ? Quels sont les avantages de cet outil pour la gestion des dépendances et du cycle de vie du projet ? Modifiez le code du jeu pour limiter le nombre d’essais de l’utilisateur à 10. Que faudrait-il changer dans la gestion de la session et du modèle ? "},{"id":27,"href":"/inf1220-hugo/docs/modules/module2/exercices-2-1/","title":"Exercices sur les classes, les variables, les types et les opérateurs","section":"Module 2: Introduction au langage Java","content":" Exercices sur les classes, les variables, les types et les opérateurs # Prenez en note chaque question. Tentez par vos propres moyens, mais avec l'aide de tout le matériel et de l'Internet, de résoudre le problème. Prévoyez jusqu'à 15 minutes de travail par question. Après avoir bien travaillé la question, consultez la réponse.\nN'allez pas trop vite. Il ne sert à rien de lire la question et d'immédiatement lire la réponse. Le but des exercices est de vous amener à travailler la matière. Si vous ne faites que regarder les solutions, vous n'apprenez pas grand chose. Oui, ça va plus vite, mais votre but ici n'est pas la rapidité.\nPrenez note qu'il est permis d'utiliser le robot conversationnel du cours lors des exercises. Cependant vous devriez vous entraîner à produire vos propres réponses.\nRéponses uniques? # Les exercices comportent une solution vous permettant de comparer votre approche avec la nôtre. Il n'y a pas de solution unique aux problèmes en général. Vous pouvez arriver avec une solution qui est préférable ou moins bonne que celle que nous offrons. Pour faire ces questions, vous devez avoir fait toutes les lectures préalables. Vous disposez alors toujours des fondements nécessaires pour faire les exercices. Nous vous encourageons tout de même à faire vos propres recherches en complément de vos lectures. Dans certains cas, au sein de la solution que nous offrons, nous pouvons utiliser des notions techniques qui n'ont pas été vues directement dans le cours, mais qui devraient vous être facilement accessibles.\nQuestions/Réponses # Question 1 # En programmation orientée objet (comme le langage Java), quelle est la différence entre une classe et une instance?\nRéponse Une classe est la description abstraite d'un concept. Une instance est la matérialisation en mémoire d'un concept. Par exemple, la classe Client et l'instance Client 11 Alice Bob. Question 2 # Vrai ou Faux : Le langage Java est un langage compilé en langage machine?\nRéponse Vrai et Faux: c'est un langage interprété par une machine virtuelle, la JVM. La code est pré-compilé dans un langage intermédiaire, le bytecode. Par la suite, lors de l'exécution, le bytecode peut être compilé en langage machine. Question 3 # Vrai ou Faux : Le mot-clé \"static\" permet de créer une seule variable en mémoire pour plusieurs instances d'un objet?\nRéponse Vrai: le mot-clé static permet de créer une variable \"pointant\" vers une seule adresse en mémoire. Donc, si la classe Test possède une variable static, toutes les instances de la classe Test accèderont à la même variable en mémoire. Elles pourraient donc modifier cette valeur à tour de rôle. Question 4 # Le code suivant est truffé d'erreurs. Veuillez énumérer les erreurs et les corriger.\npublic clas PleinErreurs { public int entier = \u0026#34;Entier\u0026#34;; public static String string = new String(\u0026#34;string\u0026#34;); public static void main(String[] args) { entier += 33; string = entier + string; System.out.println(string) } } Réponse Le mot clas : class Il manque le mot static devant la variable int entier On ne peut pas initialiser un int avec une chaîne de caractère. Mettre entier = 0; Ajouter un point-virgule à la fin du System.out.println public class PleinErreurs { public static int entier = 0; public static String string = new String(\u0026#34;string\u0026#34;); public static void main(String[] args) { entier += 33; string = entier + string; System.out.println(string); } } Le fait de faire : \u0026ldquo;entier + string\u0026rdquo; n\u0026rsquo;est pas une erreur. La JVM va convertir automatiquement le int en string suivant l\u0026rsquo;opération \u0026ldquo;+\u0026rdquo;.\nQuestion 5 # À l'aide d'une classe Java et en utilisant l'arithmétique entière, vous devez calculer la moyenne des tailles de 5 enfants, puis imprimer la moyenne à la console et l'écart à la moyenne pour chaque enfant:\nAlice : 104 cm Bob : 80 cm Chuck : 76 cm Danielle : 110 cm Éloi : 102 cm Réponse CalculMoyenne.java public class CalculMoyenne { public static void main(String[] args) { int tailleAlice = 104; int tailleBob = 80; int tailleChuck = 76; int tailleDanielle = 110; int tailleEloi = 102; //Calculer la moyenne int moyenne = (tailleAlice \u0026#43; tailleBob \u0026#43; tailleChuck \u0026#43; tailleDanielle \u0026#43; tailleEloi) / 5; //Imprimer la moyenne System.out.println(\u0026#34;Moyenne : \u0026#34; \u0026#43; moyenne); //Calcul des écart. Utilisation de la méthode Math.abs pour avoir la valeur absolue System.out.println(\u0026#34;ECT Alice : \u0026#34; \u0026#43; Math.abs(tailleAlice - moyenne)); System.out.println(\u0026#34;ECT Bob : \u0026#34; \u0026#43; Math.abs(tailleBob - moyenne)); System.out.println(\u0026#34;ECT Chuck : \u0026#34; \u0026#43; Math.abs(tailleChuck - moyenne)); System.out.println(\u0026#34;ECT Danielle : \u0026#34; \u0026#43; Math.abs(tailleDanielle - moyenne)); System.out.println(\u0026#34;ECT Eloi : \u0026#34; \u0026#43; Math.abs(tailleEloi - moyenne)); } } Exécuter Question 6 # Quelle est la différence entre un int et un long ?\nRéponse Un entier de type int sera alloué en mémoire à une taille de 32 bits. Sa valeur maximale absolue est donc de 2 147 483 647. L'entier de type long permet des valeurs plus grandes car il est alloué sur un espace de 64 bits (9 223 372 036 854 775 807). Question 7 # Que fait le code suivant ? Calculer sur papier pour s'assurer de la compréhension, puis voir la réponse ci-dessous et exécuter le code.\npublic class Exercice { public static void main(String[] args) { int i = 33; int j = 44; int k = 55; i++; j--; i = -(k + i - j); i = i%2; System.out.println(\u0026#34;Résultat:\u0026#34;+ i); } } Réponse Le résultat est 0. 1: i++ =\u003e i = 34; 2: j-- =\u003e j = 43; 3 : k + i - j = 46; 4: -46; 5: -46 % 2 = 0 (le reste de la division par 2. Comme 46 / 2 = 23. Il n'y a pas de reste); Question 8 # Quelle sera la valeur de x dans le code suivant?\npublic class Exercice { public static void main(String[] args) { int i = 11; int j = 22; long x = (i\u0026gt;=1) ? ++i : j++; System.out.println(\u0026#34;x : \u0026#34; + x); } } Réponse La réponse est 12 car l'opérateur à 3 opérandes \"?:\" vérifie si i est plus grand ou égal à 1 (c'est le cas), alors la valeur retournée est i pré-incrémenté de 1 : 12. Question 9 # Expliquer pourquoi exercice1.resultat vaut 30 et non 80 à la fin de la méthode main. Que faudrait-il corriger dans le code suivant si on souhaite obtenir 80 ?\npublic class Exercice { protected int numeroExercice = 1; protected boolean reussi = false; protected static short resultat = 0; public static void main(String[] args) { } } Réponse Il faut enlever le qualifiant static à l'attribut result. Question 10 # Vous avez à créer une classe qui selon une constante de type nombre entier présente dans la classe, le code doit afficher le bon nombre de mots de la phrase suivante : \"Veni vidi vici\". Vous ne pouvez qu'utiliser les opérateurs vus dans la leçon précédente (truc: opérateur à trois opérandes).\nRéponse Main.java public class Main { // La constante qui détermine le nombre de mot; public static final int nombreDeMot = 3; public static final String veni = \u0026#34;Veni\u0026#34;; public static final String vidi = \u0026#34;vidi\u0026#34;; public static final String vici = \u0026#34;vici\u0026#34;; public static void main(String[] args){ String phrase = new String(); phrase = (nombreDeMot == 3) ? veni \u0026#43; vidi \u0026#43; vici : (nombreDeMot == 2) ? veni \u0026#43; vidi : (nombreDeMot == 1) ? veni : \u0026#34;\u0026#34;; System.out.println(\u0026#34;Phrase : \u0026#34; \u0026#43; phrase); } } Exécuter Question 11 # Parmi les noms suivants, quels sont les noms de variable corrects en java (qui ne seront pas rejetés à la compilation)?\nLesquels sont conseillés ?\n1) _176\n2) $za21\n3) 5var\n4) A1234_\n5) var\n6) monEntier\n7) \u0026amp;var\nRéponse Nom corrects : 1, 2, 4, 5, 6.\nNoms conseillés : 5, 6. En effet à moins d\u0026#x2019;avoir de sérieuses raisons de faire autrement, il faut utiliser les minuscules pour les noms de variables simples en java, et les majuscules pour articuler les noms de variables composés comme monEntier.\nQuestion 12 # Soit les deux codes suivants :\n1)\npublic class Main { public static void main(String[] args) { final int NOMBRE; System.out.println((NOMBRE=10) + \u0026#34; Je suis un nombre final \u0026#34;); } } 2)\npublic class Main { public static void main(String[] args) { final int NOMBRE=0; System.out.println((NOMBRE=10) + \u0026#34; Je suis un nombre final \u0026#34;); } } Lequel renvoie une erreur ? Pourquoi n\u0026#x2019;y a-t-il pas d\u0026#x2019;erreur dans celui qui s\u0026#x2019;execute correctement ?\nRéponse Le code 2) renvoie une erreur. Le code 1) ne renvoie pas d\u0026#x2019;erreur, puisque nous pouvons fixer la valeur d'une constante déclarée finale après dans la déclaration, mais une seule fois.\nQuestion 13 # Soit le code suivant :\npublic class Main { public static void main(String[] args) { int k, i; int myInt = k = (i = 5) * 2; System.out.println(myInt); } } Quel résultat est affiché à la console lors de l\u0026#x2019;exécution ? Pourquoi ?\nUne erreur 10 5 Réponse Bonne réponse : 2.\nExplication : (i=5) est une expression dont la résultat est la valeur affectée à i, c\u0026#x2019;est-à-dire 5. Ce résultat est multiplié par deux et affecté à k, puis affecté à myInt.\nQuestion 14 # Que fait le code suivant?\nint f(int x, int y) { x ^= y; y ^= x; x ^= y; return y; } Réponse La fonction retourne la valeur qui était contenue dans la variable x au début de la fonction. Voir l'article wikipédia sur les techniques de permutation en informatique. Question 15 # Que va afficher ce code à l\u0026rsquo;écran?\nclass Main { public static void main(String[] args) { System.out.println(-1 \u0026gt;\u0026gt;\u0026gt; 4); System.out.println(-1 \u0026gt;\u0026gt;\u0026gt;\u0026gt; 4); } } Réponse -1 et 268435455.\nQuestion 16 # Que calcule cette fonction?\npublic static boolean f(int x, int y) { return (x^y) \u0026lt; 0; } Réponse La fonction retourne la valeur vraie si et seulement si un seul des deux paramètres est négatif. Par exemple, f(-1,1) est vrai, f(2,2) et f(-1,-3) sont faux.\nQuestion 17 # Nous savons que la somme 1/2 + 1/4 + 1/8 +... donne la valeur unitaire.\nSachant qu'un type double en Java a une mantisse comportant 53 bits, que va afficher le programme suivant?\nclass Main { public static void main(String[] args) { double x = 0; double f = 1.0; for (int i = 0; i \u0026lt; 53; i++) { f /= 2; x += f; } System.out.println(x==1.0); f /= 2; x += f; System.out.println(x==1.0); } } Réponse false, true\nQuestion 18 # Vrai ou faux... si x est un entier (int) négatif, alors -x sera un entier positif. Réponse Faux. Définissez int x = -2147483648. Vous trouvez alors que -x == x.\nQuestion 19 # Quelle est la valeur de l'expression 2083697005*101 en Java?\nRéponse L'expression 2083697005*101 est égale à 1. Cela s'explique par le fait que les entiers sont stockés avec 32 bits seulement et que la véritable valeur (210453397505) ne peut pas être représentée. Java tronque le résultat. Question 20 # Soit deux entiers positifs (int) x et y. Sachant que la moyenne des deux valeurs est aussi un entier, donnez une expression qui calcule cette moyenne.\nRéponse On peut la calculer avec l'expression y+(x - y)/2. Il pourrait être tentant d'utiliser l'expression (x + y)/2, mais cette dernière est incorrecte comme vous pouvez le vérifier avec ce programme: class Main { public static void main(String[] args) { int x = 2147483647; int y = 2147483645; System.out.println((x+y)/2); System.out.println(y+(x - y)/2); } } Question 21 # Soit une chaîne de caractère en Java: String s = \"123\";. Comment puis-je modifier la valeur de cette chaîne de caractères?\nRéponse En Java, les chaînes de caractères sont immutables, elles ne peuvent être modifiées. On ne peut donc pas modifier la valeur assigné à s. Par contre, on peut créer une nouvelle chaîne de caractères et réassigner la variable à cette nouvelle valeur (s = \"1234\";). Question 22 # Expliquez la différence entre l'ensemble des nombres non négatifs, et l'ensemble des nombres positifs.\nRéponse En informatique, on définit l\u0026rsquo;ensemble des nombres positifs comme étant les nombres plus grands que zéro. Les nombres négatifs sont les nombres plus petits que zéro. Les nombres non négatifs sont donc les nombres positifs ou nuls.\nQuestion 23 # Expliquez pourquoi 0.8825149536132812 est égal à 0.8825149536132813 en Java.\nRéponse Dans le cas qui nous concerne, il n'est pas possible de distinguer 0.8825149536132812 et 0.8825149536132813, des nombres à 16 chiffres significatifs. En général, il est possible de représenter l'ensemble des nombres entre -10 à la puissance 308 et 10 à la puissance 308 avec 15 chiffres de précision, mais pas 16 chiffres de précision. Les nombres 0.8825149536132812 et 0.8825149536132813 sont représentés en nombre à virgule flottante comme étant 115673 fois 2 à la puissance -17 ce qui est le nombre 0.88251495361328125. Question 24 # Écrivez un code Java qui affiche tous les entiers pairs de 0 à 20 inclus.\nRéponse for (int i = 0; i \u0026lt;= 20; i += 2) { System.out.println(i); } Question 25 # Quel sera le résultat de l\u0026rsquo;expression 1.0 / 0.0 ?\nRéponse En Java, l'expression 1.0 / 0.0 retourne Infinity (l'infini positif), car la division par zéro avec des nombres à virgule flottante (double) ne provoque pas d'exception, mais retourne une valeur spéciale représentant l'infini.\nQuestion 26 # Quel sera le résultat de l\u0026rsquo;expression 1 / 0 ?\nRéponse En Java, l'expression 1 / 0 provoque une erreur de type division par zéro, car la division entière par zéro n'est pas définie.\nQuestion 27 # Quelle est la différence entre == et equals() pour comparer deux chaînes de caractères en Java ?\nRéponse == compare les références (adresses en mémoire), alors que equals() compare le contenu des chaînes. Il faut utiliser equals() pour vérifier si deux chaînes ont le même texte.\nQuestion 28 # Que fait l’opérateur + lorsqu’il est utilisé avec des chaînes de caractères et des nombres en Java ? Donnez un exemple.\nRéponse L’opérateur + concatène les chaînes et convertit automatiquement les nombres en chaînes si l’un des opérandes est une chaîne.\nExemple :\nString s = \u0026#34;Valeur : \u0026#34; + 10 + 5; // \u0026#34;Valeur : 105\u0026#34; Question 29 # Quelle est la valeur de l’expression 1 + 2 + \u0026ldquo;3\u0026rdquo; + 4 + 5 en Java ?\nRéponse L’expression s’évalue de gauche à droite : 1 + 2 donne 3, puis 3 + \"3\" donne \"33\" (concaténation), puis \"33\" + 4 donne \"334\", puis \"334\" + 5 donne \"3345\". La valeur finale est \"3345\".\nQuestion 30 # Comment extraire une sous-chaîne d’une chaîne en Java ? Donnez un exemple avec substring().\nRéponse On utilise la méthode substring(debut, fin) pour obtenir une sous-chaîne allant de l’indice debut (inclus) à fin (exclu).\nExemple :\nString texte = \u0026#34;Bonjour\u0026#34;; String sous = texte.substring(0, 3); // \u0026#34;Bon\u0026#34; Question 31 # Comment vérifier si une chaîne commence ou se termine par un certain texte en Java ?\nRéponse On utilise startsWith() pour vérifier le début, et endsWith() pour la fin.\nExemple :\nString phrase = \u0026#34;Bonjour le monde\u0026#34;; System.out.println(phrase.startsWith(\u0026#34;Bon\u0026#34;)); // true System.out.println(phrase.endsWith(\u0026#34;monde\u0026#34;)); // true Question 32 # Qu’est-ce qu’une classe enveloppe (wrapper) en Java ? Donnez un exemple d’utilisation pour convertir une chaîne de caractères en entier.\nRéponse Une classe enveloppe permet de manipuler un type primitif comme un objet. Exemple :\nString s = \u0026#34;123\u0026#34;; int n = Integer.parseInt(s); // n vaut 123 Question 33 # Expliquez la différence entre int et Integer en Java. Dans quel cas doit-on utiliser Integer ?\nRéponse int est un type primitif, alors que Integer est une classe objet qui encapsule un int. /p\u003e Question 34 # Que vaut l’expression new Integer(3) == new Integer(3) en Java ? Expliquez pourquoi.\nRéponse L’expression retourne false. Chaque appel à new Integer(3) crée un nouvel objet distinct en mémoire : les deux objets ont la même valeur mais ne sont pas le même objet. L’opérateur == compare les références (adresses) des objets, pas leur contenu. Pour comparer la valeur, il faut utiliser equals() :\nSystem.out.println(new Integer(3).equals(new Integer(3))); // true Question 35 # Quels sont, selon vous, les principaux avantages et inconvénients de Java par rapport à d’autres langages de programmation modernes ?\nRéponse Avantages : portabilité, gestion automatique de la mémoire (garbage collector), vaste écosystème de bibliothèques et frameworks, documentation abondante.\nInconvénients : performances parfois inférieures au code natif (C/C++), syntaxe parfois verbeuse, nécessité d’installer la JVM.\nQuestion 36 # Expliquez ce qu’est un débordement (overflow) lors d’un calcul avec des entiers en Java. Donnez un exemple de code qui provoque un débordement.\nRéponse Un débordement se produit lorsqu’une opération arithmétique dépasse la valeur maximale ou minimale qu’un type peut représenter. Par exemple, un int en Java varie de -2 147 483 648 à 2 147 483 647. Si on additionne 1 à la valeur maximale, on « retourne » à la valeur minimale.\nint max = Integer.MAX_VALUE; System.out.println(max); // 2147483647 System.out.println(max + 1); // -2147483648 (débordement) Question 37 # Comment écrit-on un nombre en notation hexadécimale en Java ? Donnez un exemple et expliquez à quoi cela sert.\nRéponse On utilise le préfixe 0x pour écrire un nombre en hexadécimal. Exemple :\nint x = 0xFF; // 255 en décimal System.out.println(x); // Affiche 255 La notation hexadécimale est utile pour manipuler des valeurs binaires, des couleurs, des adresses mémoire, etc.\nQuestion 38 # Quelle est la valeur de l’expression 0xA + 10 en Java ? Expliquez pourquoi.\nRéponse 0xA représente 10 en décimal, donc 0xA + 10 vaut 20.\nQuestion 39 # Est-ce que -0.0 est égal à 0.0 en Java ?\nRéponse En Java, -0.0 == 0.0 retourne true car la comparaison d’égalité (==) considère ces deux valeurs comme égales selon la norme IEEE 754. Cependant, il existe une différence binaire entre -0.0 et 0.0 (le signe du zéro), ce qui peut être détecté avec certaines méthodes comme Double.doubleToRawLongBits() ou en utilisant 1.0 / -0.0 (qui donne -Infinity), alors que 1.0 / 0.0 donne Infinity.\nQuestion 40 # Comment est représenté -1 en Java ?\nRéponse En Java, les entiers sont représentés en binaire selon le format « complément à deux ». Ainsi, -1 est représenté par une suite de bits où tous les bits sont à 1. Par exemple, pour un int (32 bits), -1 correspond à 0xFFFFFFFF en hexadécimal, soit 32 bits à 1. "},{"id":28,"href":"/inf1220-hugo/docs/modules/module1/ordinateurs/","title":"Les ordinateurs et leurs langages","section":"Module 1: Algorithme et pseudocode","content":" Court historique des langages de programmation # L’idée de programmer des machines remonte au 19e siècle, époque marquée par l’émergence des premières machines de calcul et d’automatisation. Dès 1801, les métiers à tisser Jacquard utilisaient des cartes perforées pour programmer des motifs textiles, préfigurant les concepts de codage. Cependant, c’est au milieu du 19e siècle qu’un jalon historique est posé avec les travaux d’Ada Lovelace (1815-1852) sur la machine analytique de Charles Babbage. Considérée comme la première programmeuse, elle rédigea des notes détaillées incluant un algorithme pour calculer les nombres de Bernoulli, démontrant qu’une machine pouvait exécuter des instructions complexes. Le langage Ada, créé dans les années 1980, rend hommage à cette contribution pionnière.\nL’avènement des ordinateurs modernes dans les années 1940-1950 marque un tournant décisif. Les premiers langages de programmation apparaissent pour répondre aux besoins de calcul scientifique, commercial et logique. Parmi eux, FORTRAN (1954) facilite les calculs scientifiques, LISP (1958) introduit des concepts d’intelligence artificielle et de traitement symbolique, et COBOL (1959) s’impose dans la gestion des données commerciales. Ces langages, bien que rudimentaires comparés aux standards actuels, posent les bases des paradigmes de programmation modernes.\nLe langage ALGOL (Algorithmic Language) est un langage de programmation développé à la fin des années 1950, conçu pour exprimer des algorithmes de manière claire et structurée. Créé par un comité international de chercheurs, dont John Backus et Peter Naur, ALGOL a été introduit avec sa première version, ALGOL 58, suivie par ALGOL 60, qui est devenue la plus influente. Son objectif était de fournir un langage universel pour décrire des algorithmes, à la fois pour la recherche scientifique et l’enseignement, tout en servant de base pour le développement de compilateurs ALGOL se distingue par plusieurs innovations. Il introduit une syntaxe formelle, décrite par la notation de Backus-Naur (BNF), qui permet de définir précisément la structure du langage. Il propose des concepts comme la programmation structurée, avec des blocs de code délimités, des boucles et des conditionnelles bien définies, ainsi que la récursivité. Contrairement à des langages comme FORTRAN, orientés vers le calcul numérique, ALGOL privilégie la lisibilité et la généralité, ce qui en fait un précurseur des langages modernes. Bien qu’ALGOL n’ait pas été largement adopté dans l’industrie, il a eu une influence majeure. Des langages comme Pascal, C et Simula en sont directement inspirés. Simula, en particulier, a étendu ALGOL en y intégrant les concepts de classes et d’objets, posant les bases de la programmation orientée objet. ALGOL reste ainsi une étape clé dans l’histoire de l’informatique, reconnu pour sa rigueur conceptuelle et son impact sur la conception des langages de programmation.\nNotation de Backus-Naur La notation de Backus-Naur (BNF) est une méthode formelle pour décrire la syntaxe d’un langage, qu’il s’agisse de langages de programmation, de protocoles ou de formats de données. Développée par John Backus et Peter Naur pour le langage ALGOL 60, elle définit les règles grammaticales d’un langage de manière précise et concise. BNF utilise des règles de production pour spécifier comment des symboles (terminaux et non-terminaux) peuvent être combinés pour former des constructions valides. Elle est essentielle pour concevoir des compilateurs et des analyseurs syntaxiques.\nSymboles terminaux : Éléments de base du langage, comme des mots-clés, des opérateurs ou des caractères (par exemple, if, +, 1). Symboles non-terminaux : Catégories ou abstractions représentant des structures du langage (par exemple, \u0026lt;expression\u0026gt;, \u0026lt;instruction\u0026gt;). Règles de production : Définissent comment un symbole non-terminal peut être remplacé par une combinaison de terminaux et/ou non-terminaux, sous la forme \u0026lt;symbole\u0026gt; ::= définition. Méta-symboles : BNF utilise ::= pour indiquer une définition et | pour exprimer des alternatives. Une règle s’écrit ainsi :\n\u0026lt;nom_du_symbole\u0026gt; ::= séquence_de_symboles | autre_séquence Le côté gauche (\u0026lt;nom_du_symbole\u0026gt;) est un non-terminal. Le côté droit décrit les combinaisons possibles de terminaux et non-terminaux. Le symbole | sépare les alternatives. Par exemple, pour définir la syntaxe d’un nombre entier (composé de chiffres de 0 à 9) :\n\u0026lt;chiffre\u0026gt; ::= \u0026#34;0\u0026#34; | \u0026#34;1\u0026#34; | \u0026#34;2\u0026#34; | \u0026#34;3\u0026#34; | \u0026#34;4\u0026#34; | \u0026#34;5\u0026#34; | \u0026#34;6\u0026#34; | \u0026#34;7\u0026#34; | \u0026#34;8\u0026#34; | \u0026#34;9\u0026#34; \u0026lt;nombre_entier\u0026gt; ::= \u0026lt;chiffre\u0026gt; | \u0026lt;chiffre\u0026gt; \u0026lt;nombre_entier\u0026gt; \u0026lt;chiffre\u0026gt; est un symbole terminal parmi \u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;, \u0026hellip;, \u0026quot;9\u0026quot;. \u0026lt;nombre_entier\u0026gt; est soit un \u0026lt;chiffre\u0026gt;, soit un \u0026lt;chiffre\u0026gt; suivi d’un autre \u0026lt;nombre_entier\u0026gt; (permettant des nombres comme 42 ou 123). La règle est récursive. BNF permet de définir la syntaxe des langages de manière non ambiguë, facilitant la création d’analyseurs syntaxiques pour les compilateurs. Elle est utilisée pour des formats de données (par exemple, JSON) ou des protocoles réseau. Des variantes comme EBNF (Extended BNF) ajoutent des fonctionnalités comme la répétition ou les expressions optionnelles.\nAu fil des décennies, les langages évoluent pour offrir plus d’abstraction, de flexibilité et d’accessibilité. Dans les années 1980 et 1990, des langages comme C++ (1983), Python (1991), Java (1995), JavaScript (1995) et PHP (1995) voient le jour, chacun répondant à des besoins spécifiques : performance pour C++, simplicité pour Python, portabilité pour Java, interactivité web pour JavaScript, ou développement web dynamique pour PHP. Aujourd’hui, ces langages dominent l’industrie, comme le montre le classement 2017 de l’IEEE Spectrum, qui reflète leur popularité et leur polyvalence.\nTous ces langages partagent un objectif commun : permettre aux programmeurs de décrire des solutions à des problèmes en s’éloignant progressivement des contraintes du matériel. Pour comprendre leur rôle, il est essentiel de se pencher sur le fonctionnement des ordinateurs.\nProgrammation orientée objet # La programmation orientée objet trouve ses origines dans les années 1960 avec le langage Simula, développé en Norvège par Ole-Johan Dahl et Kristen Nygaard. Simula introduit les concepts de classes et d’objets pour modéliser des entités du monde réel, ouvrant la voie à une nouvelle façon de structurer les programmes.\nOle-Johan Dahl et Kristen Nygaard ont développé Simula dans les années 1960 avec pour motivation principale de créer un langage capable de modéliser et de simuler des systèmes complexes du monde réel. Travaillant au Centre de calcul norvégien à Oslo, ils cherchaient à résoudre des problèmes liés à la simulation de processus, notamment dans des domaines comme la recherche opérationnelle et la gestion de systèmes dynamiques. Leur objectif était de concevoir un outil permettant de représenter des entités concrètes (comme des objets physiques ou des processus) et leurs interactions de manière intuitive.\nSimula, initialement conçu comme une extension du langage ALGOL, a introduit les concepts de classes et d’objets pour répondre à ce besoin. Nygaard, en particulier, était motivé par la nécessité de modéliser des systèmes où de multiples entités agissaient simultanément, comme dans les simulations de flux de trafic ou de réseaux de communication. Dahl, quant à lui, apportait une rigueur mathématique pour structurer ces idées dans un cadre formel. Leur vision était de rendre la programmation plus proche de la pensée humaine, en représentant les concepts du monde réel directement dans le code, ce qui a jeté les bases de la programmation orientée objet.\nDans les années 1980, le langage Smalltalk, conçu par Alan Kay et son équipe chez Xerox PARC, popularise la programmation orientée objet en mettant l’accent sur l’interaction entre objets, l’héritage et le message passing. Smalltalk influence profondément la conception des langages modernes.\nAlan Kay a conçu le langage Smalltalk avec son équipe chez Xerox PARC dans les années 1970 pour explorer de nouvelles façons de rendre l’informatique plus accessible, flexible et intuitive. Sa motivation principale était de créer un environnement où les utilisateurs, y compris les enfants, pourraient manipuler des objets graphiques et apprendre à programmer de manière interactive. Il voulait que l’ordinateur devienne un « media personnel », aussi malléable qu’un carnet de notes, permettant l’expérimentation, la simulation et la construction de connaissances.\nSmalltalk a été pensé comme un outil pédagogique, inspiré par les idées de Seymour Papert sur l’apprentissage par la manipulation et la découverte. Alan Kay cherchait à démocratiser la programmation et à rendre le logiciel aussi modulaire et réutilisable que les objets du monde réel, d’où l’accent mis sur les objets, les messages et l’interactivité.\nTranscription traduite en français 0:40 Merci. Eh bien, je présume que la plupart d’entre vous ont veillé toute la nuit. Je n’imagine pas voir autant de programmeurs à huit heures du matin. 0:58 Je suppose que c’est la plus grande salle de bain dans laquelle j’ai jamais donné une conférence. C’était juste un test pour voir si vous pouviez me comprendre. En fait, je ne me comprends pas moi-même ici.\n1:14 Je n’étais pas revenu à cette conférence depuis la première édition. Quand j’ai été invité à donner cette présentation, je me demandais si je devais accepter ou non, et quoi faire. Il m’est venu à l’esprit que cette conférence, à ce moment précis, se situe au cœur du vingt-cinquième anniversaire de Smalltalk.\n1:58 L’interpréteur d’une page que j’ai écrit il y a quelques semaines, il y a vingt-cinq ans, et la première version fonctionnelle, réalisée quelques semaines plus tard, il y a vingt-cinq ans, placent cet événement à peu près au centre. Voyons si je peux afficher notre devise. Puis-je avoir la première diapositive, s’il vous plaît ?\n2:31 Je ne vais pas donner une conférence historique, car j’ai enfin rempli ces obligations lors de la conférence sur l’histoire des langages de programmation il y a quelques années. Mais j’ai pensé qu’il pourrait être intéressant, pour ceux qui n’ont pas programmé ces vingt-cinq ou trente dernières années, de faire un voyage de deux minutes.\n3:00 Ces images remontent à 1973 et 1974 chez Xerox PARC. Elles montrent certains des premiers enfants avec lesquels nous avons travaillé. La musique que vous entendrez dans cet extrait a été composée par un membre de notre groupe, Chris Jeffers. Elle s’appelle The Happy Hacker, au cas où vous voudriez un thème musical. Elle est jouée en synthèse FM en temps réel que nous avons développée pour l’ordinateur Alto.\n3:29 C’est le précurseur des stations de travail et du Macintosh, sans aucun matériel de synthèse sonore supplémentaire, car pourquoi en avoir si votre ordinateur est bien conçu ?\n3:48 Avant de lancer cet extrait, voyons, juste pour le plaisir, combien de personnes dans cette salle aujourd’hui ont participé à l’expérience Smalltalk chez Xerox PARC entre 1971 et 1983 environ. Pouvez-vous vous lever ? Voyons combien nous sommes. Y a-t-il quelqu’un sans cheveux gris ? Merci.\n4:19 Bien, lançons cet extrait.\n5:19 C’était l’état des choses il y a environ vingt-cinq ans. En introduction, j’ai essayé de trouver comment aborder cette conférence. J’ai fini par me souvenir d’un article de Dijkstra. Combien d’entre vous ont rencontré Dijkstra ? Vous savez probablement que l’arrogance en informatique se mesure en nano-Dijkstras.\n5:58 Il a écrit un article intitulé Sur le fait que l’Atlantique a deux rives. Il parlait des différences entre les approches de l’informatique en Europe, surtout aux Pays-Bas, et aux États-Unis. Aux États-Unis, nous n’étions pas assez mathématiques. En Hollande, si vous êtes professeur titulaire, vous êtes nommé par la reine. Il y a beaucoup d’autres distinctions importantes entre ces deux cultures.\n6:44 J’ai écrit une réponse intitulée Sur le fait que la plupart des logiciels dans le monde sont écrits d’un seul côté de l’Atlantique. Avec mon diplôme en mathématiques, j’expliquais que les ordinateurs forment une nouvelle forme de mathématiques. On ne peut pas les juger selon les mathématiques classiques. Ceux qui essaient se livrent à une forme d’autosatisfaction sans s’en rendre compte.\n7:29 C’était une sorte de mathématiques pratiques, un équilibre entre créer des structures cohérentes, bien plus vastes que tout ce que les mathématiques classiques ont jamais envisagé, et gérer les mêmes problèmes que les mathématiques de grande échelle : convaincre qu’on a couvert tous les cas.\n8:00 Un mathématicien nommé Euler a produit vingt gros volumes de spéculations, dont la plupart étaient justes, mais presque toutes ses preuves étaient erronées. De nombreux doctorats en mathématiques au dernier siècle ont consisté à examiner les livres d’Euler, démontrer qu’une preuve était mauvaise, supposer que son intuition était correcte et trouver une preuve plus convaincante. Le débogage existe aussi en mathématiques.\n8:50 Le plus important dans le travail orienté objet ou tout type de programmation, c’est un mélange exquis entre beauté et praticité. Il n’y a aucune raison de sacrifier l’un ou l’autre. Ceux qui le font ne comprennent pas vraiment ce qu’est l’informatique. C’est comme dire que j’ai de grandes idées pour des peintures, mais je vais utiliser un pinceau sans peinture. Mes idées seront représentées par les gestes que je fais sur le papier. Ne dites pas ça à un artiste du vingtième siècle, il pourrait en faire une vidéo et l’exposer dans un musée.\n9:45 J’avais du mal à décider de quoi parler. Les techniciens semblent toujours en savoir tellement. Mais il est intéressant de regarder ce qui se fait dans le monde sous le nom de programmation orientée objet. On m’a montré des morceaux de code très étranges au fil des années, y compris par des universitaires, qui disaient que c’était du code écrit dans un langage orienté objet.\n10:26 J’ai inventé le terme orienté objet, et je peux vous dire que je n’avais pas C++ en tête.\n10:43 J’ai beaucoup des mêmes sentiments à propos de Smalltalk que je vais essayer d’exprimer ici. Il y a une chose vraiment importante à propos de Smalltalk et de certains langages similaires dont nous devrions prêter une attention particulière. Cela n’a presque rien à voir avec la syntaxe ou la bibliothèque de superclasses accumulée, qui sont souvent considérées comme le langage lui-même, comme s’il avait été décrété par des dieux sur l’Olympe.\n11:31 Je veux parler de ma réaction personnelle lorsque j’ai commencé à y réfléchir dans les années 1960. Plutôt que de faire une conférence historique, je vais essayer de voir si ces réactions et intuitions ont encore une place aujourd’hui.\n12:08 Dans les années 1960, les choses étaient très mécaniques. Il y avait un sentiment de mécanisme simple, car les ordinateurs étaient aussi grands que cette salle. Celui sur lequel Ivan Sutherland a créé Sketchpad était l’un des derniers aux États-Unis à avoir son propre toit : c’était le bâtiment lui-même.\n12:38 Mais les programmes étaient assez petits et avaient beaucoup en commun avec leurs ancêtres mathématiques. Une façon de penser à la sémantique des mathématiques basées sur la logique est comme des engrenages qui s’emboîtent. Tout doit s’adapter, et si tout est compatible à la fin, vous obtenez la rotation finale de l’arbre que vous voulez.\n13:14 Une analogie pour ces programmes des années 1960 est une niche pour chien. Prenez des planches au hasard, un marteau, des clous, assemblez-les, et vous avez une structure qui tient debout. Vous n’avez besoin de savoir que planter un clou.\n13:46 Quelqu’un pourrait regarder cette niche et dire : si nous pouvions l’agrandir d’un facteur cent, nous pourrions construire une cathédrale. Une niche de un mètre de haut donnerait un bâtiment de trente étages, ce qui serait impressionnant. On pourrait y accueillir beaucoup de monde.\n14:05 Les charpentiers se mettraient au travail pour agrandir cette niche d’un facteur cent. Mais, en tant qu’ingénieurs et scientifiques, nous savons que lorsqu’on agrandit quelque chose d’un facteur cent, sa masse augmente d’un facteur un million, et sa résistance, qui dépend principalement des sections transversales, n’augmente que d’un facteur dix mille. En agrandissant d’un facteur cent, la structure devient environ cent fois plus faible. Cette niche s’effondrerait en un tas de débris.\n14:48 À ce moment, il y a deux choix. Le plus populaire est de dire que c’était l’objectif depuis le début, d’ajouter plus de débris, de recouvrir de calcaire et de prétendre qu’on voulait faire des pyramides, pas des cathédrales gothiques. Cela explique, je pense, une grande partie de la structure des systèmes d’exploitation modernes.\n15:24 Ou vous pouvez proposer un nouveau concept. Les personnes intéressées par les structures complexes il y a de nombreuses années l’ont fait. Elles ont appelé cela l’architecture, littéralement la conception et la construction d’arches réussies, une interaction non linéaire et non évidente entre des matériaux simples pour obtenir des synergies inattendues et une multiplication des matériaux.\n16:07 Il est remarquable que la quantité de matériaux dans la cathédrale de Chartres, une structure physique énorme, soit inférieure à celle utilisée pour le Parthénon. La raison est que Chartres est presque entièrement faite d’air et de verre. Tout est organisé avec ingéniosité dans une structure magnifique pour que l’ensemble ait beaucoup plus d’intégrité que chacune de ses parties.\n16:37 C’est une autre voie à suivre. Une partie du message de la programmation orientée objet est que, à mesure que la complexité devient plus importante, l’architecture dominera toujours le matériau. Le triste constat est que les gens ne se sont pas intéressés à l’architecture pour sa beauté. Ils commencent à peine à s’y intéresser maintenant, forcés par Internet. C’est assez pathétique.\n17:16 Je vais utiliser une métaphore pour cette conférence, tirée d’un merveilleux livre appelé L’acte de création d’Arthur Koestler. Koestler était un romancier devenu scientifique cognitif à la fin de sa vie. Il a écrit sur ce que pourrait être la créativité. Il a réalisé que l’apprentissage est un acte de création, car quelque chose de nouveau apparaît en vous.\n17:59 Il utilisait la métaphore des pensées comme des fourmis rampant sur un plan, ici un plan rose. Sur un plan rose, vous pouvez avoir des objectifs, choisir des directions, avancer, mais vous êtes toujours dans le contexte rose.\n18:22 Cela signifie que le progrès dans un contexte fixe est presque toujours une forme d’optimisation. Si vous trouvez quelque chose de nouveau, cela ne faisait pas partie des règles ou du contexte du plan rose. Les actes créatifs sortent généralement du contexte initial.\n19:00 Même si vous avez été soigneusement éduqué par vos parents et l’école pendant des années, parfois, sous la douche, en jogging ou dans un moment d’inattention, une idée bleue surgit. Cette chose qui vous intriguait, que vous observiez, apparaît sous un jour complètement différent, comme si c’était autre chose.\n19:33 Koestler disait que la réaction émotionnelle à cela prend trois formes : pour une blague, c’est haha ; pour la science, c’est aha ; pour l’art, c’est ah. Dans chaque cas, quelque chose de similaire se produit. Une blague vous mène sur un chemin, puis révèle qu’il s’agit d’autre chose, provoquant une explosion agressive. La science procure une sensation similaire, souvent accompagnée de rires, car la réponse était juste sous vos yeux, comme une blague. L’art nous rappelle que, quel que soit le contexte dans lequel nous pensons être, il y en a d’autres. L’art nous sort de notre contexte pour nous rendre conscients d’autres contextes.\n20:34 C’est une métaphore simple, voire simpliste, mais elle servira pour cette conférence. Koestler a aussi souligné qu’il faut quelque chose de bleu pour avoir des pensées bleues. Cela échappe souvent à ceux qui se spécialisent à outrance. En se spécialisant, on se met dans un état mental où l’optimisation est à peu près tout ce qu’on peut faire. Il faut apprendre beaucoup de choses différentes pour commencer à entrevoir d’autres contextes.\n21:17 Voici quelques déclics que j’ai eus au fil des ans. L’un d’eux, je pense, vous intéressera, car c’est la forme la plus ancienne connue de ce qu’on appelle l’abstraction de données. Cela remonte à avant 1961. J’étais dans l’Armée de l’Air en 1961, et je l’ai vu à ce moment-là, probablement un an plus tôt.\n21:47 À l’époque, il n’y avait pas vraiment de systèmes d’exploitation. Le Commandement de l’entraînement aérien devait envoyer des bandes magnétiques avec divers types d’enregistrements d’une base aérienne à une autre. La question était de savoir comment gérer tous ces formats, autrefois des images de cartes, qui devenaient plus complexes avec l’arrivée des bandes.\n22:19 Quelqu’un, probablement un engagé, car les officiers ne programmaient pas à l’époque, a eu l’idée suivante : sur la troisième partie de l’enregistrement, on mettra tous les enregistrements de ce type particulier ; sur la partie centrale, toutes les procédures qui savent gérer les formats de cette troisième partie ; et sur la première partie, des pointeurs vers ces procédures. Les dix premiers pointeurs seraient standardisés, comme la lecture, l’écriture des champs et l’impression, avec un vocabulaire standard pour les dix premiers, puis des pointeurs plus spécifiques ensuite.\n23:14 Pour lire une bande en 1961, il suffisait de charger la partie avant d’un enregistrement dans la mémoire centrale et de sauter directement via les pointeurs vers les procédures. Comparez cela à ce que vous devez faire avec HTML sur Internet.\n23:41 HTML sur Internet est un retour à l’âge des ténèbres, car il présuppose qu’un navigateur doit comprendre ses formats. C’est l’une des pires idées depuis MS-DOS. C’est vraiment honteux. Peut-être est-ce ce qui arrive quand des physiciens jouent avec des ordinateurs, je ne suis pas sûr.\n24:13 Nous voyons ce qui arrive à Internet maintenant : il y a deux guerres en cours. Les guerres des navigateurs, qui sont totalement inutiles, sont soit une tentative de démontrer une incompréhension de la construction de systèmes complexes, soit une tentative encore plus grossière de s’approprier du territoire, ce que je suspecte de Microsoft.\n24:42 Vous n’avez pas besoin d’un navigateur si vous suivez ce qu’un sergent d’état-major de l’Armée de l’Air savait faire en 1961. Il suffit de lire, tout devrait voyager avec ce dont il a besoin. Vous n’avez besoin de rien de plus complexe que quelque chose comme X Windows, en mieux, mais vous voulez distribuer toute la connaissance de ces choses.\n25:15 Internet commence à aller dans cette direction, car les gens découvrent des formats HTML de plus en plus complexes et intraitables. C’est une erreur qui se répète à chaque génération, et ce n’est tout simplement pas la bonne façon de faire.\n25:39 Cette programmation était faite avant l’existence des langages de haut niveau dans l’Armée de l’Air. Mais cette approche a été éliminée par COBOL quand ils ont standardisé sur COBOL.\n26:01 Le Sketchpad d’Ivan Sutherland était immensément sophistiqué, presque stupéfiant dans sa conception. C’était un système orienté objet avec une notion réelle de classes et de sous-classes, et un polymorphisme encore plus fort que celui du Commandement de l’entraînement aérien.\n26:43 J’avais vu cette idée trois ou quatre fois, mais ce n’est qu’en essayant de comprendre Simula que j’ai enfin saisi. Nous pensions que c’était censé être un Algol, mais c’était un amas de bandes, le premier Simula, modifié par Case Western Reserve et les inventeurs de Simula, Nygaard et Dahl, en Norvège, distribué avec une documentation incompréhensible en 1966.\n27:19 En essayant de comprendre Simula, peut-être parce qu’une bonne idée étrange vue quatre fois sous différents costumes finit par faire impression, j’ai réalisé quelque chose.\n27:41 Quand vous êtes confronté à quelque chose de nouveau, vous pouvez considérer cet avancement technologique comme une meilleure façon de faire ce que vous faites déjà, et l’utiliser pour continuer sur votre chemin, restant dans le plan rose. Ou vous pouvez dire que ce n’est pas une meilleure version de l’ancien, mais presque une nouvelle chose, et vous demander ce que cette nouvelle chose essaie d’être.\n28:15 Si vous faites cela, il y a une chance d’obtenir un levier incroyable, plutôt que d’optimiser quelque chose qui ne peut pas l’être beaucoup. Simula venait du monde des structures de données et des procédures, avec cette saveur, si vous vouliez le voir ainsi. Mais il avait une manière de lier les états de votre calcul avec des procédures, ce qui était extrêmement utile et bien meilleur que ce qu’on appelait les variables propres dans Algol 60.\n29:02 C’était une façon de le voir. Puis il y avait cette autre question : si c’était presque une nouvelle chose, de quel type de nouvelle chose s’agissait-il ? L’une de mes spécialités universitaires était la biologie moléculaire, avec un intérêt particulier pour la physiologie cellulaire et l’embryologie, aujourd’hui appelée morphogenèse.\n29:27 Le livre Molecular Biology of the Gene venait de sortir en 1965, un ouvrage merveilleux, toujours en impression, bien que les seules mots communs entre cette édition et celle d’aujourd’hui soient probablement les articles comme le ou et. Même le mot gène y est encore, mais il signifie quelque chose de complètement différent maintenant.\n29:58 Dans ce livre, Watson a réalisé le premier essai d’une créature vivante entière, la bactérie E. coli.\n30:20 Si vous regardez à l’intérieur, la complexité est stupéfiante. Ces choses en forme de popcorn sont des molécules de protéines avec environ 5000 atomes. En éliminant les petites molécules comme l’eau, les ions calcium et potassium, qui constituent environ 70 % de la masse, il reste 30 % avec environ 120 millions de composants qui interagissent de manière informationnelle.\n31:06 Chaque composant porte beaucoup d’informations. Une façon simple de voir cela est que ça fonctionne un peu comme Ops5 : il y a une correspondance de motifs, et des choses se produisent si les motifs sont appariés avec succès.\n31:29 L’état impliqué représente environ cent giga-octets. Aujourd’hui, cela équivaut à une centaine d’ordinateurs de bureau, mais c’est toujours impressionnant comme quantité de calcul. Ce qui est peut-être le plus intéressant, c’est que la rapidité de ce calcul rivalise sérieusement avec celle des ordinateurs actuels.\n32:04 Particulièrement en considérant que c’est fait en parallèle. Par exemple, l’une de ces choses de la taille d’un popcorn se déplace de sa propre longueur en deux nanosecondes. Si un atome était de la taille d’une balle de tennis, une de ces molécules de protéines serait de la taille d’une Volkswagen, se déplaçant de sa propre longueur en deux nanosecondes, soit environ 2,4 mètres à notre échelle.\n32:37 Quelqu’un peut-il calculer quelle fraction de la vitesse de la lumière représente un déplacement de 2,4 mètres en deux nanosecondes ? Oui, quatre fois la vitesse de la lumière à cette échelle.\n32:50 Si vous vous demandez pourquoi la chimie fonctionne, c’est à cause de l’agitation thermique incroyablement violente à cette échelle, qu’on ne peut même pas imaginer avec l’aide des ordinateurs. On ne voit rien à l’intérieur de ces choses tant qu’on ne les tue pas, car c’est un flou total d’activité.\n33:16 Dans de bonnes conditions, il ne faut qu’environ 15 à 18 minutes pour qu’une de ces bactéries se duplique complètement. Bien plus est connu aujourd’hui. Ces bactéries, un cinq-centième de la taille des cellules de notre corps, qui ont environ 60 milliards de composants informationnels au lieu de 120 millions, montrent l’ampleur.\n34:05 Nous avons entre 10^12 et 10^13 cellules dans notre corps, peut-être plus. Pourtant, il ne faut que cinquante divisions cellulaires pendant une grossesse de neuf mois pour faire un bébé.\n34:20 En calculant, vous réalisez qu’il n’en faut qu’environ quarante. Les dix puissances supplémentaires sont là car, pendant le processus embryologique, de nombreuses cellules inadaptées à l’organisme sont éliminées. Les choses sont faites par surprolifération, test et élagage selon un plan beaucoup plus vaste.\n34:53 Chacun de nous est intégré dans une biomasse énorme. Pour quelqu’un dont le contexte bleu pourrait être la biologie, un ordinateur ne pourrait pas être considéré comme particulièrement complexe, grand ou rapide.\n35:17 Lent, petit, stupide : voilà ce que sont les ordinateurs. La question est : comment pouvons-nous les amener à réaliser leur destin ?\n35:41 Nous utilisons une forme de technologie que Napoléon utilisait, rappelez-vous les sémaphores à travers la France. Le changement de perspective ici passe de la mécanique à autre chose.\n36:01 Si vous prenez des niches pour chiens, elles ne s’agrandissent pas bien d’un facteur cent. Les horloges non plus. Mais les cellules s’agrandissent non pas d’un facteur cent, mais d’un facteur mille milliards. La question est : comment font-elles, et comment pourrions-nous adapter cette idée pour construire des systèmes complexes ?\n36:34 C’est simple, mais même C++ n’a pas encore compris. Aucune idée n’est si simple et puissante qu’on ne puisse pas la faire mal comprendre par des millions de personnes.\n36:56 Il ne faut absolument pas permettre que l’intérieur de l’un de ces éléments soit un facteur dans le calcul de l’ensemble. Ce n’est qu’une partie de l’histoire. La membrane cellulaire est là autant pour empêcher certaines choses d’entrer que pour retenir certaines choses à l’intérieur.\n37:20 Une grande partie de notre confusion avec les objets vient du problème que, dans notre culture occidentale, nous avons un langage avec des noms et des verbes très durs. Nos mots de processus sont médiocres. Il nous est plus facile de penser à un objet.\n37:42 Je m’excuse profondément depuis vingt ans d’avoir inventé le terme orienté objet, car dès qu’il a été mal appliqué, j’ai réalisé que j’aurais dû utiliser un terme beaucoup plus orienté vers les processus.\n38:05 Les Japonais ont un mot intéressant, ma, qui désigne l’espace entre ce que nous appelons des objets, ce que nous ne voyons pas parce que nous sommes focalisés sur la chose plutôt que sur le processus. En japonais, il y a une manière plus orientée vers les processus de voir comment les choses se relient.\n38:40 On peut le voir à la taille des mots utilisés pour exprimer quelque chose d’important. Ma est très court. Nous devons utiliser des mots comme interstitiel ou pire pour approcher ce dont parlent les Japonais.\n39:00 Cette réalisation ne peut être attribuée à une personne en particulier. Elle est dans les germes de Sketchpad, dans le système de fichiers du Commandement de l’entraînement aérien, et dans Simula.\n39:18 Une fois que vous avez encapsulé de manière à avoir une interface entre l’intérieur et l’extérieur, il est possible de faire en sorte qu’un objet agisse comme n’importe quoi. La raison est simple : ce que vous avez encapsulé est un ordinateur.\n39:40 Vous avez fait quelque chose de puissant en informatique : prendre la chose puissante sur laquelle vous travaillez et ne pas la perdre en partitionnant votre espace de conception. C’est le défaut des langages de données et de procédures.\n39:58 Je pense que la chose la plus pernicieuse à propos de langages comme C++ et Java est qu’ils croient aider le programmeur en ressemblant autant que possible à l’ancien paradigme. En réalité, ils nuisent terriblement au programmeur en rendant difficile la compréhension de ce qui est vraiment puissant dans cette nouvelle métaphore.\n40:21 Les personnes travaillant sur des systèmes de partage de temps l’avaient déjà compris. La thèse de Butler Lampson en 1965 parlait de donner à chaque personne sur un système de partage de temps ce qu’on appelle maintenant une machine virtuelle, quelque chose d’aussi proche que possible de l’ordinateur physique, mais séparé pour chaque utilisateur.\n40:56 UNIX avait cette idée, mais le plus gros problème était qu’un processus UNIX avait une surcharge d’environ deux mille octets juste pour exister. Il était très difficile dans UNIX de laisser un processus UNIX représenter simplement le nombre trois. Vous passiez de trois bits à quelques milliers d’octets, ce qui posait un problème d’échelle.\n41:22 Une grande partie du problème est de décider que la métaphore biologique est celle qui prédominera au cours des vingt-cinq prochaines années, puis de s’y engager suffisamment pour qu’elle soit pratique à tous les niveaux d’échelle dont nous avons besoin.\n41:48 Nous avons un tour que la biologie ne sait pas faire : nous pouvons extraire l’ADN des cellules. Cela permet de traiter la fibrose kystique beaucoup plus facilement qu’aujourd’hui. Les systèmes ont aussi une sorte de fibrose kystique.\n42:07 Pour certains, la fibrose kystique est traitée aujourd’hui en les infectant avec un virus du rhume modifié, provoquant une infection pulmonaire. Le gène défectueux pour la fibrose kystique est dans ce virus, trop faible pour détruire les poumons comme une pneumonie, mais assez fort pour insérer une copie de ce gène dans chaque cellule des poumons.\n42:34 C’est une manière très compliquée de reprogrammer l’ADN d’un organisme une fois qu’il est en marche.\n42:51 Ce qui m’étonne, c’est que nous n’ayons pas vu plus de progrès. Par exemple, une des choses les plus surprenantes pour moi chez ceux qui travaillent sur Internet est que je ne connais personne – et j’espère que quelqu’un viendra me contredire après – qui ait réalisé qu’au minimum, chaque objet devrait avoir une URL.\n43:19 Je crois que chaque objet sur Internet devrait avoir une adresse IP, car cela représente beaucoup mieux les abstractions réelles du matériel physique aux bits.\n43:39 C’est une intuition précoce que les objets sont fondamentalement comme des serveurs. La notion de polymorphisme, autrefois appelée procédures génériques, est une façon de penser aux classes de ces serveurs.\n44:00 Nous n’y avons pas encore vraiment fait face, mais nous devons construire ces choses, et bientôt il faudra les faire croître. Il est facile de faire grandir un bébé de quinze centimètres, il le fait environ dix fois dans sa vie sans jamais s’arrêter pour maintenance. Mais essayez de faire grandir un Boeing 747, et vous faites face à un problème incroyable, car il est dans un monde mécanique simpliste où le seul objectif était de fabriquer l’artefact, pas de le réparer, de le modifier ou de le faire vivre cent ans.\n44:46 Combien de personnes ici utilisent encore un langage qui, dans le système de développement, vous force à développer en dehors du langage, à compiler, recharger et exécuter, même si c’est rapide comme Java Virtual Cafe ? Allez, avouez-le, nous pouvons organiser une réunion sous une tente texane plus tard.\n45:23 Si vous y pensez, cela ne peut être qu’une impasse pour construire des systèmes complexes, où une grande partie de la construction consistera à essayer de comprendre les possibilités d’interopérabilité avec ce qui existe déjà.\n45:45 J’ai joué un rôle mineur dans la conception de l’ARPANET. J’étais l’un des trente étudiants diplômés qui ont participé à des réunions de conception de systèmes pour formuler des principes de conception pour l’ARPANET il y a environ trente ans.\n46:02 L’ARPANET est devenu Internet. Depuis qu’il a commencé à fonctionner autour de 1969 jusqu’à aujourd’hui, il s’est agrandi d’un facteur d’environ cent millions. C’est assez impressionnant, huit ordres de grandeur.\n46:31 D’après ce que je sais, après avoir parlé à Larry Roberts récemment, il n’y a pas un seul atome physique dans l’Internet d’aujourd’hui qui était dans l’ARPANET original, ni une seule ligne de code.\n46:53 Si nous avions eu des mainframes IBM dans l’ARPANET original, cela n’aurait pas été vrai. C’est un système qui s’est agrandi de cent millions, a changé chaque atome et chaque bit, et n’a jamais eu à s’arrêter.\n47:11 C’est la métaphore que nous devons absolument appliquer à ce que nous considérons comme des choses plus petites. C’est pourquoi vos programmes sont si grands, pourquoi ils deviennent des pyramides au lieu de cathédrales gothiques.\n47:40 Voici une autre grande source. Avec Simula, Lisp est certainement le plus grand langage des années 1960, avec autant, sinon plus, d’intuitions profondes.\n48:05 Sur la page 13 de ce livre publié en 1962, il y a une demi-page de code qui est le modèle réflexif de Lisp écrit en lui-même. Tous les détails importants de la sémantique de Lisp et les directives pour créer un interpréteur Lisp sont dans cette demi-page.\n48:29 C’est cet aspect méta-réflexif qui, pour moi, est la chose la plus triste à propos de ce qui arrive à Java. Quand Java est apparu, j’ai pensé qu’il légitimait quelque chose que beaucoup ne croyaient plus depuis longtemps : l’approche des codes intermédiaires multiplateformes, comme nous avions chez Xerox PARC. Ce n’est pas une nouvelle idée, elle remonte aux années 1960.\n49:02 Mais en regardant Java, je me suis dit : comment peuvent-ils espérer survivre à tous les changements, modifications, adaptations et exigences d’interopérabilité sans un système méta, sans même pouvoir charger de nouvelles choses pendant l’exécution ?\n49:37 Le fait que les gens aient adopté cela comme un grand espoir est probablement la chose la plus désolante pour moi, personnellement, depuis MS-DOS. Cela représente un véritable échec de la compréhension de la vue d’ensemble.\n50:00 Cette notion de métaprogrammation peut être vue de différentes manières. Une implémentation particulière fait des choix pragmatiques, qui ne couvriront probablement pas tous les cas avec l’efficacité ou la richesse requise.\n50:32 C’est une connaissance standard en programmation orientée objet : nous encapsulons pour cacher nos désordres, pour avoir différentes manières de traiter les mêmes concepts sans distraire le programmeur. Mais, comme les gens de Lisp et nous chez Xerox PARC l’avons découvert, cela s’applique aussi à la construction du langage lui-même.\n51:03 Plus le langage peut voir ses propres structures, plus vous êtes libéré de la tyrannie d’une seule implémentation. C’est l’une des choses les plus critiques dont très peu de gens se préoccupent de manière pratique.\n51:22 Une des raisons pour lesquelles ces questions méta seront importantes, au point que personne ne pourra les ignorer, est la question de l’interopérabilité sur Internet dans cinq ou dix ans.\n51:40 Je ne crois pas que Microsoft pourra capturer Internet. Il est trop grand, trop de gens y apportent des idées, et les gens seront assez sophistiqués pour réaliser qu’une solution de type IBM ou Microsoft n’est ni nécessaire ni possible.\n52:08 Cela signifie qu’il y aura des dizaines et des dizaines de systèmes d’objets différents, tous avec des sémantiques très similaires mais des détails pragmatiques très différents.\n52:27 Si vous pensez à ce qu’est une URL, un message HTTP, un objet, ou un pointeur orienté objet, il devrait être clair que n’importe quel langage orienté objet peut internaliser ses propres pointeurs locaux vers n’importe quel objet dans le monde, peu importe où il a été créé. C’est tout l’intérêt de ne pas pouvoir voir à l’intérieur.\n53:00 Une interopérabilité sémantique est possible presque immédiatement en adoptant simplement cette position. Cela va tout changer. Des choses comme Java Beans et CORBA ne suffiront pas, car à un moment donné, il faudra commencer à découvrir ce que les objets pensent pouvoir faire.\n53:20 Cela mènera à un langage d’interface universel, qui n’est pas un langage de programmation en soi, mais plutôt un langage de prototypage permettant un échange profond d’informations sur ce que les objets pensent pouvoir faire, et permettant aux objets de faire des expériences avec d’autres objets de manière sûre pour voir comment ils répondent à divers messages. Ce sera crucial à automatiser dans les dix prochaines années.\n53:57 Voici un excellent livre. Combien de personnes l’ont lu ? Quand ils l’ont écrit, je les ai appelés et j’ai dit : c’est le meilleur livre écrit depuis dix ans, mais pourquoi diable l’avoir écrit d’une manière si centrée sur Lisp, si fermée à un club ?\n54:20 Ce livre est très difficile à lire si vous ne connaissez pas la culture Lisp ou la manière dont Scilos est fait. Il contient certaines des intuitions les plus profondes et pratiques sur la programmation orientée objet depuis de nombreuses années. Je vous le recommande vivement.\n54:49 S’il y a des professeurs d’université ici qui veulent remporter le prochain prix Limoge, je le donnerai à quiconque réécrira ce livre pour que la communauté orientée objet générale puisse le comprendre. Ce serait un grand service à l’humanité.\n55:08 Ce qui s’est passé dans la plupart du monde à partir des années 1970, c’est les types de données abstraits, une manière de penser centrée sur l’affectation. Quand j’ai fait cette diapositive, C++ n’était qu’un point à l’horizon. C’était comme MS-DOS : personne ne le prenait au sérieux, car qui tomberait pour une blague pareille ?\n55:55 Mon histoire préférée sur C++ est chez Apple. Il y avait cet système d’exploitation, nommé par une coïncidence remarquable Pink.\n56:06 Ce système avait deux caractéristiques intéressantes. La première, c’est qu’il devait toujours être terminé dans deux ans. Nous connaissons de grands concepteurs de systèmes d’exploitation, et je ne connais aucun bon système d’exploitation réalisé en deux ans, même par des gens dix fois plus intelligents que l’équipe de Pink.\n56:35 L’autre chose, c’est qu’il devait être fait en C++ pour l’efficacité. Ne le faisons pas en Smalltalk, c’est trop lent. Eh bien, permettez-moi de vous dire qu’il n’y a rien de plus inefficace que de passer dix ans sur un système d’exploitation qui ne fonctionne jamais.\n57:01 [Applaudissements]\n57:08 Les pires sont ceux qui semblent fonctionner.\n57:21 Prenons notre plan rose. Voici ma citation préférée de McLuhan : je ne sais pas qui a découvert l’eau, mais ce n’était pas un poisson. Il nous considérait comme les poissons, et l’eau comme nos structures de croyance, notre contexte.\n57:39 Je crois que c’est la cause principale des difficultés dans notre domaine et dans l’humanité en général : adopter un seul point de vue et s’y engager comme à une religion. Cela s’est produit avec Smalltalk.\n58:05 Schopenhauer, philosophe allemand du XIXe siècle, a dit que chaque idée passe par trois étapes. D’abord, elle est dénoncée comme l’œuvre de fous, ce que Swift appelait une confédération d’imbéciles. Ensuite, on remarque qu’elle était totalement évidente depuis le début. Enfin, le dénonciateur initial prétend l’avoir inventée. C’est là qu’elle entre dans sa phase religieuse.\n58:47 Ce qui m’a le plus attristé avec Smalltalk, lorsqu’il est sorti de Xerox PARC, c’est qu’il a cessé de changer à bien des égards. À Xerox PARC, il y a eu quatre versions majeures, complètement différentes, sur environ dix ans, et des dizaines de versions significatives au sein de ces versions.\n59:11 Ce que nous aimions le plus dans Smalltalk, ce n’était pas ce qu’il pouvait faire, mais le fait qu’il était un si bon véhicule pour amorcer la prochaine série d’idées sur la construction de systèmes. Quand Smalltalk est devenu commercial, ce processus s’est pratiquement arrêté.\n59:31 Il y avait un livre, le célèbre Blue Book d’Adèle et Dave, qui contenait le code pour créer des interpréteurs Smalltalk et démarrer ce processus soi-même. Presque personne n’en a profité. Presque aucune université, presque aucune entreprise commerciale.\n59:58 Ce qu’ils ont manqué, c’est, pour moi, la chose la plus profonde que je voudrais vous transmettre aujourd’hui : nous ne savons pas encore concevoir des systèmes. Ne transformons pas ce que nous ne savons pas en religion, pour l’amour de Dieu.\n1:00:05 Ce que nous devons faire, c’est penser, penser et repenser à ce qui est important. Nos systèmes doivent nous permettre d’atteindre les prochains niveaux d’abstraction à mesure que nous les découvrons.\n1:00:24 Ce dont je suis le plus fier à propos de Smalltalk, presque la seule chose dont je suis fier de mon point de vue, c’est qu’il a été si efficace pour se débarrasser de ses versions précédentes, jusqu’à ce qu’il sorte dans ce monde.\n1:00:38 Une des raisons pour lesquelles nous nous sommes à nouveau impliqués dans Smalltalk, après seize ans sans travailler sur les langages de programmation, est que nous avons lancé il y a quelques années un projet appelé Squeak.\n1:00:56 Ce n’est pas une tentative de donner au monde un Smalltalk gratuit, mais un mécanisme d’amorçage pour quelque chose de bien meilleur que Smalltalk. Quand vous jouerez avec Squeak, pensez-y de ce point de vue : détruisez-le en utilisant ses propres mécanismes pour obtenir une version suivante.\n1:01:21 Cherchez les pensées bleues. Je cherchais une façon de conclure cette conférence, car je pourrais continuer indéfiniment. Je me suis souvenu d’une histoire. Je suis organiste, et la plupart des organistes ont un héros nommé E. Power Biggs.\n1:01:49 Il a ravivé l’intérêt pour l’orgue, surtout tel qu’il était joué aux XVIIe et XVIIIe siècles, et a eu une énorme influence sur nous tous, organistes. Un bon ami à moi était son assistant pendant de nombreuses années dans les années 1940 et 1950. Il a maintenant plus de quatre-vingts ans.\n1:02:07 Quand nous l’invitons à dîner, nous le faisons toujours raconter des histoires sur E. Power Biggs. L’orgue que Biggs avait à l’époque pour ses émissions était un petit orgue médiocre, ni poisson ni oiseau, dans un petit musée à Harvard appelé Bush-Reisinger.\n1:02:30 Mais toutes sortes de musiques y étaient jouées. Un jour, cet assistant a dû remplacer Biggs. Il lui a demandé quelle pièce devait être jouée. Biggs a répondu qu’il avait programmé la Pièce héroïque de César Franck.\n1:02:50 Si vous connaissez cette pièce, elle est faite pour les plus grands orgues jamais construits, les plus puissants, dans les plus grandes cathédrales, car c’est une œuvre symphonique pour orgue du XIXe siècle.\n1:03:04 Biggs demandait à mon ami de jouer cela sur ce petit orgue minable. Il a dit : mais comment puis-je jouer ça là-dessus ? Biggs a répondu : joue-le simplement avec grandeur, joue-le avec grandeur.\n1:03:26 La façon de rester avec l’avenir à mesure qu’il avance est de toujours jouer vos systèmes avec plus de grandeur qu’ils ne semblent en avoir maintenant. Merci.\nLa programmation orientée objet se diffuse ensuite dans de nombreux langages : C++ (1983) ajoute l’orienté objet au C, Java (1995) en fait un pilier de sa conception, Python, Ruby, C#, et bien d’autres adoptent ou s’inspirent de ces principes. La programmation orientée objet devient le paradigme dominant dans l’industrie logicielle, car on croit qu\u0026rsquo;elle facilite la modularité, la réutilisation et la maintenance du code.\nAujourd’hui, la programmation orientée objet est enseignée dans la plupart des cursus en informatique et reste au cœur du développement de logiciels complexes, bien qu’elle coexiste avec d’autres paradigmes (fonctionnel, procédural, etc.) dans les langages modernes.\nNotre façon de programmer continuer d\u0026rsquo;évoluer. Aujourd\u0026rsquo;hui, plusieurs des idées fortes de la méthode orientée objet (comme l\u0026rsquo;héritage) sont vues comme parfois trop contraignantes. Néanmoins, les langages populaires comme Python, C#, Java, etc. relèvent de l\u0026rsquo;orienté objet.\nDéfinition. La programmation orientée objet est un paradigme de programmation qui organise le code autour d’« objets » représentant des entités du monde réel ou conceptuel. Chaque objet regroupe des données (attributs) et des comportements (méthodes) et interagit avec d’autres objets via des messages ou des appels de méthodes.\nJava # Java a été créé au début des années 1990 par James Gosling et son équipe chez Sun Microsystems. Le projet, initialement nommé « Oak », visait à développer un langage portable pour les appareils électroniques embarqués. En 1995, le langage est officiellement lancé sous le nom de Java, avec la promesse « écrire une fois, exécuter partout » (Write Once, Run Anywhere), grâce à la machine virtuelle Java (JVM) qui permet d’exécuter le même code sur différentes plateformes.\nJava connaît un succès rapide, d’abord dans le développement d’applets pour le web, puis dans les applications d’entreprise avec la plateforme Java EE. Au fil des années, Java s’impose comme un standard pour le développement de logiciels robustes, portables et sécurisés, aussi bien côté serveur (applications web, systèmes bancaires, etc.) que côté client (applications de bureau, Android).\nLe langage évolue régulièrement : Java 5 introduit les génériques et les annotations, Java 8 apporte les expressions lambda et l’API Stream, Java 9 les modules, et les versions récentes (Java 17, 21…) continuent d’ajouter des fonctionnalités modernes (pattern matching, records, virtual threads…).\nEn 2010, Oracle rachète Sun Microsystems et devient le principal responsable du développement de Java. Aujourd’hui, Java reste l’un des langages les plus utilisés au monde, soutenu par une vaste communauté et de nombreux outils open source. Il est omniprésent dans l’industrie, l’enseignement, le développement mobile (Android), le cloud et l’Internet des objets.\nLe langage Java est en pleine évolution. Certaines des techniques enseignées dans notre cours ne fonctionnent pas avec des versions précédentes du Java.\nVersion Changement principal Année de sortie JDK 1.0 Lancement initial 1996 JDK 1.1 Classes internes 1997 J2SE 1.2 API Swing 1998 J2SE 1.3 Améliorations HotSpot 2000 J2SE 1.4 Assertions 2002 J2SE 5.0 Génériques 2004 Java SE 6 Performance JVM 2006 Java SE 7 Syntaxe try-with-resources 2011 Java SE 8 Expressions lambda 2014 Java SE 9 Système de modules 2017 Java SE 10 Inférence de types 2018 Java SE 11 Client HTTP standard 2018 Java SE 12 Switch expressions 2019 Java SE 13 Blocs de texte 2019 Java SE 14 Records (aperçu) 2020 Java SE 15 Classes scellées 2020 Java SE 16 Records finalisés 2021 Java SE 17 Pattern matching 2021 Java SE 18 API vectorielle (aperçu) 2022 Java SE 19 Threads virtuels 2022 Java SE 20 Structured Concurrency 2023 Java SE 21 Sequenced Collections 2023 Java SE 22 Foreign Function API 2024 Java SE 23 Module import simplifié 2024 Java SE 24 Améliorations Loom 2025 Java SE 25 Finalisation Valhalla 2025 Java SE 26 Optimisations Leyden 2026 Vidéo (optionnelle) :\nRésumé de l’architecture des ordinateurs et de l’abstraction des langages # Tous ces langages partagent un objectif commun : permettre aux programmeurs de décrire des solutions à des problèmes en s’éloignant progressivement des contraintes du matériel. Pour comprendre leur rôle, il est essentiel de se pencher sur le fonctionnement des ordinateurs.\nLes ordinateurs modernes s’appuient sur deux concepts fondamentaux : la machine de Turing, théorisée par Alan Turing, qui définit une machine capable d’exécuter n’importe quel algorithme, et l’architecture de von Neumann, qui structure les ordinateurs autour de quatre composantes principales. Premièrement, la mémoire stocke à la fois les données et les programmes, une innovation clé par rapport aux machines antérieures où les instructions étaient fixes. Deuxièmement, l’unité de contrôle orchestre l’exécution des instructions en suivant un séquençage précis. Troisièmement, l’unité arithmétique et logique effectue les calculs de base, comme les additions ou les comparaisons. Enfin, les interfaces d’entrée/sortie permettent d’interagir avec l’utilisateur ou d’autres systèmes, via des périphériques comme les claviers, écrans ou réseaux.\nDans un langage plus accessible, un ordinateur contemporain se compose de processeurs (CPU), de mémoire vive (RAM) pour les calculs temporaires, de stockage à long terme (disques durs ou SSD), de processeurs graphiques (GPU) pour le rendu visuel, et de cartes d’entrée/sortie pour la connectivité. La carte mère agit comme un chef d’orchestre, coordonnant les échanges entre ces éléments. Par exemple, lorsqu’un programme s’exécute, le CPU lit les instructions depuis la RAM, effectue les calculs nécessaires, et envoie les résultats vers la mémoire ou un périphérique de sortie, comme un écran.\nLes processeurs se déclinent en plusieurs architectures. Dans les ordinateurs personnels, les puces x64 (ou x86-64), produites par Intel et AMD, dominent grâce à leur puissance et leur compatibilité. Dans les appareils mobiles, comme les smartphones, les processeurs ARM, plus économes en énergie, sont privilégiés. La mémoire vive repose sur la technologie DRAM, rapide mais volatile, tandis que le stockage à long terme utilise majoritairement la mémoire flash, comme dans les SSD, pour sa rapidité et sa fiabilité.\nLes langages de programmation jouent un rôle crucial en traduisant des instructions humaines en commandes compréhensibles par ces composants matériels. Leur niveau d’abstraction varie : les langages de bas niveau, comme l’assembleur, sont proches du matériel et offrent un contrôle précis mais exigent une expertise technique. À l’opposé, les langages de haut niveau, comme Python ou Java, simplifient le développement en masquant les détails matériels, ce qui les rend plus accessibles et adaptés à des applications complexes, comme le développement web ou l’intelligence artificielle.\nDans ce cours, nous explorerons le langage Java, largement adopté dans l’industrie pour sa portabilité, sa robustesse et sa polyvalence. Utilisé dans des domaines variés, des applications mobiles Android aux systèmes d’entreprise, Java illustre parfaitement comment un langage de haut niveau peut répondre à des besoins modernes tout en s’appuyant sur les principes fondamentaux de l’informatique.\nAPI # Le terme API signifie « Application Programming Interface » (interface de programmation d’application). Une API est un ensemble organisé de classes, de méthodes et de conventions qui permet à des développeurs d’utiliser facilement des fonctionnalités sans avoir à connaître les détails internes de leur implémentation. En Java, on parle souvent de l’API standard (Java Standard Library), qui regroupe des milliers de classes prêtes à l’emploi pour manipuler des chaînes de caractères, des fichiers, des collections, des dates, des flux de données, etc.\nPar exemple, l’API Stream introduite en Java 8 fournit des outils puissants pour traiter des collections de données de façon déclarative et fonctionnelle (filtrer, transformer, trier, agréger…). L’API Swing permet de créer des interfaces graphiques, l’API JDBC permet d’accéder à des bases de données, etc. Chaque API définit un « contrat » : si vous respectez la façon d’utiliser ses classes et méthodes, vous pouvez profiter de fonctionnalités avancées sans réinventer la roue.\nEn résumé, une API est une boîte à outils logicielle, conçue pour être utilisée par d’autres développeurs, qui facilite l’accès à des fonctionnalités complexes (réseau, interface graphique, traitement de données, etc.) tout en masquant les détails techniques.\nUnités de mesures # Les ordinateurs et leurs composants sont caractérisés par différentes unités de mesure :\nFréquence (vitesse du processeur) # Hertz (Hz) : unité de fréquence, correspond à un cycle par seconde. Kilohertz (kHz) : 1 000 Hz. Mégahertz (MHz) : 1 000 000 Hz (un million de cycles/seconde). Gigahertz (GHz) : 1 000 000 000 Hz (un milliard de cycles/seconde). La fréquence d’un processeur (ex : 3,2 GHz) indique combien d’opérations il peut effectuer par seconde.\nTemps # Seconde (s) : unité de base du temps. Milliseconde (ms) : 1/1 000 de seconde (\\(10^{-3}\\) s). Microseconde (µs) : 1/1 000 000 de seconde (\\(10^{-6}\\) s). Nanoseconde (ns) : 1/1 000 000 000 de seconde (\\(10^{-9}\\) s). Les temps d’accès à la mémoire ou d’exécution d’instructions sont souvent mesurés en nanosecondes ou microsecondes.\nStockage et mémoire # Octet (B) : unité de base, correspond à 8 bits. Kilooctet (ko) : 1 000 octets (notation décimale, SI). Mégaoctet (Mo) : 1 000 000 octets. Gigaoctet (Go) : 1 000 000 000 octets. Téraoctet (To) : 1 000 000 000 000 octets. Kibioctet (Kio) : 1 024 octets (\\(2^{10}\\)). Mebioctet (Mio) : 1 048 576 octets (\\(2^{20}\\)). Gibioctet (Gio) : 1 073 741 824 octets (\\(2^{30}\\)). Remarque : Les systèmes d’exploitation et les fabricants utilisent parfois les préfixes kilo, méga, giga pour désigner soit des puissances de 10 (décimal), soit des puissances de 2 (binaire). Par exemple, 1 Go peut désigner 1 000 000 000 octets (décimal) ou 1 073 741 824 octets (binaire). Les préfixes Kio, Mio, Gio sont utilisés pour lever cette ambiguïté.\nCes unités sont essentielles pour comprendre les performances, la capacité de stockage et la rapidité des ordinateurs modernes.\nLa vitesse de la lumière dans le vide est d’environ 299 792 458 mètres par seconde (environ 300 000 km/s). C’est la vitesse maximale à laquelle l’information ou l’énergie peut se déplacer dans l’univers selon la physique moderne. La lumière parcourt environ 29,98 centimètres (soit presque 30 cm) en une nanoseconde dans le vide. Autrement dit, en une nanoseconde (1 ns = 10⁻⁹ seconde), la lumière se déplace d’environ 30 cm.\nBinaire # Les ordinateurs fonctionnent en binaire, c’est-à-dire qu’ils ne manipulent que deux états possibles : 0 et 1. Cette représentation repose sur le système de numération binaire, où chaque chiffre (bit) correspond à une puissance de 2. Un bit (binary digit) est l’unité d’information la plus petite : il peut valoir 0 ou 1.\nUn groupe de 8 bits forme un octet (byte), qui permet de représenter 256 valeurs différentes (de 0 à 255). Les ordinateurs stockent et traitent toutes les données (nombres, texte, images, sons) sous forme de suites de bits. Par exemple, le nombre décimal 5 s’écrit 101 en binaire :\n1 × 2² + 0 × 2¹ + 1 × 2⁰ = 4 + 0 + 1 = 5 Voici quelques exemples de conversion :\nDécimal Binaire 0 0000 1 0001 2 0010 3 0011 4 0100 5 0101 6 0110 7 0111 8 1000 9 1001 Chaque bit supplémentaire double le nombre de valeurs possibles. Ainsi, avec n bits, on peut représenter 2ⁿ valeurs différentes.\nUtilisez l\u0026rsquo;application suivante pour explorer la représentation binaire. Observez comment, par convention, le bit le plus à gauche est le plus significatif. Que remarquez-vous au sujet des puissances de deux comme 2, 4, 8 ?\nManipulateur de 8 bits Valeur binaire: 00000000\nValeur décimale: 0\nPourquoi le binaire ? # Le choix du binaire s’explique par la simplicité de la technologie électronique : il est facile de concevoir des circuits qui distinguent deux états (tension présente ou absente, aimantation positive ou négative, etc.). Cela rend les ordinateurs plus fiables et moins sensibles au bruit que s’ils utilisaient plus de deux états.\nLes ordinateurs effectuent des opérations logiques (ET, OU, NON, OU exclusif) directement sur les bits. Ces opérations sont à la base de tous les calculs et traitements informatiques.\n"},{"id":29,"href":"/inf1220-hugo/docs/modules/module3/activite-3-3/","title":"Les structures de données de base","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" Les structures de données de base # Le langage Java possède toutes les stuctures de données nécessaires. Faisons-en rapidement le tour. En Java, les types de données sont organisés en deux grandes catégories : les types primitifs et les types référence. Les types primitifs, tels que int, double, float, long, short, byte, char et boolean, sont des types de base qui stockent directement des valeurs simples et ne sont pas des objets. Chaque type primitif possède une classe enveloppe correspondante (par exemple, Integer pour int, Double pour double) dans la catégorie des classes enveloppes. Ces classes permettent de représenter les primitifs sous forme d’objets, offrant des fonctionnalités supplémentaires comme l’utilisation dans des collections ou la conversion entre types.\nLes types référence, quant à eux, incluent les objets tels que String, StringBuilder, ArrayList, HashMap, HashSet, PriorityQueue et Stack. Ces types, qui font partie des classes Java, sont utilisés pour manipuler des données complexes. Les classes enveloppes appartiennent également aux types référence, car elles sont des objets. Les types référence comme ArrayList et HashMap sont des collections génériques capables de stocker d’autres objets, y compris des instances de classes enveloppes ou d’autres types référence. Cette organisation permet une gestion flexible des données, avec des relations où les types primitifs sont enveloppés par leurs classes correspondantes, et les types référence servent de conteneurs ou de structures pour organiser et manipuler ces données.\nLes structures de données sont organisées en packages. Les packages en Java permettent d’organiser le code de manière modulaire et hiérarchique. Un package est un espace de noms qui regroupe des classes, des interfaces et d’autres ressources connexes, facilitant la gestion des projets complexes. Par exemple, le package java.util contient des classes utilitaires comme ArrayList ou Scanner. En utilisant des packages, les développeurs évitent les conflits de noms et améliorent la lisibilité du code. Pour déclarer un package, on utilise le mot-clé package au début d’un fichier source, suivi du nom du package, comme package com.exemple.monprojet. Les packages reflètent généralement la structure des répertoires du projet.\nL’instruction import en Java sert à accéder aux classes, interfaces ou membres statiques définis dans d’autres packages. Sans import, il faudrait utiliser le nom complet d’une classe, comme java.util.ArrayList, ce qui rendrait le code verbeux. Par exemple, import java.util.ArrayList; permet d’utiliser directement ArrayList dans le code. Java propose également l’importation de packages entiers avec import java.util.*;, bien que cela puisse alourdir la compilation dans de grands projets. Les importations doivent être placées après la déclaration du package, mais avant la définition de la classe.\nIl existe des règles spécifiques pour les importations. Les classes du package java.lang, comme String ou System, sont automatiquement importées, donc aucune instruction import n’est nécessaire. De plus, l’ordre des importations suit une convention : d’abord les packages Java standards, puis les packages tiers, et enfin les packages du projet. Les importations statiques, introduites avec import static, permettent d’accéder directement aux membres statiques d’une classe, comme import static java.lang.Math.PI;, pour utiliser PI sans qualifier la classe. Une bonne gestion des packages et des importations est essentielle pour un code Java clair et maintenable.\nLe diagramme suivant résume l\u0026rsquo;organisation des types que vous allez découvrir.\nclassDiagram %% Categories as containers class Types_Primitif { int double float long short byte char boolean } class Classes_Enveloppes { Integer Double Float Long Short Byte Character Boolean } class Tableaux { int[] Integer[] Float[] String[] int[][] } class Types_Reference { String StringBuilder ArrayList HashMap HashSet PriorityQueue Stack } Classes_Enveloppes --\u003e Types_Reference : fait partie de Tableaux --\u003e Types_Reference : fait partie de %% Relationships Types_Primitif --\u003e Classes_Enveloppes : enveloppe %% Reference Types relationships Types_Reference --\u003e ArrayList : stocké dans Types_Reference --\u003e HashMap : stocké dans Allocation de mémoire et ramasse-miettes # Lorsque vous créez un objet en Java, la mémoire nécessaire est automatiquement allouée dans une zone appelée le « tas » (heap). Contrairement à certains langages comme C ou C++, il n’est pas nécessaire de libérer explicitement la mémoire des objets qui ne sont plus utilisés. Java intègre un mécanisme appelé ramasse-miettes (ou garbage collector) qui se charge de détecter et de libérer automatiquement la mémoire occupée par les objets devenus inaccessibles. Il partage cette caractéristique avec d\u0026rsquo;autres langages comme C#, JavaScript et Python.\nLe ramasse-miettes fonctionne en arrière-plan : il identifie les objets qui ne sont plus référencés par aucune variable ou structure de données, puis récupère la mémoire correspondante pour la rendre disponible à de nouveaux objets. Cela simplifie la gestion de la mémoire et réduit les risques de fuites de mémoire (memory leaks) ou d’erreurs de libération (comme les double free en C).\nCependant, il est important de comprendre que la libération de la mémoire n’est pas instantanée : le ramasse-miettes intervient à des moments choisis par la machine virtuelle Java (JVM), ce qui peut parfois entraîner de légères pauses dans l’exécution du programme. Pour la plupart des applications, ce fonctionnement automatique est un avantage, car il permet de se concentrer sur la logique du programme sans se soucier de la gestion manuelle de la mémoire.\nL’allocation de mémoire en Java est automatique et la libération est assurée par le ramasse-miettes, ce qui contribue à la robustesse et à la sécurité des programmes Java.\nPar contre, le ramasse-miettes a des inconvénients : il peut provoquer des pauses imprévisibles dans l’exécution du programme, appelées « pauses de collecte », lorsque la JVM décide de libérer la mémoire. Ces pauses sont généralement courtes, mais peuvent devenir perceptibles dans des applications nécessitant une grande réactivité (jeux, systèmes temps réel, etc.). De plus, le développeur a moins de contrôle sur le moment précis où la mémoire est libérée, ce qui peut compliquer l’optimisation des performances dans certains cas particuliers. Enfin, le ramasse-miettes consomme lui-même des ressources processeur, ce qui peut avoir un effet sur l’efficacité globale du programme.\nMalgré l\u0026rsquo;existence du ramasse-miettes, il faut donc tenter de minimiser l\u0026rsquo;allocation de mémoire. Il faut éviter de créer des objets temporaires quand on peut réutiliser un objet déjà alloué.\nString # En Java, le type String représente une séquence de caractères. Il est très utilisé pour manipuler du texte : noms, messages, fichiers, etc. Une particularité essentielle à comprendre est que les objets de type String sont immuables : une fois créés, ils ne peuvent pas être modifiés. Toute opération qui semble modifier une chaîne (comme la concaténation, le remplacement ou la suppression de caractères) crée en réalité un nouvel objet String en mémoire, sans changer l’original.\nPar exemple :\nString s = \u0026#34;Bonjour\u0026#34;; s = s + \u0026#34; le monde\u0026#34;; // Crée un nouvel objet String Ici, la chaîne \u0026ldquo;Bonjour\u0026rdquo; n’est pas modifiée : une nouvelle chaîne \u0026ldquo;Bonjour le monde\u0026rdquo; est créée et la variable s pointe vers ce nouvel objet. L’ancienne chaîne reste inchangée (et sera éventuellement libérée par le ramasse-miettes).\nCette immuabilité rend les String sûres et efficaces pour le partage, mais peut entraîner des problèmes de performance si on fait beaucoup de modifications : dans ce cas, il vaut mieux utiliser StringBuilder.\nEn Java, les chaînes de caractères (String) sont représentées en mémoire selon l’encodage UTF-16. Cela signifie que chaque élément du tableau interne d’une chaîne est un « code unit » de 16 bits (un char Java), mais tous les caractères Unicode ne tiennent pas forcément dans un seul char.\nL’UTF-16 est un encodage qui permet de représenter tous les caractères Unicode. La plupart des caractères courants (latin, accentués, etc.) sont codés sur un seul char (16 bits), mais certains caractères spéciaux ou emojis, appelés « supplémentaires », nécessitent deux char consécutifs (appelés une paire de substitution ou surrogate pair).\nLa méthode charAt(int index) retourne le char à la position donnée dans la chaîne, mais ce char ne correspond pas toujours à un caractère complet pour l’utilisateur. Si la chaîne contient un caractère supplémentaire (hors du plan multilingue de base), charAt peut retourner seulement une partie de ce caractère (un des deux éléments de la paire de substitution).\nPour manipuler correctement les caractères Unicode, il faut utiliser les méthodes codePointAt, codePoints() ou les classes de l’API Character, qui tiennent compte des paires de substitution et permettent de traiter chaque caractère Unicode comme une entité logique.\nString s = \u0026#34;A😊B\u0026#34;; System.out.println(s.length()); // Affiche 4 (car 😊 occupe deux char) System.out.println(s.charAt(1)); // Affiche un char de la paire surrogate, pas le smiley complet System.out.println(s.codePointAt(1));// Affiche le code Unicode complet du smiley Ainsi, il faut être vigilant lors du traitement de chaînes contenant des emojis ou des caractères spéciaux, car la longueur d’une chaîne (length) et l’accès par charAt ne correspondent pas toujours au nombre réel de caractères.\nUtilisez l\u0026rsquo;application suivante pour explorer la représentation des chaînes de caractères en format UTF-16.\nAllo la 🌍! StringBuilder # Le type StringBuilder en Java permet de construire et de modifier efficacement des chaînes de caractères. Contrairement à la classe String, qui est immuable (chaque modification crée un nouvel objet), StringBuilder permet d’ajouter, de modifier ou de supprimer des caractères sans créer de nouveaux objets à chaque opération. Cela le rend particulièrement utile lorsqu’on doit faire de nombreuses modifications ou concaténations de chaînes, par exemple lors de la lecture d’un fichier ou la construction dynamique d’un texte.\nL’utilisation de StringBuilder améliore considérablement les performances, surtout dans les boucles : concaténer des chaînes avec + dans une boucle crée à chaque fois une nouvelle chaîne, ce qui consomme beaucoup de mémoire et ralentit le programme. StringBuilder évite ce problème en travaillant sur une seule zone mémoire.\nExemple :\nStringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; 5; i++) { sb.append(\u0026#34;Ligne \u0026#34;).append(i).append(\u0026#34;\\n\u0026#34;); } String resultat = sb.toString(); System.out.println(resultat); Dans cet exemple, toutes les lignes sont ajoutées efficacement à la même chaîne. Pour des opérations répétées ou sur de gros volumes de texte, StringBuilder est donc le choix recommandé pour de bonnes performances.\nCharSequence et subSequence() # L’interface CharSequence représente une séquence de caractères lisible : elle est implémentée par plusieurs classes Java comme String, StringBuilder et StringBuffer. Cela permet d’écrire des méthodes qui acceptent n’importe quel type de séquence de caractères, et pas seulement des chaînes immuables.\nLa méthode subSequence(int start, int end) permet d’obtenir une portion (sous-séquence) de la séquence de caractères, allant de l’indice start (inclus) à end (exclu). C’est utile pour extraire une partie d’un texte sans créer une nouvelle chaîne si ce n’est pas nécessaire.\nExemple avec String :\nString texte = \u0026#34;Bonjour le monde\u0026#34;; CharSequence sousTexte = texte.subSequence(8, 14); // \u0026#34;le mon\u0026#34; System.out.println(sousTexte); Exemple avec StringBuilder :\nStringBuilder sb = new StringBuilder(\u0026#34;abcdefg\u0026#34;); CharSequence sousSeq = sb.subSequence(2, 5); // \u0026#34;cde\u0026#34; System.out.println(sousSeq); Utiliser CharSequence rend le code plus flexible : on peut manipuler des chaînes, des buffers ou des builders de la même façon, et extraire facilement des sous-parties avec subSequence(). La méthode subSequence évite de faire une copie inutile.\nLes tableaux et matrices # Jusqu'à présent, lorsque nous avons créé une variable, elle ne contenait qu'une seule donnée qui pouvait être une donnée primitive ou une référence vers un objet. En effet, dans la programmation orientée objet, certaines structures ont un nombre fixe d'objets : il s'agit des tableaux. Il en existe deux types : les tableaux à une dimension et les matrices à deux ou trois dimensions.\nLes tableaux (array en anglais) sont très courants en programmation, car ils permettent d'organiser les données. À partir du moment où nous devons concevoir un programme devant manipuler un grand nombre de données, il devient intéressant pour nous de les rassembler dans des tableaux. Par exemple, pour un programme chargé d'organiser les nom et prénom des étudiants d'un cours, il ne serait pas efficace de déclarer une variable de type String pour chaque étudiant, car cela serait trop long. Par contre, les tableaux pourront nous aider à accélérer ce travail.\nIndices # Un tableau est donc une liste de valeurs. Chacune d'entre elles est stockée dans le tableau à une position bien précise, appelée indice. Le tableau ci-dessous, nommé salaires, contient des nombres entiers. En Java, la première position dans le tableau est celle de l'indice 0. Le tableau des salaires possède 11 valeurs dont les indices vont de 0 à 10.\n12 74 88 22 8 78 28 44 47 78 81 Valeurs 0 1 2 3 4 5 6 7 8 9 10 Indices Pour accéder à une valeur du tableau, nous utilisons le nom du tableau suivi de l'indice entre crochets. Par exemple, pour accéder au cinquième salaire du tableau, il suffit d'écrire : salaire [4]. La valeur sera donc 8. L'expression salaire [4] a donc comme valeur 8. L'indice d'un tableau est un simple entier, il est donc possible d'utiliser des variables ou constantes entre crochets comme dans l'exemple ci-dessous :\n// Tableau avec une pré-déclaration int[] salaire = {12, 74, 88, 22, 8, 78, 28, 44, 47, 78, 81}; System.out.println(salaire[4]); Déclarer et utiliser les tableaux # En Java, les tableaux sont des objets; donc, pour créer un nouveau tableau, il faudra utiliser l'opérateur new. La ligne de code suivante permet de créer un tableau de salaire horaire des 10 employés d'une entreprise.\nint[] salaire = new int[10]; Cela signifie simplement que nous déclarons une variable dont le nom est salaire, dont le type est int[] (tableau d'entiers de type primitif int). Dans le cas de tableaux contenant des nombres en utilisant des types de base (int, float, etc.), le contenu du tableau est initialisé avec des valeurs équivalent au zéro. Nous assignons ensuite un nouvel objet à cette variable. L'objet est un tableau de 10 entiers (int [10]). Il est donc à remarquer qu'un tableau contient plusieurs valeurs qui doivent toutes avoir le même type. Nous ne pourrions pas créer un tableau qui contiendrait des int et des double par exemple. De plus, la taille du tableau étant décidé et fixée lors de la déclaration, elle ne pourra pas changer. Nous avons par conséquent un tableau statique (rien à voir avec les classes statiques ou le mot réservé static).\nMain.java public class Main { public static void main(String[] args) { final int MAX = 10; int[] list = new int[MAX]; // Remplit le tableau for (int i = 0; i \u0026lt; MAX; i\u0026#43;\u0026#43;) { list[i] = i * 20; } // On change la quatrième valeur list[3] = 777; // On affiche le contenu du tableau for (int i = 0; i \u0026lt; MAX; i\u0026#43;\u0026#43;) { System.out.print(list[i] \u0026#43; \u0026#34; \u0026#34;); } } } Exécuter Le résultat de l'exécution donnera ceci :\n0 20 40 777 80 100 120 140 160 180 Cet exemple montre également une bonne utilisation des constantes. En effet, si nous voulons un tableau de taille 15, il n'y a qu'une ligne de code à changer, à savoir la valeur de la constante MAX. Les crochets utilisés pour accéder à un élément d'un tableau sont un opérateur Java comme + ou =. Cet opérateur a la plus haute priorité et sera donc exécuté en premier. L'opérateur d'indexation de tableau ([]) vérifie automatiquement si l'indice est correct, c'est-à-dire s'il est positif et est plus petit que la taille du tableau - 1. Si tel n'est pas le cas, il se produira une erreur d'exécution.\nint[] tableau = new int[2]; tableau [0] = 0; tableau [1] = 1; System.out.println (tableau [1]); //Appel dans un index hors du tableau System.out.println (tableau [2]); Erreur d'indice L'exécution de ce code produira la sortie suivante à la console :\njava.lang.ArrayIndexOutOfBoundsException: 2 at Test.main(Test.java:18) Exception in thread \"main\"\nÉtant donné que le premier indice est de 0, il arrive souvent des erreurs d'indice trop élevé d'une position. Le programmeur doit donc être vigilant et s'assurer que les indices restent dans les limites du tableau. La taille d'un tableau est régie par une variable d'instance de l'objet tableau appelée length. Donc, pour connaître la taille d'un tableau, il suffit de consulter le contenu de cette variable à l'aide de l'opérateur d'accès point.\nint[] tableau = new int[5]; System.out.println (tableau.length); // Affiche 5 à la console Instanciation d\u0026rsquo;un tableau # Nous pouvons instancier autrement un tableau. Il suffit de donner directement les valeurs qu'il contient. Nous affecterons une liste d'initialisation ou initialisateur au tableau. Les éléments du tableau sont repris entre des accolades et séparés par des virgules. Par exemple, pour créer le tableau ci-dessous, nous pourrions écrire :\nint[] tableau = {20, 17, 21, 19, 18, 20}; Initialisateur # Nous ne pouvons utiliser une liste d\u0026rsquo;initialisation que pour la première déclaration. De plus, il faut impérativement la combiner avec la déclaration de la variable. Il est impossible de le faire en deux étapes. Par exemple, le code ci-dessous produit une erreur de compilation.\nint[] tab = new int[3]; tab = {1, 2, 3}; Initialisateur : erreur de compilation java.lang.Error: Unresolved compilation problem: Array constants can only be used in initializers Passer des tableaux en paramètre # Nous pouvons passer un tableau complet en paramètre à une méthode, car les tableaux ne sont rien d'autre que des objets. Il ne faut donc pas oublier que ce qui sera donné à la méthode n'est pas le tableau, ni une copie de celui-ci mais bien une copie de la référence vers le tableau. Nous pouvons bien entendu passer en paramètre un seul élément d'un tableau. S'il s'agit d'une donnée primitive, une copie de celle-ci sera passée en paramètre. S'il s'agit d'un objet, une copie de la référence sera passée en paramètre. La méthode ci-dessous déplace tous les éléments du tableau d'une position vers la droite.\npublic class AfficheDeplacer { public static void main(String[] args) { int[] tableau = {11, 22, 33, 44}; print(tableau); deplacerADroite(tableau); print(tableau); } private static void deplacerADroite(int[] tableau) { int last = tableau[tableau.length - 1]; for (int i = tableau.length - 1; i \u0026gt; 0; i--) { tableau[i] = tableau[i - 1]; } tableau[0] = last; } private static void print(int[] tableau) { for (int i = 0; i \u0026lt; tableau.length; i++) { System.out.print(tableau[i] + \u0026#34; \u0026#34;); } System.out.println(); } } Tableaux d\u0026rsquo;objets # Dans tous les exemples que nous avons vus jusqu'à présent, les tableaux contenaient uniquement des types primitifs. Dans la dernière partie de la section précédente, nous avons vu des tableaux qui pouvaient contenir des objets, ou plus précisément des références vers des objets. Il est possible de stocker des objets dans un tableau. La ligne de code suivant crée un tableau de 20 objets de type String.\nString[] phrases = new String[20]; Quelques techniques utiles # Nous sommes maintenant davantage en mesure de comprendre la signature de la méthode main. Nous voyons en paramètre un tableau de String. En réalité, lorsque nous lançons un programme Java, nous savons déjà que la méthode main sera automatiquement appelée, mais qu'il est possible de lui passer des paramètres. En fait, nous pouvons lui passer un tableau de String. Nous donnons en fait à la méthode main une chaîne de caractères qui sera découpée en morceaux délimités par des espaces. Il est ensuite possible d\u0026rsquo;utiliser ces paramètres dans la méthode, comme l\u0026rsquo;illustre le programme suivant :\npublic static void main(String[] args) { if (args.length != 0) { System.out.println(args[0]); } else { System.out.println(); System.out.println(\u0026#34;Aucun argument sur la ligne de commande\u0026#34;); } } Trier un ensemble de données # L'atout principal de l'ordinateur est sa capacité de traiter très rapidement une immense quantité de données (par exemple, la recherche d'éléments dans un ensemble selon des contraintes choisies par l'utilisateur ou encore le tri d'éléments en fonction d'un critère déterminé). Le tri d'informations fait partie des nombreuses applications en informatique. Il y a n! (factoriel n) façons d'ordonner une collection de n éléments. Les données triées permettent une recherche d'informations plus efficace. Le choix d'un algorithme de tri est par conséquent un critère plus pertinent que la vitesse intrinsèque de l'ordinateur.\nUn tri simple de données consiste à rechercher la valeur minimale d'un tableau ou sa valeur maximale. Grâce à un algorithme de recherche, nous assignons la valeur minimale à la première valeur, puis parcourons l'ensemble des valeurs pour tester si l'une d'entre elles est plus petite que la valeur minimale. Si tel est le cas, la valeur minimale est assignée à cette valeur, sinon, le tri se poursuit. Réalisation de l'algorithme « recherche du minimum » en Java :\npublic static int minimum(int a[]) { int min = a[0]; for (int i = 1; i \u0026lt; a.length; i++) { if (a[i] \u0026lt; min) { min = a[i]; } } return min; } La recherche de la valeur maximale est très similaire : il suffit de changer le critère de comparaison. La réalisation sous la forme d'une méthode Java est, par conséquent, aussi similaire :\npublic static int maximum(int a[]) { int max = a[0]; for (int i = 1; i \u0026lt; a.length; i++) { if (a[i] \u0026gt; max) max = a[i]; } return max; } En Java, le tri est une opération courante pour ordonner des collections d’objets, comme des listes ou des tableaux. La bibliothèque standard propose plusieurs méthodes de tri, notamment via la classe Collections (pour les collections) et la classe Arrays (pour les tableaux). Ces méthodes s’appuient souvent sur l’interface Comparator pour définir un ordre personnalisé, surtout lorsque les objets ne suivent pas un ordre naturel (comme les chaînes ou les nombres) ou lorsque l’ordre par défaut ne convient pas.\nL’interface Comparator définit une méthode abstraite, compare(T o1, T o2), qui retourne :\nUne valeur négative si o1 doit précéder o2. Zéro si o1 et o2 sont équivalents dans l’ordre. Une valeur positive si o1 doit suivre o2. Ce cas montre comment trier une liste de chaînes en utilisant un comparator pour inverser l’ordre alphabétique naturel.\nTriInverse.java import java.util.Arrays; import java.util.Comparator; public class TriInverse { public static void main(String[] args) { String[] mots = {\u0026#34;banane\u0026#34;, \u0026#34;pomme\u0026#34;, \u0026#34;ananas\u0026#34;, \u0026#34;cerise\u0026#34;}; Arrays.sort(mots, Comparator.reverseOrder()); System.out.println(\u0026#34;Mots triés en ordre alphabétique inverse : \u0026#34; \u0026#43; Arrays.toString(mots)); } } Exécuter Le prochain code Java illustre une manière simple et claire de trier une liste de mots en fonction de leur longueur, de la plus courte à la plus longue. Le programme commence par importer des outils Java essentiels : Arrays pour créer des listes, List pour gérer une collection de données, et Comparator pour définir une règle de tri personnalisée. Une classe spéciale, LongueurComparator, est créée pour comparer deux mots en soustrayant la longueur du premier mot de celle du second, ce qui permet de les classer par ordre de taille. Dans la méthode principale (main), une liste de mots (\u0026ldquo;chat\u0026rdquo;, \u0026ldquo;éléphant\u0026rdquo;, \u0026ldquo;chien\u0026rdquo;, \u0026ldquo;girafe\u0026rdquo;) est initialisée, puis triée à l’aide de cette règle de comparaison. Enfin, le programme affiche la liste triée, montrant les mots dans l’ordre suivant : \u0026ldquo;chat\u0026rdquo;, \u0026ldquo;chien\u0026rdquo;, \u0026ldquo;girafe\u0026rdquo;, \u0026ldquo;éléphant\u0026rdquo;.\nExempleLongueur.java import java.util.Arrays; import java.util.Comparator; public class ExempleLongueur { // Nouvelle classe Comparator static class LongueurComparator implements Comparator\u0026lt;String\u0026gt; { @Override public int compare(String a, String b) { return a.length() - b.length(); } } public static void main(String[] args) { String[] mots = {\u0026#34;chat\u0026#34;, \u0026#34;éléphant\u0026#34;, \u0026#34;chien\u0026#34;, \u0026#34;girafe\u0026#34;}; Arrays.sort(mots, new LongueurComparator()); System.out.println(\u0026#34;Mots triés par longueur : \u0026#34; \u0026#43; Arrays.toString(mots)); } } Exécuter Cet exemple illustre la notion de classe statique. Une classe statique en Java est une classe imbriquée (définie à l\u0026rsquo;intérieur d\u0026rsquo;une autre classe) déclarée avec le mot-clé static. Elle est associée à la classe englobante plutôt qu\u0026rsquo;à une instance spécifique de cette classe. Cela signifie qu\u0026rsquo;elle peut être utilisée sans instancier la classe englobante, et elle ne peut accéder qu\u0026rsquo;aux membres statiques (variables ou méthodes) de la classe englobante.\nVoiture.java public class Voiture { private static String marque = \u0026#34;Toyota\u0026#34;; // Classe statique imbriquée public static class Moteur { private int puissance; public Moteur(int puissance) { this.puissance = puissance; } public void afficherDetails() { System.out.println(\u0026#34;Marque de la voiture : \u0026#34; \u0026#43; marque); System.out.println(\u0026#34;Puissance du moteur : \u0026#34; \u0026#43; puissance \u0026#43; \u0026#34; chevaux\u0026#34;); } } public static void main(String[] args) { // Création d\u0026#39;une instance de la classe statique sans instancier Voiture Voiture.Moteur moteur = new Voiture.Moteur(150); moteur.afficherDetails(); } } Exécuter On peut aussi régler ce problème avec une classe anonyme. Une classe anonyme en Java est une classe sans nom, définie et instanciée en une seule expression. Elle est généralement utilisée pour fournir une implémentation ponctuelle d\u0026rsquo;une interface ou pour étendre une classe, souvent dans des situations où une implémentation unique et temporaire est nécessaire. Les classes anonymes sont couramment utilisées avec des interfaces comme Comparator, Runnable, ou des écouteurs d\u0026rsquo;événements. En voici un exemple :\nExempleLongueur.java import java.util.Arrays; import java.util.Comparator; public class ExempleLongueur { public static void main(String[] args) { String[] mots = {\u0026#34;chat\u0026#34;, \u0026#34;éléphant\u0026#34;, \u0026#34;chien\u0026#34;, \u0026#34;girafe\u0026#34;}; // Utilisation d\u0026#39;une classe anonyme pour implémenter Comparator Arrays.sort(mots, new Comparator\u0026lt;String\u0026gt;() { @Override public int compare(String a, String b) { return a.length() - b.length(); } }); System.out.println(\u0026#34;Mots triés par longueur : \u0026#34; \u0026#43; Arrays.toString(mots)); } } Exécuter Les tableaux à plusieurs dimensions (Matrices) # Les tableaux que nous avons utilisés jusqu'à présent sont des tableaux à une seule dimension. Il suffit d'un seul indice pour identifier un élément de ces types de tableaux. Ce sont donc de simples listes de valeurs.\nTableau à deux dimensions # Un tableau à deux dimensions est un tableau avec des lignes et des colonnes. Contrairement à un tableau à une dimension, il faut utiliser deux indices pour accéder aux éléments des tableaux à deux dimensions. Le premier indice représente la ligne et le second, la colonne. La figure ci-dessous, nommée Tableau à deux dimensions, représente un tableau à deux dimensions.\nTableau 1. Tableau à deux dimensions\nColonne 0 Colonne 1 Colonne 2 Colonne 3 Ligne 0 11 12 12 4 Ligne 1 87 45 32 6 Ligne 2 64 56 22 55 Ligne 3 37 32 91 33 Ligne 4 93 35 54 43 Pour avoir accès à un élément du tableau 1, il faut écrire tableau_1[Ligne][Colonne]. Ainsi :\ntableau_1[Ligne 0][Colonne 0] = 11\ntableau_1[Ligne 4][Colonne 2] = 54\ntableau_1[Ligne 2][Colonne 1] = 56\n....\nCréation de tableaux à deux dimensions # La première dimension spécifie que le tableau contient cinq éléments et représente les cinq lignes achats. La seconde dimension spécifie que chacun de ces cinq éléments est formé d'un tableau de type double de quatre éléments qui représente les colonnes d'achats.\nsemaine 1 semaine 2 semaine 3 semaine 4 2010 11 123 455 4 2009 87 45 32 6 2008 64 56 22 55 2007 37 32 91 33 2006 93 35 54 43 Pour déclarer un tableau à deux dimensions, il faut simplement écrire :\ntypededonnées NonDuTableau [nombreDeLignes][nombreDeColonne]\nPlus concrètement, nous pouvons déclarer un tableau à deux dimensions pour inscrire des achats du mois en faisant :\ndouble achats [][]; //achats est ici un tableau à deux dimensions de type double des achats. Une fois que le tableau est déclaré, il faut le créer en utilisant le mot clé new.\nAinsi, pour créer les achats des quatre semaines du mois de juillet des cinq dernières années, nous allons faire :\nachats = new double [5][4]; La première dimension spécifie que le tableau contient cinq éléments et représente les cinq lignes achats. La seconde dimension spécifie que chacun de ces cinq éléments est formé d'un tableau de type double de quatre éléments qui représente les colonnes d'achats.\nSemaine 1 Semaine 2 Semaine 3 Semaine 4 2010 11 123 455 4 2009 87 45 32 6 2008 64 56 22 55 2007 37 32 91 33 2006 93 35 54 43 Achats\nIl faut noter ici que rien ne nous empêche de déclarer et de créer en même temps un tableau. Pour cela, il faut simplement faire :\ntypeDeTableau [][] nomDuTableau = new typeDeTableau [nombreDeLigne][nombreDeColonne]; Ainsi dans le cas de Achats, nous pouvons écrire :\ndouble[][] Achats = new double [5][4]; Ainsi Achats est déclaré et créé simultanément.\nManipulation d\u0026rsquo;un tableau à 2 dimensions # Pour accéder à un élément du tableau Achats, il faut écrire, par exemple :\nAchats [0][0] = 11 pour l'élément à la ligne 0 colonne 0. Il est cependant important de noter que si nous avons des milliers d'éléments, cette façon de faire ne sera pas commode. Ainsi, avec deux boucles for imbriquées, nous pouvons accéder plus facilement aux éléments de Achats. La portion de programme suivant le montre facilement :\nint annees = 2010; // initialisation de l\u0026#39;année selon l\u0026#39;indice 0 du tableau Achats for (int i = 0; i \u0026lt; 5; i++) { for (int j = 0; j \u0026lt; 4; j++) { System.out.println(\u0026#34;Achats [\u0026#34; + i + \u0026#34;][\u0026#34; + j + \u0026#34;] =\u0026#34; + achats[i][j]); } } Pour initialiser un tableau à deux dimensions, nous pouvons simplement écrire :\ntypeDeTableau nomDuTableau [][] = { { }, {}, {}, etc...}; Ainsi, pour un tableau composé des noms des étudiants et des cours qu'ils suivent peut être défini de la manière suivante :\nString etudiants[][] = { {\u0026#34;nom\u0026#34;, \u0026#34;cours\u0026#34;}, {\u0026#34;nom\u0026#34;, \u0026#34;cours\u0026#34;}, {\u0026#34;nom\u0026#34;, \u0026#34;cours\u0026#34;}, {\u0026#34;nom\u0026#34;, \u0026#34;cours\u0026#34;} etc...}; Considérons l\u0026rsquo;exemple suivant. Le code implémente un modèle de langue simple en Java qui calcule les probabilités de transition entre caractères ASCII dans une chaîne donnée, puis génère une séquence de 100 caractères à partir d\u0026rsquo;un caractère initial. Il utilise un tableau à deux dimensions double[][] transitions de taille 128x128 pour stocker les probabilités qu’un caractère ASCII (0-127) soit suivi d’un autre. Dans calculerTransitions, le programme compte les occurrences des paires de caractères consécutifs dans le texte d’entrée et normalise ces comptes pour obtenir des probabilités, stockées dans transitions[i][j], où i est le caractère courant et j le suivant. Lors de la génération dans genererCaractereSuivant, ce tableau est utilisé pour sélectionner aléatoirement le caractère suivant en fonction des probabilités associées au caractère courant. Cette application des tableaux à deux dimensions permet de modéliser efficacement les relations entre caractères, chaque cellule représentant une probabilité de transition, et facilite la génération de texte en s’appuyant sur une structure matricielle claire et organisée.\nModeleLangue.java import java.util.Random; public class ModeleLangue { private static final int ASCII_SIZE = 128; // Taille de la table ASCII (0-127) private double[][] transitions; // Matrice des probabilités de transition private Random random; // Constructeur qui calcule les probabilités de transition à partir d\u0026#39;une chaîne public ModeleLangue(String texte) { transitions = new double[ASCII_SIZE][ASCII_SIZE]; random = new Random(); calculerTransitions(texte); } // Calcule les probabilités de transition private void calculerTransitions(String texte) { // Compter les transitions int[][] compte = new int[ASCII_SIZE][ASCII_SIZE]; int[] totalParCaractere = new int[ASCII_SIZE]; // Parcourir la chaîne pour compter les transitions for (int i = 0; i \u0026lt; texte.length() - 1; i\u0026#43;\u0026#43;) { char courant = texte.charAt(i); char suivant = texte.charAt(i \u0026#43; 1); // Vérifier que les caractères sont dans la plage ASCII if (courant \u0026lt; ASCII_SIZE \u0026\u0026 suivant \u0026lt; ASCII_SIZE) { compte[courant][suivant]\u0026#43;\u0026#43;; totalParCaractere[courant]\u0026#43;\u0026#43;; } } // Calculer les probabilités for (int i = 0; i \u0026lt; ASCII_SIZE; i\u0026#43;\u0026#43;) { if (totalParCaractere[i] \u0026gt; 0) { for (int j = 0; j \u0026lt; ASCII_SIZE; j\u0026#43;\u0026#43;) { transitions[i][j] = (double) compte[i][j] / totalParCaractere[i]; } } } } // Génère un caractère suivant basé sur les probabilités private char genererCaractereSuivant(char courant) { if (courant \u0026gt;= ASCII_SIZE) { return (char) random.nextInt(ASCII_SIZE); // Caractère hors plage } double somme = 0.0; for (double prob : transitions[courant]) { somme \u0026#43;= prob; } // Si aucune transition n\u0026#39;existe, choisir un caractère aléatoire if (somme == 0.0) { return (char) random.nextInt(ASCII_SIZE); } // Sélection aléatoire basée sur les probabilités double r = random.nextDouble(); double cumul = 0.0; for (int i = 0; i \u0026lt; ASCII_SIZE; i\u0026#43;\u0026#43;) { cumul \u0026#43;= transitions[courant][i]; if (r \u0026lt;= cumul) { return (char) i; } } // En cas d\u0026#39;erreur (arrondi), retourner le dernier caractère possible return (char) (ASCII_SIZE - 1); } // Génère une séquence de longueur donnée à partir d\u0026#39;un caractère initial public String genererSequence(char debut, int longueur) { StringBuilder sequence = new StringBuilder(); sequence.append(debut); char courant = debut; for (int i = 0; i \u0026lt; longueur - 1; i\u0026#43;\u0026#43;) { courant = genererCaractereSuivant(courant); sequence.append(courant); } return sequence.toString(); } public static void main(String[] args) { // Exemple de texte d\u0026#39;entraînement String texte = \u0026#34;bonjour le monde c\u0026#39;est un test simple pour modeller une langue en java\u0026#34;; ModeleLangue modele = new ModeleLangue(texte); // Générer une séquence de 100 caractères à partir du caractère \u0026#39;b\u0026#39; String sequence = modele.genererSequence(\u0026#39;b\u0026#39;, 100); System.out.println(\u0026#34;Séquence générée : \u0026#34; \u0026#43; sequence); } } Exécuter Tableaux multidimensionnels # Java ne se limite pas seulement aux tableaux à deux dimensions. Nous pouvons aussi déclarer des tableaux à plus de deux dimensions. Pour déclarer un tableau à trois dimensions, par exemple, il suffit de faire : typedetableau [][][] nomdutableau = new [taille][taille][taille]; Plus concrètement, nous pouvons déclarer un tableau d'entiers comme :\nint tableauEntier [][][] = new int [5][5][5]; Nous venons ainsi de créer un tableau d'entiers à trois dimensions. Pour initialiser un tel tableau, nous pouvons utiliser trois boucles for. À titre d'exemples, initialisons tous les éléments du tableau tableauentier à 1 :\nfor (int i = 0; i \u0026lt; 5; i++) { for (int j = 0; j \u0026lt; 5; j++) { for (int k = 0; k \u0026lt; 5; k++) { tableauEntier[i][j][k] = 1; } } } Les ArrayLists # Une ArrayList est une structure de données, similaire à un tableau, mais avec une taille indéfinie. Bref, comme une liste d\u0026rsquo;items, sa taille change au fur et à mesure de l\u0026rsquo;ajout ou du retrait d\u0026rsquo;éléments et s\u0026rsquo;utilise à la façon d\u0026rsquo;un tableau grâce à la méthode get(i), où i est l\u0026rsquo;index du tableau. L\u0026rsquo;objet ArrayList possède un ensemble de méthodes permettant de manipuler les données (ex. get, remove, isEmpty, toArray). De plus, les ArrayList utilisent le système de template (à voir en détail un peu plus loin), qui permet de créer des ArrayList pour un type d\u0026rsquo;Objet en particulier, par exemple : \u0026ldquo;ArrayList\u0026lt;String\u0026gt;, ArrayList\u0026lt;Double\u0026gt;, ArrayList\u0026lt;ArrayList\u0026lt;Integer\u0026gt;\u0026gt;\u0026rdquo; (Oui c\u0026rsquo;est possible \u0026hellip; pour simuler une matrice par exemple),etc. Voici un exemple d\u0026rsquo;instanciation et d\u0026rsquo;utilisation d\u0026rsquo;une ArrayList.\nMain.java import java.util.*; class Main { public static void main(String[] args) { ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(); //Permet d\u0026#39;ajout un élément list.add(\u0026#34;Valeur1\u0026#34;); //Permet de modifier une valeur à un index particulier list.set(0, \u0026#34;Valeur2\u0026#34;); //Permet d\u0026#39;accéder à un élément System.out.println(list.get(0)); //Permet de vérifier si la structure est vide ou non System.out.println(list.isEmpty()); //Permet de retirer un élément list.remove(0); //Permet de retourner une version tableau de l\u0026#39;ArrayList. String[] tableau = new String[list.size()]; for(int i = 0; i \u0026lt; list.size(); i\u0026#43;\u0026#43;) { tableau[i] = (String)list.get(i); } // Attention: list.toArray() retourne // un object de type Object[]. The type // String[] n\u0026#39;est pas un sous-type du // type Object[]. On ne peut donc pas faire: // // String[] tableau = list.toArray(); // Non!!! } } Exécuter Comme nous l'avions vu lors de la présentation de la structure d'itération while, il est possible d'itérer rapidement parmi les éléments d'une ArrayList. Pour ce faire, voici trois façons d'itérer parmi les éléments : ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(); list.add(\u0026#34;Valeur1\u0026#34;); //Avec le traditionnel for for(int i = 0; i \u0026lt; list.size();i++){ System.out.println(list.get(i)); } //Avec le for est un raccourci du compilateur. La variable s sera chaque élément de la liste for(String s : list) { System.out.println(s); } //La méthode plus ancienne (Java 1.6) avec les itérateurs Iterator\u0026lt;String\u0026gt; it = list.iterator(); while(it.hasNext()) { System.out.println(it.next()); } Les structures de données dynamiques, comme StringBuilder ou ArrayList ne sont pas magiques. Elles augmentent leur capacité de la manière suivante. En commençant avec un tableau ayant une capacité fixe, elles permettent d\u0026rsquo;ajouter des éléments jusqu\u0026rsquo;à ce que la capacité soit épuisée. Elles allouent alors un nouveau tableau plus grand, elles y copient les éléments, et ainis de suite. Pour comprendre le mécanisme, utilisez l\u0026rsquo;application suivante.\nSimulation d'ArrayList Java Ajouter Étape Les tableaux dynamiques ont un coût amorti de \\(O(1)\\) ? Ajouter de nouveaux éléments à un tableau dynamique, comme l\u0026rsquo;ArrayList de Java, a un temps constant espéré (\\(O(1)\\)) grâce à l\u0026rsquo;analyse amortie. Alors que la plupart des ajouts sont des opérations rapides en \\(O(1)\\), car elles placent simplement un élément dans un emplacement disponible du tableau sous-jacent, il arrive occasionnellement que le tableau atteigne sa capacité et doive être redimensionné. Ce redimensionnement implique la création d\u0026rsquo;un nouveau tableau, plus grand (généralement d\u0026rsquo;un facteur \\(K \u003e 1\\)), et la copie de tous les éléments existants. Si la capacité actuelle est \\(C\\), et qu\u0026rsquo;il y a \\(C\\) éléments, leur copie vers le nouveau tableau de taille \\(K \\cdot C\\) prend un temps \\(O(C)\\).\nPour comprendre pourquoi cela conduit à un temps amorti de \\(O(1)\\), considérons une séquence de \\(N\\) insertions à partir d\u0026rsquo;un tableau vide. Le coût total pour \\(N\\) insertions est la somme des coûts des insertions individuelles (chacune en \\(O(1)\\)) plus les coûts de toutes les opérations de redimensionnement. Les insertions individuelles ajoutent \\(N \\cdot O(1) = O(N)\\) au coût total.\nConcentrons-nous maintenant sur les coûts de redimensionnement. Les capacités auxquelles les redimensionnements se produisent sont approximativement \\(1, K, K^2, K^3, \\ldots, K^m\\), où \\(K^m\\) est la plus petite puissance de \\(K\\) supérieure ou égale à \\(N\\).\nLe coût de copie pour ces redimensionnements sera : \\(1 + K + K^2 + \\ldots + K^{m-1}\\) (en supposant une capacité initiale de 1 pour simplifier).\nCeci est la somme d\u0026rsquo;une série géométrique : \\(\\mathrm{Coût}_{\\mathrm{copie}} = \\sum_{i=0}^{m-1} K^i = \\frac{K^m - 1}{K - 1}\\)\nPuisque \\(K^m \\approx N\\) (plus précisément, \\(K^{m-1} \u003c N \\le K^m\\)), le coût de copie est approximativement \\(\\frac{N}{K-1}\\).\nPar conséquent, le coût total pour \\(N\\) insertions est : \\(\\mathrm{Coût\\ Total} = O(N)\\ \\text{(pour les insertions)} + O\\left(\\frac{N}{K-1}\\right)\\ \\text{(pour les copies)}\\)\nÉtant donné que \\(K\\) est une constante supérieure à 1, \\(\\frac{1}{K-1}\\) est également une constante. Ainsi, \\(\\mathrm{Coût\\ Total} = O(N) + O(N) = O(N)\\).\nEnfin, le coût amorti par opération est le coût total divisé par le nombre d\u0026rsquo;opérations : \\(\\mathrm{Coût\\ Amorti} = \\frac{\\mathrm{Coût\\ Total}}{N} = \\frac{O(N)}{N} = O(1)\\).\nDonc, tant que \\(K \u003e 1\\), la complexité temporelle amortie pour ajouter un élément à un tableau dynamique reste \\(O(1)\\), car le coût total de la copie des éléments lors des redimensionnements est proportionnel au nombre total d\u0026rsquo;éléments insérés.\nAutres structures de données # Stack (Pile) # Une Stack (ou pile) est une structure de données fondamentale qui fonctionne selon le principe « dernier arrivé, premier sorti » (LIFO : Last In, First Out). Cela signifie que le dernier élément ajouté à la pile sera le premier à en sortir. Les opérations principales sont push (empiler), pop (dépiler) et peek (regarder le sommet sans retirer). Les piles sont utilisées dans de nombreux contextes : gestion des appels de fonctions, annulation d’actions, analyse d’expressions, etc.\nEn Java, la classe Stack permet d’utiliser facilement cette structure : on peut y empiler des objets de tout type, puis les dépiler dans l’ordre inverse de leur ajout. Voici un exemple simple :\nimport java.util.Stack; public class ExempleStack { public static void main(String[] args) { Stack\u0026lt;Integer\u0026gt; pile = new Stack\u0026lt;\u0026gt;(); pile.push(10); pile.push(20); pile.push(30); System.out.println(pile.pop()); // Affiche 30 System.out.println(pile.peek()); // Affiche 20 (sans dépiler) } } Dans cet exemple, on empile trois entiers ; le pop() retire et retourne le dernier ajouté (30), puis peek() permet de consulter le sommet (20) sans le retirer.\nHashMap (Table de hachage) # Une HashMap est une structure de données qui associe des clés à des valeurs. Elle permet de retrouver très rapidement une valeur à partir de sa clé, grâce à une fonction de hachage qui transforme la clé en un index. Les HashMap sont très utiles pour stocker des associations uniques, comme des noms d’étudiants et leurs notes, ou des mots et leurs définitions.\nUne caractéristique importante : si on ajoute plusieurs fois la même clé, la nouvelle valeur écrase l’ancienne. Par exemple, si on fait map.put(\u0026ldquo;clé\u0026rdquo;, 1) puis map.put(\u0026ldquo;clé\u0026rdquo;, 2), la valeur associée à \u0026ldquo;clé\u0026rdquo; sera 2. Si on cherche une clé qui n’est pas présente, get retourne null (ou lève une exception si on utilise getOrDefault ou get sur des types primitifs).\nVoici un exemple d’utilisation :\nimport java.util.HashMap; public class ExempleHashMap { public static void main(String[] args) { HashMap\u0026lt;String, Integer\u0026gt; notes = new HashMap\u0026lt;\u0026gt;(); notes.put(\u0026#34;Alice\u0026#34;, 85); notes.put(\u0026#34;Bob\u0026#34;, 92); notes.put(\u0026#34;Alice\u0026#34;, 90); // Remplace la note précédente d\u0026#39;Alice System.out.println(notes.get(\u0026#34;Alice\u0026#34;)); // Affiche 90 System.out.println(notes.get(\u0026#34;Charlie\u0026#34;)); // Affiche null (clé absente) } } Dans cet exemple, la note d’Alice est d’abord 85, puis remplacée par 90. La recherche d’une clé absente (\u0026ldquo;Charlie\u0026rdquo;) retourne null.\nPriorityQueue (File de priorité) # Une PriorityQueue (file de priorité) est une structure de données qui permet de toujours extraire l’élément ayant la plus haute priorité (par défaut, le plus petit selon l’ordre naturel). Contrairement à une file classique (FIFO), la PriorityQueue trie automatiquement ses éléments selon leur priorité. Elle est très utilisée pour la gestion de files d’attente avec priorités, les algorithmes de plus court chemin (Dijkstra), ou la planification de tâches.\nEn Java, la classe PriorityQueue permet d’ajouter des éléments avec add ou offer, et d’extraire le plus prioritaire avec poll (qui le retire) ou peek (qui le consulte sans le retirer). Par défaut, les éléments sont triés dans l’ordre croissant, mais on peut fournir un comparateur personnalisé.\nVoici un exemple simple :\nimport java.util.PriorityQueue; public class ExemplePriorityQueue { public static void main(String[] args) { PriorityQueue\u0026lt;Integer\u0026gt; file = new PriorityQueue\u0026lt;\u0026gt;(); file.add(30); file.add(10); file.add(20); System.out.println(file.poll()); // Affiche 10 (le plus petit) System.out.println(file.peek()); // Affiche 20 (le prochain plus petit) } } Dans cet exemple, les entiers sont extraits dans l’ordre croissant. On peut aussi utiliser des objets et définir l’ordre de priorité avec un comparateur.\nPar valeur et par référence # Quand on passe une valeur en Java, il y a une différence fondamentale selon qu’il s’agit d’un type primitif ou d’un type référence, en raison de la manière dont Java gère les paramètres dans les méthodes.\nLes types primitifs (int, double, float, long, short, byte, char, boolean) sont passés par valeur. Cela signifie que lorsqu’une variable de type primitif est passée à une méthode, une copie de sa valeur est transmise. Toute modification de cette valeur à l’intérieur de la méthode n’affecte pas la variable originale à l’extérieur de la méthode. Par exemple, si vous passez un int à une méthode et que la méthode modifie ce paramètre, la valeur de la variable initiale reste inchangée.\nEn revanche, les types référence (comme String, StringBuilder, ArrayList, HashMap, ou les classes enveloppes telles que Integer, Double ainsi que tous les tableaux) sont passés par référence, ou plus précisément, par copie de la référence. Cela signifie que la méthode reçoit une copie de l’adresse mémoire pointant vers l’objet. Si la méthode modifie l’état interne de l’objet (par exemple, en ajoutant un élément à un ArrayList), cette modification est visible à l’extérieur, car l’objet original est affecté. Cependant, si la méthode réassigne la référence à un nouvel objet (par exemple, en créant un nouveau StringBuilder), cela n’affecte pas la référence originale à l’extérieur de la méthode. En résumé, pour les types référence, les modifications internes aux objets sont persistantes, mais les réassignations de la référence ne le sont pas.\nIl est préférable d\u0026rsquo;utiliser des exemples pour bien comprendre. Dans l\u0026rsquo;exemple suivant, la variable valeur n’est pas modifiée car une copie de sa valeur n’est pas modifiée car une copie de sa valeur est passée à la méthode. Exemple.java public class Exemple { public static void modifierValeur(int nombre) { nombre = 100; System.out.println(\u0026#34;Valeur dans la méthode : \u0026#34; \u0026#43; nombre); } public static void main(String[] args) { int valeur = 10; System.out.println(\u0026#34;Avant appel : \u0026#34; \u0026#43; valeur); modifierValeur(valeur); System.out.println(\u0026#34;Après appel : \u0026#34; \u0026#43; valeur); } } Exécuter Dans le prochain exemple, le tableau est modifié car la méthode accède à l’objet original via la copie de la référence. Exemple.java public class Exemple { public static void modifierTableau(int[] tableau) { tableau[0] = 999; System.out.println(\u0026#34;Valeur dans la méthode : \u0026#34; \u0026#43; tableau[0]); } public static void main(String[] args) { int[] monTableau = {1, 2, 3}; System.out.println(\u0026#34;Avant appel : \u0026#34; \u0026#43; monTableau[0]); modifierTableau(monTableau); System.out.println(\u0026#34;Après appel : \u0026#34; \u0026#43; monTableau[0]); } } Exécuter Dans cet autre exemple, la modification interne de l’objet StringBuilder est visible à l’extérieur. Exemple.java public class Exemple { public static void modifierStringBuilder(StringBuilder sb) { sb.append(\u0026#34; monde\u0026#34;); System.out.println(\u0026#34;Valeur dans la méthode : \u0026#34; \u0026#43; sb); } public static void main(String[] args) { StringBuilder texte = new StringBuilder(\u0026#34;Bonjour\u0026#34;); System.out.println(\u0026#34;Avant appel : \u0026#34; \u0026#43; texte); modifierStringBuilder(texte); System.out.println(\u0026#34;Après appel : \u0026#34; \u0026#43; texte); } } Exécuter Dans le prochain exemple, la réassignation de sb à un nouvel objet n’affecte pas la référence originale. Exemple.java public class Exemple { public static void reassignerStringBuilder(StringBuilder sb) { sb = new StringBuilder(\u0026#34;Nouveau\u0026#34;); System.out.println(\u0026#34;Valeur dans la méthode : \u0026#34; \u0026#43; sb); } public static void main(String[] args) { StringBuilder texte = new StringBuilder(\u0026#34;Original\u0026#34;); System.out.println(\u0026#34;Avant appel : \u0026#34; \u0026#43; texte); reassignerStringBuilder(texte); System.out.println(\u0026#34;Après appel : \u0026#34; \u0026#43; texte); } } Exécuter Dans ce dernier exemple, la réassignation dans la méthode crée un nouvel objet sans affecter la référence originale. Exemple.java public class Exemple { public static void modifierString(String texte) { texte = \u0026#34;Nouveau texte\u0026#34;; System.out.println(\u0026#34;Valeur dans la méthode : \u0026#34; \u0026#43; texte); } public static void main(String[] args) { String message = \u0026#34;Texte initial\u0026#34;; System.out.println(\u0026#34;Avant appel : \u0026#34; \u0026#43; message); modifierString(message); System.out.println(\u0026#34;Après appel : \u0026#34; \u0026#43; message); } } Exécuter De toute manière, une instance de la classe String ne peut pas être modifiée en Java.\nComplexité algorithmique # La complexité algorithmique mesure le coût (en temps ou en espace) des opérations selon la taille des données manipulées. Voici un survol de la complexité des principales opérations sur les structures de données abordées dans ce module :\nTableaux (array) # Accès à un élément : \\(O(1)\\) (accès direct par indice) Modification d’un élément : \\(O(1)\\) Recherche d’une valeur : \\(O(n)\\) dans le pire cas (il faut parcourir tout le tableau) Insertion/Suppression : \\(O(n)\\) (il faut déplacer les éléments suivants) ArrayList # Accès à un élément : \\(O(1)\\) Ajout à la fin : \\(O(1)\\) en moyenne (amortie), mais \\(O(n)\\) lors d’un redimensionnement Insertion/Suppression à une position donnée : \\(O(n)\\) (déplacement des éléments) Recherche d’une valeur : \\(O(n)\\) Stack (Pile) # Ajout (push) ou retrait (pop) d’un élément : \\(O(1)\\) Accès au sommet : \\(O(1)\\) HashMap # Insertion, suppression, recherche par clé : \\(O(1)\\) en moyenne, \\(O(n)\\) dans le pire cas (rare) PriorityQueue # Ajout d’un élément : \\(O(\\log n)\\) (le nouvel élément est placé à la fin puis remonté) Extraction du plus prioritaire (poll) : \\(O(\\log n)\\) (le dernier élément est placé en tête puis redescendu) Consultation du plus prioritaire (peek) : \\(O(1)\\) Opérations sur les streams et lambdas # Filtrage, transformation (map, filter, etc.) : \\(O(n)\\), car chaque élément est traité une fois Tri d’une liste : \\(O(n \\log n)\\) (par exemple, avec Collections.sort() ou List.sort()) Remarques pédagogiques # Les opérations en \\(O(1)\\) sont dites « en temps constant » : leur durée ne dépend pas de la taille des données. Les opérations en \\(O(n)\\) sont « linéaires » : leur durée croît proportionnellement à la taille des données. Les opérations en \\(O(n \\log n)\\) sont typiques des algorithmes de tri efficaces. Les structures comme HashMap sont très performantes pour la recherche par clé, mais moins adaptées pour le parcours ordonné. En résumé, le choix de la structure de données influence fortement la performance des algorithmes. Il est essentiel de comprendre la complexité des opérations pour écrire du code efficace, surtout lorsque les ensembles de données deviennent volumineux.\nLecture optionnelle dans le livre de référence (Delannoy) # Pour aller plus en profondeur sur les structures de données(optionnel), vous pouvez lire dans Programmer en Java de Claude Delannoy les chapitres 7 et 22.\nVidéos # "},{"id":30,"href":"/inf1220-hugo/docs/modules/module4/","title":"Module 4: Les entrées et sorties","section":"Modules","content":" Module 4 # Le module 4 se consacre aux concepts d’entrées et de sorties, des composantes fondamentales pour interagir avec les utilisateurs et gérer les données dans un programme Java. Les entrées permettent de collecter des informations provenant de sources externes, telles que les saisies clavier ou les fichiers, tandis que les sorties servent à afficher ou à enregistrer les résultats, que ce soit à l’écran ou dans des fichiers. Ce module explore les techniques et les classes Java dédiées à ces opérations, comme Scanner pour les entrées et System.out pour les sorties. À travers des exercices pratiques tirés du manuel Java pas à pas et du site du cours, les apprenants acquièrent la capacité de concevoir des programmes interactifs et dynamiques.\nCe module met également l’accent sur la gestion efficace des flux d’entrées et de sorties, en introduisant des notions telles que la lecture et l’écriture de fichiers. Les apprenants découvrent comment manipuler des données textuelles ou numériques pour répondre à des besoins spécifiques, tout en apprenant à gérer les erreurs potentielles liées à ces opérations. En s’appuyant sur des exemples concrets, ce module renforce la compréhension des mécanismes d’interaction entre un programme et son environnement, permettant ainsi de développer des applications plus robustes et polyvalentes. Ces compétences s’intègrent aux connaissances acquises dans les modules précédents, consolidant une approche pratique et structurée de la programmation.\nCe module comprend désormais une section dédiée au développement web avec Java. Vous y découvrirez les bases du protocole HTTP, la structure des pages HTML, l’utilisation de JavaScript et de JSON, ainsi que la création d’applications web dynamiques côté serveur avec Javalin et Thymeleaf. Une activité complète vous guide pas à pas dans la réalisation d’un jeu web interactif, de la conception du code Java à la mise en forme avec CSS, en passant par la gestion des routes, des sessions et des échanges de données.\nVous apprendrez également à utiliser Maven pour automatiser la compilation et le déploiement de vos applications web Java, et à structurer vos projets pour faciliter la maintenance et la collaboration. Cette nouvelle section vous permettra de relier les notions d’entrées/sorties à la programmation web moderne, en mettant l’accent sur l’interaction entre le serveur, le navigateur et l’utilisateur.\nObjectifs du module # À la fin de ce module, vous serez capable de :\nUtiliser les classes et méthodes Java pour gérer les entrées (clavier, fichiers) et les sorties (console, fichiers). Lire et écrire des données textuelles et numériques à partir de différentes sources. Concevoir des programmes interactifs capables de traiter des informations provenant de l’utilisateur ou de fichiers externes. Gérer les erreurs et exceptions liées aux opérations d’entrée/sortie de manière appropriée. Comprendre et appliquer les notions de flux (streams) pour optimiser la gestion des données. Appliquer les bonnes pratiques pour assurer la robustesse et la performance des opérations d’E/S. Intégrer les opérations d’entrée/sortie dans des programmes plus complexes, en lien avec les structures de données et de contrôle vues dans les modules précédents. "},{"id":31,"href":"/inf1220-hugo/docs/modules/module5/travail-note-5/","title":"Travail noté 5","section":"Module 5. La programmation orientée objet: héritage et le polymorphisme","content":" Travail noté 5 - Héritage et polymorphisme # Pour le cours INF1220, les travaux notés doivent être soumis sous forme d’un unique fichier PDF via l’outil de dépôt officiel de la TÉLUQ, avant la date de fin de cours indiquée sur le portail étudiant. Les soumissions par courriel ne sont pas acceptées et entraînent une note de zéro, tout comme les documents manuscrits, les saisies d’écran ou ceux ne permettant pas le copier-coller du code Java. L’utilisation du robot conversationnel du cours est autorisée, mais les réponses et analyses doivent être personnelles. Avant de commencer, il est crucial d’avoir complété toutes les lectures et exercices préparatoires et de maîtriser la matière, en posant des questions si nécessaire.\nLa date de fin de cours, fixée par l’Université, est non négociable par les enseignants, et tout travail soumis tardivement risque une note de zéro ou un « incomplet », même si l’examen a lieu plus tard. En cas de difficultés personnelles (maladie, deuil, etc.), les étudiants doivent contacter l’Université pour demander un report. Les problèmes techniques avec l’outil de dépôt doivent également être résolus via l’Université. Aucun indice supplémentaire ne sera fourni au-delà de l’énoncé pour garantir l’équité, et les étudiants sont responsables de planifier leur temps et de vérifier soigneusement leur travail avant soumission.\nLes travaux sont strictement individuels, et tout échange, notamment sur les réseaux sociaux, est considéré comme une faute académique pouvant entraîner une note de zéro ou une exclusion du programme. Le fichier PDF doit contenir le code Java, intégré de manière à faciliter la correction, sans fichiers séparés. La préparation rigoureuse, incluant la maîtrise des concepts et la vérification du travail, est essentielle pour éviter les erreurs et répondre aux attentes du cours.\nQuestion #1 # Veuillez expliquer en quelques phrases les résultats ou les erreurs suivantes lors de l'utilisation de ces classes dans la classe TestAnimaux.java:\nTestAnimaux.javapublic class TestAnimaux { public static void main(String[] args) { Chat cat1 = new Chat(); cat1.greeting(); Chien dog1 = new Chien(); dog1.greeting(); GrosChien bigDog1 = new GrosChien(); bigDog1.greeting(); Animaux animal1 = new Chien (); animal1.greeting(); Animaux animal2 = new Chien(); animal2.greeting(); Animaux animal3 = new GrosChien(); animal3.greeting(); Chien dog2 = (Chien)animal2; GrosChien bigDog2 = (GrosChien)animal3; Chien dog3 = (Chien)animal3; dog2.greeting(dog3); dog3.greeting(dog2); dog2.greeting(bigDog2); bigDog2.greeting(dog2); bigDog2.greeting(bigDog1); Chat cat2 = (Chat)animal2; } } Animaux.javaabstract public class Animaux { abstract public void greeting(); } Chat.javapublic class Chat extends Animaux { @Override public void greeting() { System.out.println(\u0026#34;Meow!\u0026#34;); } } Chien.javapublic class Chien extends Animaux { @Override public void greeting() { System.out.println(\u0026#34;Woof!\u0026#34;); } public void greeting(Chien another) { System.out.println(\u0026#34;Woooooooooof!\u0026#34;); } } GrosChien.javapublic class GrosChien extends Chien { @Override public void greeting() { System.out.println(\u0026#34;Woow!\u0026#34;); } @Override public void greeting(Chien another) { System.out.println(\u0026#34;Woooooowwwww!\u0026#34;); } } Exécuter Question #2 # En tant que programmeur, vous recevez le code suivant. Vous devez appliquer l'héritage afin que Cercle et Carré héritent à la fois de Forme et Resizable. Vous pouvez bien entendu modifier le code reçu. Utilisez votre bon jugement. Votre solution doit comprendre au moins une classe abstraite. Vous devez expliquer vos choix de manière détaillée: un travail remis avec des explications insuffisantes pourra se voir attribué la note de zéro, sans droit de reprise.\nTestCercle.javapublic class TestCercle { public static void main(String[] args) { Cercle c = new Cercle(1.9); System.out.println(\u0026#34;Bonjour, INF 1220 !\u0026#34;); } } Cercle.javapublic class Cercle { double diametre = 0; public Cercle(double diametre) { this.diametre = diametre; } public double getPerimeter() { return Math.PI * diametre; } public void resize(double diametre) { this.diametre = diametre; } } Carre.javapublic class Carre { double taille = 0; public Carre(double taille) { this.taille = taille; } public double getPerimeter() { return taille*4; } public void resize(double taille) { this.taille = taille; } } Resizable.javapublic abstract class Resizable { public abstract void resize(double d); } Forme.javapublic abstract class Forme { public abstract double getPerimeter(); } Exécuter Question #3 # À quoi servent les interfaces en Java ? Utilisez la question précédente (2) comme base de discussion. Maximum 5 phrases.\nEn terminant # Dans plusieurs cas, vos travaux sont corrigés par un « correcteur ». Il est possible que vous puissiez identifier cette personne en examinant le document de rétroaction que vous recevez au sein du portail étudiant. Vous ne devriez jamais joindre cette personne. Cette personne n'a pas comme mandat de répondre à vos questions suite à la correction. Vos courriels seront ignorés. Il faut plutôt joindre la personne qui vous encadre au sein du cours.\nRobot conversationnel – Questionnaire de retour sur expérience # Qu’avez-vous pensé du robot conversationnel du cours? Votre avis compte pour nous. Nous vous invitons à compléter le questionnaire de retour sur expérience (5 minutes). Nous vous remercions pour votre contribution à notre projet pilote.\n"},{"id":32,"href":"/inf1220-hugo/docs/extra/feuille-de-route/","title":"Feuille de route","section":"Autres ressources","content":"Feuille de route Prévoyez environ 9 heures de travail pendant quinze semaines. Il n'est pas possible, pour la plupart des étudiants, de réussir ce cours en ne prenant qu'une poignée d'heures par semaine. Chaque étudiant a sa propre date de départ et date de fin de cours personnalisée. La date à laquelle l'étudiant doit passer son examen est déterminé par l'Université: celle-ci vous fera parvenir les détails en temps opportun. Vous devez joindre l'Université si vous souhaitez les modifier. Il n'y a pas de dates fixes pour la remise des travaux, mais il est recommandé de prévoir une semaine de travail pour la réalisation de chacun de ceux-ci et de les remettre selon l'ordre de présentation du cours. Tous les étudiants ne vont pas avancer au même rythme dans le cours. Nous vous suggérons cependant de remettre vos travaux notés lors de la semaine indiquée par le tableau suivant :\nActivitésemaine de remise\tTravail noté 12\tTravail noté 25\tTravail noté 38\tTravail noté 410\tTravail noté 514\tExamen sous surveillance15 ou plus Il est parfaitement normal de consacrer des dizaines d'heures à compléter un travail noté et les activités préparatoires. Il est de votre responsabilité de trouver le temps nécessaire.\nSi vous trouvez certaines sections du cours plus faciles, n'hésitez pas à avancer plus rapidement. Organisation du cours # Module 1. Algorithme et pseudocode. Dans ce module, vous verrez comment concevoir des algorithmes simples et comment les présenter de manière précise en français. Module 2. Introduction au langage Java. Le concept de programme. Les types, les fonctions, les méthodes, les variables. Les variables de classe et les variables locales. Module 3. Les structures de données, de contrôle et d'itération en Java. Manipulation de chaînes de caractères. Mise en oeuvre d'algorithmes avec des boucles. Module 4. Les entrées et sorties. Module 5. La programmation orientée objet: héritage et le polymorphisme. "},{"id":33,"href":"/inf1220-hugo/docs/modules/module3/fonctionnel/","title":"La programmation fonctionnelle en Java","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" La programmation fonctionnelle en Java # La programmation fonctionnelle tire ses origines des mathématiques, en particulier du calcul lambda développé par Alonzo Church dans les années 1930. Ce formalisme a posé les bases théoriques pour décrire les calculs comme des fonctions pures, sans effets de bord. Dans les années 1950, John McCarthy a créé Lisp, le premier langage explicitement inspiré de ces idées, introduisant des concepts comme les fonctions de première classe. Les années 1980 ont vu l’émergence de langages comme Haskell, qui a mis l’accent sur les fonctions pures et l’évaluation paresseuse. L\u0026rsquo;évaluation paresseuse est une stratégie en programmation fonctionnelle où l\u0026rsquo;évaluation d\u0026rsquo;une expression est retardée jusqu\u0026rsquo;à ce que sa valeur soit réellement nécessaire. Cela permet d\u0026rsquo;optimiser les performances en évitant les calculs inutiles et de supporter des structures de données potentiellement infinies. Depuis, la programmation fonctionnelle a influencé de nombreux langages modernes (Scala, Clojure, F#) et a été intégrée dans des langages impératifs comme Python, JavaScript et Java, en réponse à la nécessité de parallélisme et de code plus robuste.\nAvant Java 8 (2014), la programmation fonctionnelle était absente ou limitée. Les programmeurs utilisaient des solutions comme les classes anonymes pour simuler des comportements fonctionnels, mais cela était verbeux. Avec Java 8, l’introduction des expressions lambda, de l’API Stream et des interfaces fonctionnelles (comme Function, Predicate) a marqué un tournant, permettant de manipuler les fonctions comme des objets de première classe et de traiter les données de manière déclarative. Les références de méthodes et les types fonctionnels ont renforcé cette approche.\nDans ce cours, vous n\u0026rsquo;avez pas à maîtriser la programmation fonctionnelle, mais il est utile d\u0026rsquo;être familier avec cette notion.\nLambdas # Une fonction lambda, ou expression lambda, est une fonction anonyme concise définie sans nom, souvent utilisée pour des opérations simples et ponctuelles. Elle permet d\u0026rsquo;écrire du code plus compact, notamment dans des contextes où une fonction est passée en argument, comme pour des opérations de filtrage ou de tri. En Java, par exemple, les lambdas s\u0026rsquo;appuient sur les interfaces fonctionnelles, qui possèdent une unique méthode abstraite. Leur syntaxe est de la forme (paramètres) -\u0026gt; expression ou (paramètres) -\u0026gt; { instructions; } pour des blocs plus complexes.\nVoici un exemple de code Java avec une méthode main utilisant une lambda pour trier une liste de chaînes par longueur :\nExempleLambda.java import java.util.Arrays; import java.util.List; import java.util.Comparator; public class ExempleLambda { public static void main(String[] args) { List\u0026lt;String\u0026gt; mots = Arrays.asList(\u0026#34;chat\u0026#34;, \u0026#34;éléphant\u0026#34;, \u0026#34;chien\u0026#34;, \u0026#34;girafe\u0026#34;); mots.sort((a, b) -\u0026gt; a.length() - b.length()); System.out.println(\u0026#34;Mots triés par longueur : \u0026#34; \u0026#43; mots); } } Exécuter Ce code définit une liste de mots, utilise une lambda pour trier les éléments par longueur croissante, puis affiche le résultat. La lambda (a, b) -\u0026gt; a.length() - b.length() remplace une implémentation complète de Comparator.\nEn Java, les expressions lambda permettent de capturer des variables de leur portée environnante, mais cette capture est soumise à des règles strictes pour garantir la sécurité et la prévisibilité. Les lambdas peuvent accéder aux variables locales, aux paramètres de méthode, aux variables d\u0026rsquo;instance, aux variables statiques et aux références this ou super. Les variables locales et les paramètres de méthode doivent être final ou effectivement final (non modifiés après leur initialisation) pour être capturés par une lambda. Par exemple, une variable locale int x = 10 peut être utilisée dans une lambda si elle n\u0026rsquo;est pas réassignée. En revanche, les variables d\u0026rsquo;instance et statiques de la classe englobante peuvent être librement accédées et modifiées. Les lambdas capturent également la référence this de la classe englobante, permettant d\u0026rsquo;accéder à ses méthodes et champs d\u0026rsquo;instance. Contrairement aux classes anonymes, où this fait référence à l\u0026rsquo;instance de la classe anonyme, dans une lambda, this désigne l\u0026rsquo;instance de la classe englobante. Les lambdas ne créent pas de nouvelle portée pour this, ce qui simplifie leur sémantique. Cependant, les paramètres de la lambda ne peuvent pas avoir le même nom qu\u0026rsquo;une variable locale capturée pour éviter les ambiguïtés. Sous le capot, la capture des variables locales se fait par référence à leur valeur (qui est constante en raison de la règle de finalité effective), tandis que les variables d\u0026rsquo;instance et statiques sont accessibles via une référence à l\u0026rsquo;objet ou à la classe englobante. Cela permet aux lambdas de modifier l\u0026rsquo;état mutable, comme une liste référencée par une variable locale effectivement final, ce qui peut compromettre la pureté fonctionnelle. Pour qu\u0026rsquo;une lambda soit une fonction pure, elle doit éviter de modifier ou de dépendre d\u0026rsquo;un état mutable externe et se limiter à ses paramètres d\u0026rsquo;entrée et à des données immuables.\nLambdaCaptureExample.java import java.util.ArrayList; import java.util.List; import java.util.function.Consumer; import java.util.function.Function; public class LambdaCaptureExample { private int instanceVar = 100; // Variable d\u0026#39;instance private static int staticVar = 200; // Variable statique public void demonstrateLambdaCapture() { // Variable locale int localVar = 10; // Effectivement final // Liste mutable référencée par une variable locale List\u0026lt;Integer\u0026gt; mutableList = new ArrayList\u0026lt;\u0026gt;(); // Lambda 1 : Capture d\u0026#39;une variable locale (pure) Function\u0026lt;Integer, Integer\u0026gt; pureLambda = x -\u0026gt; x \u0026#43; localVar; System.out.println(\u0026#34;Lambda pure (5 \u0026#43; localVar) : \u0026#34; \u0026#43; pureLambda.apply(5)); // Affiche 15 // Lambda 2 : Capture et modification d\u0026#39;une variable d\u0026#39;instance (non pure) Runnable instanceLambda = () -\u0026gt; { instanceVar \u0026#43;= 50; System.out.println(\u0026#34;Variable d\u0026#39;instance modifiée : \u0026#34; \u0026#43; instanceVar); }; instanceLambda.run(); // Affiche 150 // Lambda 3 : Capture et modification d\u0026#39;une variable statique (non pure) Runnable staticLambda = () -\u0026gt; { staticVar \u0026#43;= 100; System.out.println(\u0026#34;Variable statique modifiée : \u0026#34; \u0026#43; staticVar); }; staticLambda.run(); // Affiche 300 // Lambda 4 : Capture de \u0026#39;this\u0026#39; pour accéder à une méthode d\u0026#39;instance Runnable thisLambda = () -\u0026gt; System.out.println(\u0026#34;Accès via this, instanceVar : \u0026#34; \u0026#43; this.getInstanceVar()); thisLambda.run(); // Affiche 150 // Lambda 5 : Capture d\u0026#39;une liste mutable (non pure) Consumer\u0026lt;Integer\u0026gt; listLambda = x -\u0026gt; mutableList.add(x); listLambda.accept(42); System.out.println(\u0026#34;Liste après ajout : \u0026#34; \u0026#43; mutableList); // Affiche [42] // Tentative de modification de localVar (invalide) // localVar = 20; // Erreur : localVar doit être final ou effectivement final } public int getInstanceVar() { return instanceVar; } public static void main(String[] args) { LambdaCaptureExample example = new LambdaCaptureExample(); example.demonstrateLambdaCapture(); } } Exécuter Les lambdas sont utilisés à de multiples fins en Java. L’API Stream en Java pour effectuer un filtrage fonctionnel sur une liste de nombres. Considérons le prochain exemple. Le premier concept clé est la création d’une liste immuable avec Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8). Cette méthode transforme un tableau de nombres en une List fixe, qui ne peut pas être modifiée (par exemple, pas d’ajout ou de suppression d’éléments). Cette liste, nommée nombres, sert de point de départ pour le traitement. Ensuite, l’opération de filtrage repose sur l’API Stream, introduite en Java 8, qui permet de manipuler des collections de manière déclarative, en exprimant ce qu’on veut obtenir (ici, les nombres pairs) plutôt que comment le faire (comme avec une boucle traditionnelle). Ce paradigme fonctionnel rend le code plus concis et expressif. La méthode filter() crée un nouveau flux contenant uniquement les éléments satisfaisant une condition donnée, définie par une expression lambda qui retourne true ou false.\nExempleLambdaFiltre.java import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class ExempleLambdaFiltre { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; nombres = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8); List\u0026lt;Integer\u0026gt; nombresPairs = nombres.stream() .filter(n -\u0026gt; n % 2 == 0) .collect(Collectors.toList()); System.out.println(\u0026#34;Nombres pairs : \u0026#34; \u0026#43; nombresPairs); } } Exécuter Dans cet exemple, nous utilisons les méthodes stream et collect.\nstream() : La méthode stream() convertit une collection (comme une liste) en un flux (Stream), une séquence d’éléments permettant un traitement séquentiel ou parallèle. Les opérations sur un flux sont paresseuses (exécutées uniquement lorsque nécessaire) et ne modifient pas la collection d’origine. collect() : La méthode collect() rassemble les éléments d’un flux dans une structure de données (par exemple, une liste) après application des opérations. Elle utilise souvent un collecteur, comme Collectors.toList(), pour spécifier le type de résultat. C’est une opération terminale qui déclenche l’exécution du flux. La méthode map() transforme chaque élément d’un flux en appliquant une fonction, produisant un nouveau flux de même longueur avec les valeurs transformées.\nMain.java import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; nombres = Arrays.asList(1, 2, 3, 4); List\u0026lt;Integer\u0026gt; nombresCarres = nombres.stream() .map(x -\u0026gt; x * x) .collect(Collectors.toList()); System.out.println(nombresCarres); // Sortie : [1, 4, 9, 16] } } Exécuter La méthode reduce() combine les éléments d’un flux en une seule valeur en appliquant une fonction prenant deux arguments : le résultat accumulé et l’élément suivant.\nMain.java import java.util.Arrays; import java.util.List; public class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; nombres = Arrays.asList(1, 2, 3, 4); int produit = nombres.stream() .reduce(1, (x, y) -\u0026gt; x * y); System.out.println(produit); // Sortie : 24 } } Exécuter La méthode forEach() applique une action à chaque élément d’un flux. C’est une opération terminale, souvent utilisée pour afficher des résultats ou effectuer des effets secondaires.\nMain.java import java.util.Arrays; import java.util.List; public class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; nombres = Arrays.asList(1, 2, 3, 4); nombres.stream() .forEach(x -\u0026gt; System.out.println(x)); // Sortie : // 1 // 2 // 3 // 4 } } Exécuter La méthode flatMap() transforme chaque élément d’un flux en un flux d’éléments, puis aplatit ces flux en un seul flux. Elle est utile pour gérer des collections imbriquées.\nMain.java import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Main { public static void main(String[] args) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; listes = Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3, 4)); List\u0026lt;Integer\u0026gt; aplatie = listes.stream() .flatMap(liste -\u0026gt; liste.stream()) .collect(Collectors.toList()); System.out.println(aplatie); // Sortie : [1, 2, 3, 4] } } Exécuter La méthode distinct() supprime les doublons d’un flux, renvoyant un flux avec des éléments uniques (basé sur la méthode equals()).\nMain.java import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; nombres = Arrays.asList(1, 2, 2, 3, 3, 4); List\u0026lt;Integer\u0026gt; uniques = nombres.stream() .distinct() .collect(Collectors.toList()); System.out.println(uniques); // Sortie : [1, 2, 3, 4] } } Exécuter La méthode limit() restreint un flux aux n premiers éléments, utile pour traiter un sous-ensemble de données.\nMain.java import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; nombres = Arrays.asList(1, 2, 3, 4, 5); List\u0026lt;Integer\u0026gt; premiers = nombres.stream() .limit(3) .collect(Collectors.toList()); System.out.println(premiers); // Sortie : [1, 2, 3] } } Exécuter La méthode sorted() trie les éléments d’un flux selon leur ordre naturel ou un comparateur personnalisé.\nMain.java import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; nombres = Arrays.asList(4, 1, 3, 2); List\u0026lt;Integer\u0026gt; tries = nombres.stream() .sorted((a, b) -\u0026gt; b - a) .collect(Collectors.toList()); System.out.println(tries); // Sortie : [4, 3, 2, 1] } } Exécuter Les méthodes peuvent être enchaînées pour des opérations complexes. Par exemple, filtrer les nombres pairs, les mettre au carré, supprimer les doublons, limiter à deux éléments et trier en ordre décroissant :\nMain.java import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Main { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; nombres = Arrays.asList(1, 2, 2, 3, 4, 4, 5, 6); List\u0026lt;Integer\u0026gt; resultat = nombres.stream() .filter(x -\u0026gt; x % 2 == 0) .map(x -\u0026gt; x * x) .distinct() .limit(2) .sorted((a, b) -\u0026gt; b - a) .collect(Collectors.toList()); System.out.println(resultat); // Sortie : [16, 4] } } Exécuter Function, Predicate # En Java, les interfaces Function et Predicate font partie du package java.util.function, introduit avec Java 8 pour supporter la programmation fonctionnelle. L\u0026rsquo;interface Function\u0026lt;T, R\u0026gt; représente une fonction qui prend un argument de type T et produit un résultat de type R. Elle est utilisée pour transformer ou mapper des données, souvent dans des contextes comme les streams ou les lambdas. Par exemple, une Function peut convertir une chaîne en sa longueur ou transformer un objet en un autre type. Sa méthode principale est apply, qui exécute la transformation. Les Function peuvent être chaînées avec des méthodes comme andThen ou compose pour combiner des opérations. Ces interfaces rendent le code plus concis et déclaratif, facilitant les manipulations fonctionnelles dans un langage historiquement orienté objet.\nEn Java, la méthode andThen est une méthode de l\u0026rsquo;interface Function\u0026lt;T, R\u0026gt; qui permet de composer deux fonctions en séquence. Plus précisément, si vous avez une Function\u0026lt;T, R\u0026gt; (disons f1) et une autre Function\u0026lt;R, V\u0026gt; (disons f2), f1.andThen(f2) crée une nouvelle fonction qui applique d\u0026rsquo;abord f1 à l\u0026rsquo;entrée de type T pour produire un résultat de type R, puis applique f2 à ce résultat pour produire une sortie de type V. En d\u0026rsquo;autres termes, andThen définit une chaîne où le résultat de la première fonction devient l\u0026rsquo;entrée de la seconde.\nExempleAndThen.java import java.util.function.Function; public class ExempleAndThen { public static void main(String[] args) { // Première fonction : convertit une chaîne en sa longueur Function\u0026lt;String, Integer\u0026gt; longueurChaine = s -\u0026gt; s.length(); // Deuxième fonction : multiplie un entier par 2 Function\u0026lt;Integer, Integer\u0026gt; doubler = n -\u0026gt; n * 2; // Composition avec andThen : longueur, puis doubler Function\u0026lt;String, Integer\u0026gt; longueurPuisDoubler = longueurChaine.andThen(doubler); // Test String texte = \u0026#34;Bonjour\u0026#34;; System.out.println(\u0026#34;Résultat pour \u0026#39;\u0026#34; \u0026#43; texte \u0026#43; \u0026#34;\u0026#39; : \u0026#34; \u0026#43; longueurPuisDoubler.apply(texte)); } } Exécuter L\u0026rsquo;interface Predicate\u0026lt;T\u0026gt; représente une fonction qui prend un argument de type T et retourne un booléen, servant à tester une condition. Elle est couramment utilisée pour filtrer des données, notamment dans les streams avec la méthode filter. Sa méthode principale est test, qui évalue la condition. Les Predicate peuvent être combinés avec des méthodes comme and, or ou negate pour créer des conditions complexes. Par exemple, un Predicate peut vérifier si un nombre est pair ou si une chaîne dépasse une certaine longueur. Voici un exemple.\nFunctionPredicateExemples.java import java.util.function.Function; import java.util.function.Predicate; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class FunctionPredicateExemples { public static void main(String[] args) { // Exemple 1 : Function pour transformer une chaîne en sa longueur Function\u0026lt;String, Integer\u0026gt; longueurChaine = s -\u0026gt; s.length(); System.out.println(\u0026#34;Longueur de \u0026#39;Bonjour\u0026#39; : \u0026#34; \u0026#43; longueurChaine.apply(\u0026#34;Bonjour\u0026#34;)); // Exemple 2 : Function avec chaînage (convertir en majuscules puis prendre la longueur) Function\u0026lt;String, String\u0026gt; enMajuscules = String::toUpperCase; Function\u0026lt;String, Integer\u0026gt; majusculesPuisLongueur = enMajuscules.andThen(longueurChaine); System.out.println(\u0026#34;Longueur de \u0026#39;hello\u0026#39; après majuscules : \u0026#34; \u0026#43; majusculesPuisLongueur.apply(\u0026#34;hello\u0026#34;)); // Exemple 3 : Predicate pour vérifier si un nombre est pair Predicate\u0026lt;Integer\u0026gt; estPair = n -\u0026gt; n % 2 == 0; System.out.println(\u0026#34;10 est pair : \u0026#34; \u0026#43; estPair.test(10)); System.out.println(\u0026#34;7 est pair : \u0026#34; \u0026#43; estPair.test(7)); // Exemple 4 : Predicate avec combinaison (pair ET supérieur à 5) Predicate\u0026lt;Integer\u0026gt; superieurACinq = n -\u0026gt; n \u0026gt; 5; Predicate\u0026lt;Integer\u0026gt; pairEtSuperieurACinq = estPair.and(superieurACinq); System.out.println(\u0026#34;8 est pair et \u0026gt; 5 : \u0026#34; \u0026#43; pairEtSuperieurACinq.test(8)); System.out.println(\u0026#34;4 est pair et \u0026gt; 5 : \u0026#34; \u0026#43; pairEtSuperieurACinq.test(4)); // Exemple 5 : Utilisation de Function et Predicate dans un stream List\u0026lt;String\u0026gt; mots = Arrays.asList(\u0026#34;Java\u0026#34;, \u0026#34;est\u0026#34;, \u0026#34;puissant\u0026#34;); List\u0026lt;Integer\u0026gt; longueursFiltrees = mots.stream() .filter(s -\u0026gt; s.length() \u0026gt; 3) // Predicate .map(longueurChaine) // Function .collect(Collectors.toList()); System.out.println(\u0026#34;Longueurs des mots de plus de 3 lettres : \u0026#34; \u0026#43; longueursFiltrees); } } Exécuter Conclusion # La programmation fonctionnelle est un paradigme de programmation qui met l\u0026rsquo;accent sur l\u0026rsquo;utilisation de fonctions pures, l\u0026rsquo;immutabilité des données et l\u0026rsquo;évitement des effets secondaires. Une fonction pure produit toujours le même résultat pour les mêmes entrées et n\u0026rsquo;altère pas l\u0026rsquo;état externe, ce qui facilite la prédiction et le débogage du code. En Java, bien que le langage soit principalement orienté objet, l\u0026rsquo;introduction de l\u0026rsquo;API Stream et des expressions lambda en Java 8 a permis d\u0026rsquo;intégrer des concepts fonctionnels. Ces outils permettent de manipuler des collections de données de manière déclarative, en exprimant ce que l\u0026rsquo;on veut accomplir (par exemple, filtrer ou transformer des données) plutôt que comment le faire étape par étape, comme dans une approche impérative. Cette approche améliore la lisibilité et la modularité du code, tout en favorisant des opérations comme le parallélisme sans effort explicite.\nLe rôle des lambdas et de l\u0026rsquo;API Stream dans Java illustre bien l\u0026rsquo;influence de la programmation fonctionnelle. Les lambdas permettent de définir des fonctions anonymes concises, souvent utilisées pour implémenter des interfaces fonctionnelles (comme Predicate ou Function) dans des opérations comme le filtrage, le mappage ou le tri. Par exemple, dans une opération comme list.stream().filter(x -\u0026gt; x \u0026gt; 0).map(x -\u0026gt; x * 2).collect(Collectors.toList()), chaque étape est une transformation fonctionnelle qui ne modifie pas la liste initiale, respectant ainsi le principe d\u0026rsquo;immutabilité. L\u0026rsquo;API Stream prend en charge ces transformations en traitant les données comme un flux, où les opérations sont enchaînées et évaluées de manière paresseuse (lazy evaluation), ne s\u0026rsquo;exécutant qu\u0026rsquo;à la demande d\u0026rsquo;un résultat final. Cela réduit les calculs inutiles et permet une optimisation automatique, comme le traitement parallèle avec parallelStream().\nCependant, l\u0026rsquo;intégration de la programmation fonctionnelle en Java reste partielle, car le langage conserve une forte orientation objet. Les développeurs doivent être conscients des compromis : les lambdas et les streams rendent le code plus expressif, mais une utilisation excessive ou inappropriée peut nuire à la performance ou à la lisibilité, notamment dans des cas complexes. De plus, Java impose des contraintes, comme l\u0026rsquo;absence de fonctions de première classe (les lambdas sont des implémentations d\u0026rsquo;interfaces) et une gestion explicite de l\u0026rsquo;immutabilité. Malgré ces limitations, la programmation fonctionnelle en Java, via les streams et les lambdas, a transformé la manière dont les développeurs manipulent les données, encourageant des pratiques plus modernes et alignées sur les paradigmes fonctionnels tout en restant ancrées dans l\u0026rsquo;écosystème Java.\n"},{"id":34,"href":"/inf1220-hugo/docs/modules/module1/algorithmes/","title":"Les algorithmes","section":"Module 1: Algorithme et pseudocode","content":" Les algorithmes # The etymology of program is pro ‘before’ + graphein ‘write’. I think of programming as making a plan that will be executed in the future, something that every human does from time to time. The hard part is that a computer has to execute the plan, and computers are incredibly stupid. Dealing with such stupidity requires more patience and determination than many people have. (Peter Turney)\nPréalables # Nous supposons dans ce cours que vous avez complété les mathématiques du collégial et que vous avez de bonnes aptitudes en ce qui a trait aux raisonnements formels. Dans ce premier module, vous aurez à exprimer la solution de certains problèmes en terme de variables, de boucles et d\u0026rsquo;embranchement. Il ne s\u0026rsquo;agit pas de notions avancées : vous devriez être familier avec ces notions. Les boucles font partie implicitement du calcul d\u0026rsquo;une somme ou d\u0026rsquo;un produit scalaire. Les variables en informatique sont une notion voisine des variables en algèbre. Les embranchements sont des notions de base en logique élémentaire.\nNous supposons une maîtrise de ces notions. Vous êtes responsables de vous assurez que vous avez la préparation nécessaire pour suivre le cours INF 1220.\nIntroduction # Le processus systématique de résolution d\u0026rsquo;un problème donné s\u0026rsquo;appelle algorithme. La notion d\u0026rsquo;algorithme formel est vue dans le cadre des cours de mathématiques du secondaire, notamment dans le contexte de la théorie des graphes et des algorithmes d\u0026rsquo;optimisation. Comme point de départ dans le cours INF 1220, nous revisitons et approfondissons brièvement cette notion fondamentale.\nUn algorithme est donc une suite d\u0026rsquo;actions pour répondre à un problème de traitement de l\u0026rsquo;information. Ces actions peuvent être mathématiques (ex. somme = a + b), de contrôles (ex. SI a \u0026gt; b ALORS) ou d\u0026rsquo;itérations (ex. TANT QUE a \u0026gt; b FAIRE). Pour décrire ces algorithmes, il existe également plusieurs formalismes, certains utiliseront des formalismes mathématiques alors que d\u0026rsquo;autres utiliseront des pseudo-codes. Encore là dans plusieurs formats pour représenter un pseudo-code, il n\u0026rsquo;existe pas de normes uniques!\nEn cuisine, une recette est un exemple d\u0026rsquo;algorithme si celle-ci comporte une séquence d\u0026rsquo;instructions précises. Pouvoir rédiger de manière précise une recette afin que d\u0026rsquo;autres cuisiniers puissent reproduire la même séquence d\u0026rsquo;opération est de facto de la programmation informatique. Si vous avez fait l\u0026rsquo;expérience du manuel de recette de quelqu\u0026rsquo;un d\u0026rsquo;autre (par ex., votre grand-mère), vous avez peut-être découvert qu\u0026rsquo;il peut être difficile de suivre des consignes de quelqu\u0026rsquo;un d\u0026rsquo;autre surtout quand celles-ci ne sont pas suffisamment précises. Une recette de cuisine est du pseudo-code.\nAvant l\u0026rsquo;invention du GPS, il était commun d\u0026rsquo;expliquer à des amis ou des parents comment se rendre à un lieu donné en suivant une série d\u0026rsquo;instructions. Il arrivait souvent, malheureusement, que ces instructions n\u0026rsquo;étaient pas assez précises et que les gens se perdent. Expliquer à quelqu\u0026rsquo;un comment se rendre à un lieu donné est un exemple de programmation informatique. Votre explication est du pseudo-code.\nIl est essentiel de comprendre ce qu\u0026rsquo;est le pseudo-code: il s\u0026rsquo;agit d\u0026rsquo;une façon de décrire un algorithme afin que d\u0026rsquo;autres êtres humains puissent vous comprendre. Il faut donc interpréter le pseudo-code en utilisant son jugement humain de la même façon que vous interprétez tout autre texte ou discours. Pouvoir lire un algorithme, décrit en pseudo-code, est une compétence essentielle en informatique. Il faut être capable de comprendre d\u0026rsquo;autres informaticiens sans nécessairement exiger que ceux-ci utilisent du code informatique dans un langage particulier (par ex., Java). Programmer et faire de l\u0026rsquo;informatique exige de pouvoir bien communiquer avec les autres informaticiens indépendamment de langages de programmation spécifiques.\nPour un programmeur d\u0026rsquo;expérience, s\u0026rsquo;exprimer à l\u0026rsquo;aide d\u0026rsquo;un pseudo-code est chose aisée. Pour le commun des mortels, c\u0026rsquo;est un peu plus difficile. La blague suivante illustre le problème.\nUne femme demande à son programmeur de mari : « Va au supermarché acheter une bouteille de lait. Et si ils ont des œufs, prends en 6 ». Le mari revient avec six bouteilles de lait. Sa femme lui demande pourquoi il a pris six bouteilles. « Parce qu\u0026rsquo;ils avaient des oeufs » répond-il.\nQuand on rédige un pseudo-code, il faut tout spécifier, comme si on s\u0026rsquo;adressait à quelqu\u0026rsquo;un qui prend tout littéralement, sans aucun jugement. Pour devenir un programmeur, pour penser comme un programmeur, il faut s\u0026rsquo;habituer à rédiger des séquences d\u0026rsquo;instructions précises. La lecture et la rédaction de pseudo-codes relativement simples peut être une bonne pratique.\nLe pseudocode est destiné à être lu par l\u0026rsquo;humain, et il peut être écrit de diverses manières tant que l\u0026rsquo;humain le comprend. Le cours ne vise pas à vous permettre de comprendre une syntaxe particulière de pseudocode, mais bien le pseudocode en général.\nQu\u0026rsquo;est-ce qu\u0026rsquo;un algorithme ? # Un algorithme est une suite finie et ordonnée d\u0026rsquo;instructions permettant de résoudre un problème ou d\u0026rsquo;accomplir une tâche spécifique. Il s\u0026rsquo;agit d\u0026rsquo;une méthode systématique, exprimée de manière précise, qui garantit un résultat correct lorsqu\u0026rsquo;elle est exécutée. Les algorithmes sont au cœur de l\u0026rsquo;informatique, car ils décrivent comment un programme doit fonctionner pour atteindre un objectif.\nExemples d\u0026rsquo;algorithmes dans la vie quotidienne :\nUne recette de cuisine (série d\u0026rsquo;étapes pour préparer un plat). Les instructions pour assembler un meuble. En informatique, un algorithme peut, par exemple, trier une liste de nombres ou calculer le chemin le plus court entre deux points.\nQu\u0026rsquo;est-ce que le pseudo-code ? # Le pseudo-code est une manière d\u0026rsquo;écrire un algorithme en utilisant un langage simplifié, proche du langage naturel, mais structuré comme un programme informatique. Il n\u0026rsquo;est pas destiné à être exécuté directement par un ordinateur, mais sert à décrire la logique d\u0026rsquo;un algorithme de manière claire et compréhensible, indépendamment d\u0026rsquo;un langage de programmation spécifique.\nLe pseudo-code utilise des conventions comme :\nSI, ALORS, SINON pour les conditions. POUR, TANT QUE pour les boucles. Des instructions comme écrire ou lire pour les entrées/sorties. Exemple de pseudo-code pour calculer la somme de deux nombres :\nlire nombre1 lire nombre2 somme ← nombre1 + nombre2 écrire somme Le pseudo-code permet aux programmeurs de planifier la logique avant de la traduire dans un langage comme Python, C++ ou Java.\nEn résumé, un algorithme est une méthode pour résoudre un problème, tandis que le pseudo-code est un outil pour exprimer cet algorithme de manière claire et universelle. Ces deux concepts sont essentiels pour concevoir des solutions informatiques efficaces.\nLogique booléenne # Un des fondements des algorithmes est la logique booléenne.\nVoici la table de vérité des principaux opérateurs logiques :\nA B NON A A ET B A OU B vrai vrai faux vrai vrai vrai faux faux faux vrai faux vrai vrai faux vrai faux faux vrai faux faux NON A : l’inverse de A (négation) A ET B : vrai seulement si A et B sont vrais A OU B : vrai si au moins un des deux est vrai Exemple 1 : Contrôle d’accès selon l’âge # lire age SI age \u0026gt;= 18 ALORS écrire \u0026#34;Accès autorisé\u0026#34; SINON écrire \u0026#34;Accès refusé\u0026#34; FIN SI Ce pseudocode décrit un algorithme simple de contrôle d’accès basé sur l’âge d’une personne. L’instruction lire age récupère une valeur (l’âge) entrée par l’utilisateur ou une source externe, stockée dans la variable age. Une structure conditionnelle (SI \u0026hellip; ALORS \u0026hellip; SINON) vérifie si age est supérieur ou égal à 18. Si la condition est vraie (age \u0026gt;= 18), l’algorithme affiche le message \u0026ldquo;Accès autorisé\u0026rdquo;, indiquant que la personne est majeure et peut accéder à une ressource ou un lieu. Sinon, si age est inférieur à 18, il affiche \u0026ldquo;Accès refusé\u0026rdquo;, signalant que l’accès est interdit. L’algorithme se termine après l’affichage.\nExemple 2 : Vérifier si un nombre est dans un intervalle # lire x SI x \u0026gt;= 10 ET x \u0026lt;= 20 ALORS écrire \u0026#34;x est dans l\u0026#39;intervalle [10, 20]\u0026#34; SINON écrire \u0026#34;x n\u0026#39;est pas dans l\u0026#39;intervalle\u0026#34; FIN SI Ce pseudocode décrit un algorithme qui vérifie si une valeur entrée se situe dans l’intervalle fermé [10, 20]. L’instruction lire x récupère une valeur (un nombre, supposé réel ou entier) entrée par l’utilisateur, stockée dans la variable x. Une structure conditionnelle (SI \u0026hellip; ALORS \u0026hellip; SINON) évalue si x satisfait deux conditions combinées par l’opérateur ET : x \u0026gt;= 10 (x est supérieur ou égal à 10) et x \u0026lt;= 20 (x est inférieur ou égal à 20). Si les deux conditions sont vraies, c’est-à-dire si x est dans l’intervalle [10, 20], l’algorithme affiche \u0026ldquo;x est dans l\u0026rsquo;intervalle [10, 20]\u0026rdquo;. Sinon, si x est inférieur à 10 ou supérieur à 20, il affiche \u0026ldquo;x n\u0026rsquo;est pas dans l\u0026rsquo;intervalle\u0026rdquo;. L’algorithme se termine après l’affichage.\ngraph TD A[Lire x] --\u003e B{x \u003e= 10 ET x \u003c= 20 ?} B -- Vrai --\u003e C[\"x est dans l'intervalle\"] B -- Faux --\u003e D[\"x n'est pas dans l'intervalle\"] C --\u003e E[Fin] D --\u003e E Notation des programmeurs # Pour des raisons historiques, les programmeurs remplacent souvent ET par \u0026amp;\u0026amp;, OU par || et NON par !. C\u0026rsquo;est le cas notamment en Java.\nUtilisez l\u0026rsquo;application suivante pour tester votre compréhension.\nCalculateur d'expressions booléennes Sélectionner ou entrer une expression Choisir un exemple... !A || A A \u0026\u0026 B A || B !A \u0026\u0026 B A || !B !(A \u0026\u0026 B) (A || B) \u0026\u0026 !A Générer la table de vérité La boucle # Un algorithme prend habituellement des données et produit un résultat. Par exemple, un algorithme cherchant à déterminer si un nombre est pair, pourra recevoir un nombre en paramètre et il pourra produire comme réponse une valeur booléenne (vrai ou faux). Un même algorithme va donc généralement pouvoir être exécuté sur différentes données et pouvoir fournir des réponses différentes. En ce sens, une fonction (au sens mathématique) comme f(x) = a x + b peut être décrite comme étant un algorithme. Une fonction doit toujours produire la même valeur étant donnée les mêmes données. Un algorithme n\u0026rsquo;est pas limité de cette manière. Par exemple, un algorithme pourrait servir à choisir un nom aléatoirement au sein d\u0026rsquo;une liste. D\u0026rsquo;une exécution à l\u0026rsquo;autre, l\u0026rsquo;algorithme pourrait produire des valeurs différentes avec les mêmes données.\nLa plupart des algorithmes en pratique sont itératifs. Une itération est la répétition d\u0026rsquo;un processus. Si vous devez teindre une clôture, vous allez peut-être teindre chaque planche une à une. Nous dirons alors que vous itérez sur les planches. Mais comment saurez-vous où vous êtes rendu si vous prenez une pause? Peut-être pourrez-vous poser un petit drapeau sur la planche que vous êtes en train de teindre. On dira alors que le drapeau est un itérateur, c\u0026rsquo;est-à-dire un indicateur de votre progrès dans votre itération. À chaque étape où vous déplacez le drapeau d\u0026rsquo;une planche à l\u0026rsquo;autre, nous pourrons dire que vous incrémentez la position du drapeau. Si jamais vous deviez faire un retour à la planche précédente, nous dirons que vous décrémentez le drapeau. En informatique, nous n\u0026rsquo;utilisons pas de drapeaux physiques. Pour savoir où on est rendu, on utilise des compteurs, le plus souvent des valeurs entières. Quand on dit qu\u0026rsquo;on incrémente un entier, on veut généralement dire qu\u0026rsquo;on ajoute \u0026ldquo;1\u0026rdquo; à sa valeur.\nNous obtenons alors la notion de boucle: nous effectuons une tâche donnée tant qu\u0026rsquo;une condition n\u0026rsquo;est pas satisfaite. Cette vidéo présente le concept de boucle.\nEn informatique, on fait souvent référence à la notion d\u0026rsquo;impression à l\u0026rsquo;écran. Le plus souvent cela fait référence à l\u0026rsquo;affichage à l\u0026rsquo;écran d\u0026rsquo;un message ou d\u0026rsquo;un texte.\nTableau # Un tableau est une structure de données qui permet de stocker plusieurs éléments, comme des nombres ou des chaînes de caractères, dans une seule variable. Ces éléments sont organisés séquentiellement et accessibles via un indice, un nombre entier qui indique leur position. Par exemple, dans un tableau nommé tableau, l’élément à la position 1 est noté tableau[1], celui à la position 2 est tableau[2], et ainsi de suite. La taille du tableau est normalement fixée et connue.\nLa numérotation des indices varie selon les langages de programmation ou les contextes. Dans de nombreux langages comme C, Java ou Python, les indices commencent à 0 : le premier élément est tableau[0], le deuxième tableau[1], etc. Cette convention, dite « base 0 », est courante en informatique pour des raisons techniques liées à la gestion de la mémoire. Dans d’autres contextes, comme certaines notations mathématiques ou langages comme Lua, les indices débutent à 1, ce qui peut être plus intuitif pour des utilisateurs non techniques. Le choix de l’index de départ dépend donc du système utilisé, et il est crucial de connaître cette convention pour manipuler correctement les éléments d’un tableau. La convention utilisée est souvent claire selon le contexte.\nCalcul de la moyenne # Pour illustrer la notion de pseudo-code, commençons par un exemple relativement simple. Supposons que nous avons un tableau de notes (par ex., les notes 10.4, 12.6, 18.7, 5.0) et que nous désirons calculer la moyenne. On utilise le convention que si le tableau se nomme \u0026rsquo;notes\u0026rsquo;, alors la première note (par ex., 10.4) est notes[0], la seconde note est notes[1]\u0026hellip; et ainsi de suite jusqu\u0026rsquo;à notes[3]. Évidemment, dans ce cas, on sait qu\u0026rsquo;il y\u0026rsquo;a 4 notes, mais il plus pratique d\u0026rsquo;écrire le pseudo-code de manière générale. On fera donc référence à la longueur du tableau (au nombre d\u0026rsquo;éléments qu\u0026rsquo;il contient) comme étant un paramètre. Pour visiter tous les éléments, on peut initialiser une valeur entière à 0, et l\u0026rsquo;incrémenter de 1 tant qu\u0026rsquo;elle demeure plus petite que la longueur du tableau.\ngraph TD A[Début] --\u003e B[Initialiser iterateur = 0, moyenne = 0] B --\u003e C{iterateur \u003c longueur de notes ?} C -- Vrai --\u003e D[\"moyenne = moyenne + notes[iterateur]\"] D --\u003e E[iterateur = iterateur + 1] E --\u003e C C -- Faux --\u003e F[moyenne = moyenne / longueur de notes] F --\u003e G[Afficher moyenne] G --\u003e H[Fin] Utilisez l\u0026rsquo;application suivante pour explorer l\u0026rsquo;exécution de l\u0026rsquo;algorithme. Ce pseudocode calcule la moyenne de quatre nombres rationnels stockés dans un tableau notes. Une variable iterateur est initialisée à 0 pour parcourir le tableau, et une variable moyenne est initialisée à 0 pour accumuler la somme des éléments. La boucle (TANT QUE iterateur \u0026lt; la longueur de notes FAIRE) itère tant que iterateur est inférieur à la longueur du tableau (ici, 4). À chaque itération, l’élément notes[iterateur] est ajouté à moyenne, et iterateur est incrémenté de 1. Une fois la boucle terminée, la somme totale des éléments est stockée dans moyenne. Enfin, moyenne est divisée par la longueur du tableau (moyenne = moyenne / la longueur de notes) pour obtenir la moyenne arithmétique. Le résultat, un nombre rationnel, est la sortie.\nCalcul de la moyenne Entrez un tableau de nombres rationnels séparés par des virgules et exécutez le pseudocode pour calculer la moyenne.\nPseudocode\nTableau de quatre nombres rationnels : notes Variables : Nombre entier : iterateur = 0 Nombre rationnel : moyenne = 0 Sorties : Nombre rationnel : moyenne TANT QUE iterateur \u003c la longueur de notes FAIRE moyenne = moyenne + notes[iterateur] iterateur = iterateur + 1 FIN TANT QUE moyenne = moyenne / la longueur de notes État\nTableau : []\nItérateur : 0\nMoyenne : 0\nProchaine étape Réinitialiser Observez comment on termine la boucle \u0026ldquo;TANT QUE\u0026rdquo; avec une ligne \u0026ldquo;FIN TANT QUE\u0026rdquo;. Ce n\u0026rsquo;est pas nécessaire, mais vous devez être clair et précis quant au début et à la fin de vos opérations. On peut aussi indiquer le début et la fin d\u0026rsquo;une boucle avec l\u0026rsquo;indentation, ou tout autre moyen compris par les êtres humains. L\u0026rsquo;expression \u0026ldquo;TANT QUE\u0026rdquo; est associée à une condition qui peut être vraie ou fausse. L\u0026rsquo;exécution se poursuit tant que l\u0026rsquo;expression est vraie, et elle se termine lorsque l\u0026rsquo;expression est fausse.\n"},{"id":35,"href":"/inf1220-hugo/docs/modules/module2/methodes/","title":"Méthodes et constructeurs","section":"Module 2: Introduction au langage Java","content":" La conception de méthodes/fonctions et leur appel # La conception de méthodes (ou fonctions) est un pilier de la programmation structurée et orientée objet. Une méthode permet d’isoler une opération ou un calcul précis, de lui donner un nom, et de la réutiliser à volonté dans différents contextes du programme. Cela favorise la clarté, la maintenance et la réutilisabilité du code. Lorsqu’on appelle une méthode, on peut lui transmettre des informations (paramètres) et récupérer un résultat (valeur de retour). En Java, chaque méthode appartient à une classe : elle définit le comportement que les objets de cette classe peuvent adopter ou les opérations qu’ils peuvent effectuer. Bien concevoir ses méthodes, c’est donc apprendre à découper un problème en sous-tâches logiques, à nommer clairement les opérations, et à limiter la duplication de code.\nLes méthodes # Dans la plupart des langages de programmation modernes, il est possible de subdiviser le code en plusieurs sections appelées méthodes ou fonctions (le terme méthode est spécifique au langage Java, mais le terme fonction peut-être également utilisé). L'avantage est double, ces méthodes permettent une meilleure lecture du code et permet de généraliser et réutiliser des portions de code fréquent. De plus, en programmation orientée objet, l'utilisation de méthodes est parfois appelée un passage de message. Ainsi, une classe peut offrir différentes méthodes à l'application qui peuvent être appelées en envoyant à celle-ci un message et des paramètres (ou non). De plus, la bibliothèque de code standard de Java, appelé Application programming interface (API), fournit plusieurs classes utiles telles que des structures de données (ex. ArrayList, Hashmap), des types avancés (ex. les chaînes de caractères String ou StringBuffer), des outils de gestion de flux de données (ex. pour l'écriture et la lecture dans les fichiers (ex. FileReader, FileInputStream). Chacune des classes de l'API offre un ensemble de méthodes pouvant être appelées pour une tâche ou un traitement donné. Voici un exemple d'appel de méthode avec la classe String : ExempleMethode.java public class ExempleMethode { public static void main(String[] args) { String texte = \u0026#34;Veni, vidi\u0026#34;; texte = texte.concat(\u0026#34;, vici\u0026#34;); System.out.println(texte); String autreTexte = \u0026#34;J\u0026#39;aime les patates\u0026#34;; System.out.println(\u0026#34;Textes égaux ? :\u0026#34; \u0026#43; texte.equals(autreTexte)); } } Exécuter Avec les versions plus récentes de Java (Java 26 et mieux), il est possible d\u0026rsquo;omettre le nom de la classe comme ceci:\nExempleMethode.java void main() { System.out.println(\u0026#34;Bonjour, le monde !\u0026#34;); int x = 5; int y = 10; int sum = x \u0026#43; y; System.out.println(\u0026#34;La somme de \u0026#34; \u0026#43; x \u0026#43; \u0026#34; et \u0026#34; \u0026#43; y \u0026#43; \u0026#34; est : \u0026#34; \u0026#43; sum); } Exécuter Par contre, cette nouvelle syntaxe ne s\u0026rsquo;applique que dans des cas simples. En pratique, il est quasiment toujours nécessaire de spécifier le nom de la classe.\nLa définition d\u0026rsquo;une méthode/fonction simple # Une méthode est une suite d'instructions englobées dans un bloc {} permettant de réaliser une opération donnée. De façon générale, la syntaxe d'une méthode est la suivante :\npublic static typeretourné nomdelafonction(la liste des paramètrés){ //instructions } Vous trouverez ci-dessous la description de la définition de la méthode précédente :\npublic : tout programme Java a accès à cette fonction. Nous verrons plus loin d'autres types d'accès (protected, private).\nstatic : indique que la fonction que nous avons définie est statique, c'est-à-dire qu'elle peut être appelée sans la création d'une instance de la classe dans laquelle elle est définie. Si le mot-clé static n'est pas utilisé, alors il faut créer une instance de la classe où la méthode est définie. À ce moment, la méthode sera appelée pour l'instance de la classe spécifique. Pour pouvoir appeler une fonction qui n'est pas static, il faut absolument disposer d'une instance de la classe. Une fonction qui est static peut être appelée sans instance de la classe. typeretourné : c'est le type de la variable retournée par la fonction. Si la fonction ne retourne rien, il faut utiliser le mot clé void.\nnomdelafonction : Il faut choisir un nom assez explicite pour la fonction. Il faut également uniformiser la nomenclature des fonctions dans tout le programme afin d'en faciliter le débogage. Il est recommandé d'utiliser la convention mixed-Case, selon laquelle il est recommandé d'écrire le premier mot complètement en minuscule. Il existe plusieurs conventions et recommandations pour la nomenclature des différents éléments d'un programme, voici celle de l'entreprise Google pour le langage Java https://google.github.io/styleguide/javaguide.html#s5-naming\nla liste des paramètres : La liste peut contenir plusieurs paramètres. Elle permet à Java de savoir quels types de paramètres sont reçus par la fonction, de même que leur nom. Alors, les instructions reçues par la fonction pourront utiliser ces paramètres comme des variables locales. Par contre, si la fonction n'accepte pas de paramètres, elle est définie ainsi :\npublic static typeretourné nomDeLaFonction(){ //instructions } Voici un exemple présentant une classe avec deux types de méthode (static et non static) :\nTransformeurTexte.java public class TransformeurTexte { protected String texte = \u0026#34;\u0026#34;; // Méthode pour inverser un texte public static String inverserTexte(String texte) { String texteRenverse = new String(); for (char c : texte.toCharArray()) { texteRenverse = c \u0026#43; texteRenverse; } return texteRenverse; } public String getTexte() { return texte; } public void setTexte(String texteInstance) { this.texte = texteInstance; } public void transformerTexteEnHTML() { texte = \u0026#34;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;p\u0026gt;\u0026#34; \u0026#43; texte \u0026#43; \u0026#34;\u0026lt;/p\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;; } public static void main(String[] args) { String test = \u0026#34;ohohoh\u0026#34;; System.out.println(inverserTexte(test)); TransformeurTexte transformeur = new TransformeurTexte(); transformeur.setTexte(\u0026#34;Bonjour le monde!\u0026#34;); transformeur.transformerTexteEnHTML(); System.out.println(transformeur.getTexte()); } } Exécuter Dans la classe TransformeurTexte, la référence this est utilisée dans la méthode setTexte pour désigner l\u0026rsquo;instance actuelle de la classe. La référence this représente l\u0026rsquo;instance actuelle de la classe TransformeurTexte sur laquelle la méthode setTexte est appelée. La référence this ne peut être utilisée que dans un contexte non statique.\nPeu importe l'environnement que vous utilisez pour tester nos exemples, prenez la peine de vous familiariser avec celui-ci.\nPrenez note que sur repl.it, la méthode main est définie dans une classe distincte appelée Main. La classe TransformateurTexte doit apparaître dans un fichier nommé TransformateurTexte.java selon les conventions propres au Java.\nLa structure d\u0026rsquo;une méthode # Nous avons appris précédemment que la définition d'une fonction suivait le modèle général : typeretourné nomdelafonction(arg1,arg2…)\nSi vous utilisez un type de retour autre que void dans le corps de la définition de la fonction, vous devez avoir l'expression retournée. Cela prend la forme suivante : \"return expression;\" La variable \"expression\" doit être du même type que le \"typeretourné\" par la fonction. Donc si typeretourné est int alors expression est de type int également.\nLe programme ci-dessous illustre l'utilisation d'une fonction avec type retourné :\nNombreAleatoire.java public class NombreAleatoire { public static int getNombreAleatoire() { int num = (int)(Math.random() * 10) \u0026#43; 1; return num; } public static void main(String[] args) { int nombre = getNombreAleatoire(); System.out.println(\u0026#34;le nombre est \u0026#34; \u0026#43; nombre); } } Exécuter L'exemple de code ci-dessous présente une méthode avec plusieurs paramètres:\nExercice.java public class Exercice { public static String fusionDeTexte(String texte1, String texte2) { return texte1 \u0026#43; \u0026#34;::\u0026#34; \u0026#43; texte2; } public static void main(String[] args) { String bonjourTexte = \u0026#34;Bonjour\u0026#34;; String hiTexte = \u0026#34;Hi\u0026#34;; System.out.println(fusionDeTexte(bonjourTexte, hiTexte)); } } Exécuter Nous pouvons catégoriser les fonctions de la façon suivante :\nsi la fonction ne retourne aucune valeur, alors on utilise le mot-clé void au lieu de typeretourné; si la fonction retourne un type de valeur, ce type remplace typeretourné dans la définition de la fonction; si la fonction ne reçoit aucun paramètre, on affiche des parenthèses vides au nom de la fonction; si la fonction reçoit plusieurs paramètres, on place ces paramètres séparés par des virgules entre parenthèses après le nom de la fonction. En pratique, une fonction est très souvent une combinaison de deux des catégories ci-dessus. Si on veut qu'une fonction retourne plusieurs valeurs, on doit créer un nouveau type représentant une entité contenant toute l'information qu'on désire récupérer et on se sert de ce nouveau type comme type de retour.\nEnfin, en Java les paramètres passés aux méthodes le sont par valeur lorsqu'il s'agit de type primaire, mais par référence lorsqu'il s'agit d'instance de classes, contrairement à d'autres langages (ex. C++). C'est à dire que si une méthode vient manipuler une instance d'un objet dans une méthode, alors cette valeur est également modifiée à l'extérieur de la portée (scope) de la méthode, car la valeur a été modifiée à l'adresse mémoire dans le programme. Toutefois, ce n'est pas le cas pour des paramètres type primaire (int, float, char, boolean, etc). En somme, les valeurs correspondant aux types primaires sont passées par valeur (la modification a une portée locale), mais pour le reste, c'est par référence et la modification a une portée qui excède la fonction. Voici un exemple pour illustrer le comportement du passage de paramètre en référence :\nExercice.java public class Exercice { protected int compteur = 0; public static void mettreDesPointsExclamations(StringBuffer texte) { // On modifie le texte texte.insert(0, \u0026#34;!!!\u0026#34;); texte.append(\u0026#34;!!!\u0026#34;); } public static void main(String[] args) { StringBuffer test = new StringBuffer(\u0026#34;Bonjour\u0026#34;); System.out.println(test); mettreDesPointsExclamations(test); System.out.println(test); } } Exécuter Pour éviter des effets de bord difficiles à comprendre lors de modification de paramètres dans une fonction, il est possible d'éviter de modifier les valeurs des paramètres en faisant une copie locale comme dans cet exemple : Exercice.java public class Exercice { protected int compteur = 0; public static StringBuffer mettreDesPointsExclamations(StringBuffer texte) { StringBuffer copieLocal = new StringBuffer(texte.toString()); copieLocal.insert(0, \u0026#34;!!!\u0026#34;); copieLocal.append(\u0026#34;!!!\u0026#34;); return copieLocal; } public static void main(String[] args) { StringBuffer test = new StringBuffer(\u0026#34;Bonjour\u0026#34;); System.out.println(test); StringBuffer texteModifie = mettreDesPointsExclamations(test); System.out.println(texteModifie); } } Exécuter Surdéfinition de méthodes # Ce qui distingue les méthodes dans une classe sont : le nom de la méthode, le type de retour (void ou autres) et ses paramètres. Il peut être utile d'avoir plusieurs méthodes avec le même nom, ayant sensiblement le même comportement/action mais dont les paramètres en entrées sont différents. Ceci permet de spécialiser certaines méthodes pour le traitement de certains types de données. Voici un exemple de surdéfinition de méthodes :\nFusionDonnees.java public class FusionDonnees { protected String texte = \u0026#34;\u0026#34;; public String getTexte() { return texte; } public void setTexte(String texte) { this.texte = texte; } public String fusion(String autreTexte) { return texte \u0026#43; \u0026#34;|\u0026#43;s|\u0026#34;\u0026#43; autreTexte; } public String fusion(int entier) { return texte \u0026#43; \u0026#34;|\u0026#43;i|\u0026#34; \u0026#43; Integer.toString(entier); } public static void main(String[] args) { String hiTexte = \u0026#34;Hi\u0026#34;; FusionDonnees fusionneur = new FusionDonnees(); fusionneur.setTexte(\u0026#34;Bonjour\u0026#34;); System.out.println(fusionneur.fusion(hiTexte)); System.out.println(fusionneur.fusion(13)); } } Exécuter Signature d\u0026rsquo;une méthode # Chaque classe donnée ne peut avoir qu\u0026rsquo;une seule méthode ayant une certaine signature. La signature d\u0026rsquo;une méthode est la combinaison du nom de la méthode et de la liste (et l’ordre) des types de ses paramètres. Cela signifie que deux méthodes d’une même classe peuvent porter le même nom, à condition qu’elles aient des paramètres de types ou d’ordre différents : c’est la surcharge de méthodes (overloading). La signature ne tient pas compte du type de retour de la méthode ni des modificateurs d’accès (public, private, etc.).\nvoid afficher(String message) void afficher(int nombre) void afficher(String message, int nombre) Ici, chaque méthode a une signature différente, même si le nom est identique.\nVidéos # Lecture optionnelle dans le livre de référence (Delannoy) # Pour aller plus en profondeur sur les méthodes/fonctions. Veuillez lire dans Programmer en Java de Claude Delannoy, Chapitre 6:\nSection 6 : Règles d'écriture des méthodes Section 7 : Champs et méthodes de classe Section 8 : Surdéfinition de méthodes Section 9 : Échange d'informations avec les méthodes Les constructeurs # Pour les types élémentaires comme int et float, on peut créer une nouvelle instance, une nouvelle valeur directement par assignation: « float x = 1.0f; ». Les autres types (c'est-à-dire les instances de classe) sont définis par une classe Java et doivent être créés avec une fonction particulière appelée constructeur. Ces fonctions prennent le nom de la classe comme nom, ne possèdent pas de type de retour (void ou autre) et peuvent posséder plusieurs paramètres ou aucun. Il est également possible pour une même classe d'avoir plusieurs constructeurs avec des paramètres différents. Les constructeurs sont appelées lors de la création d'une instance d'une classe à l'aide du mot-clé « new ». L'appel du mot-clé « new » retourne une nouvelle instance de la classe créée par l'entremise de l'appel d'un constructeur: par exemple, l'appel « MaClasse x = new MaClasse(1) » pourra appeler le constructeur « public MaClasse(int x) ». Toute instance d'une classe doit avoir été créée par l'appel d'un constructeur. Si une classe ne comprend aucun constructeur explicite, Java va y ajouter un constructeur implicite qui ne prend aucun paramètre. Le constructeur par défaut ne va pas apparaître dans votre code, Java s'en charge. Le constructeur doit initialiser (donner une valeur) aux attributs de la classe. Une fois que le constructeur s'est exécuté, l'instance de classe doit être utilisable. Voici un exemple de constructeurs et leur utilisation :\nClient.java public class Client { public static final String DEBUTLOG = \u0026#34;Client :\u0026#34;; public static final String SEPARATEUR = \u0026#34;|*|\u0026#34;; public int id; public String prenom; public String nom; public boolean clientActif; public Client() { id = (int)(Math.random() * 1000) - 1; prenom = \u0026#34;John\u0026#34;; nom = \u0026#34;Doe\u0026#34;; clientActif = false; } public Client(int id, String prenom, String nom) { this.id = id; this.prenom = prenom; this.nom = nom; clientActif = true; } public static void main(String[] args) { Client unClient = new Client(); Client unAutreClient = new Client(44, \u0026#34;Charlie\u0026#34;, \u0026#34;Chaplin\u0026#34;); System.out.println(Client.DEBUTLOG \u0026#43; unClient.id \u0026#43; Client.SEPARATEUR \u0026#43; unClient.prenom \u0026#43; Client.SEPARATEUR \u0026#43; unClient.nom); System.out.println(DEBUTLOG \u0026#43; unAutreClient.id \u0026#43; Client.SEPARATEUR \u0026#43; unAutreClient.prenom \u0026#43; Client.SEPARATEUR \u0026#43; unAutreClient.nom); } } Exécuter À moins de ne programmer qu'avec des types de base (int, float, etc.), vous n'avez pas le choix en Java: il faut appeler des constructeurs, ne serait-ce que les constructeurs par défaut. Contrairement aux méthodes, les constructeurs doivent avoir le même nom que la classe et ils ne renvoient aucune valeur explicitement. Pour une même instance de classe, le constructeur n’est appelé qu’une seule fois alors que les méthodes peuvent être appelées plusieurs fois.\nLecture optionnelle # Constructeur (programmation) (Wikipédia) Est-ce qu\u0026rsquo;on doit toujours construire ses propres classes en Java? # Le langage de programmation java vous incite à créer vos propres classes, avec des méthodes et des attributs correspondants à votre problème. Est-ce toujours nécessaire ou souhaitable?\nLa réponse est négative. Pour les problèmes simples qui peuvent être résolus avec une, deux ou trois petites fonctions statiques, il n'est souvent pas nécessaire ou souhaitable de créer une classe sur mesure. La règle d'or en programmation est que la solution la plus simple est la préférable.\nLe langage de programmation Java est fortement axé sur la programmation orientée objet, mais cette stratégie de programmation ne doit pas être utilisée plus que nécessaire. Une solution comprenant plusieurs classes sur mesure n'est pas nécessairement meilleure. Plusieurs langages de programmation populaires comme le C, le Rust, le JavaScript conventionnel, le Go, etc. n'ont même pas de notion de classe. Il n'est donc pas nécessaire, quand on programme, de toujours créer des classes sur mesure.\nAlors pourquoi est-ce qu'on vous demande d'en apprendre autant sur les classes, les constructeurs, etc.? Parce que c'est une technique de programmation répandue et parfois incontournable. En Java, si vous ne comprenez pas les notions de classe, méthode et constructeur, vous ne pourrez pas aller bien loin. Dès que les problèmes deviennent complexes, vous devrez créer des classes.\nConcrètement, dans ce cours, vous ne serez jamais pénalisé si vous écrivez des programmes Java qui répondent aux consignes sans nécessairement créer plus de classes que nécessaire. Par contre, il est probable que vous ne pourrez pas réussir le cours si vous ne comprenez pas les notions de classe, constructeur et méthode.\nVidéos # Il y a une liste de vidéos sur le sujet des constructeurs par Sam et al. Lecture optionnelle dans le livre de référence (Delannoy) # Pour aller plus en profondeur sur les constructeurs (optionnel), vous pouvez lire dans Programmer en Java de Claude Delannoy, Chapitre 6:\nSection 2 : La notion de constructeur "},{"id":36,"href":"/inf1220-hugo/docs/modules/module5/","title":"Module 5. La programmation orientée objet: héritage et le polymorphisme","section":"Modules","content":" Module 5 # Le module 5 initie à la programmation orientée objet en explorant des concepts fondamentaux : l’héritage, les interfaces et le polymorphisme. L’héritage permet de créer des classes dérivées qui réutilisent et étendent les propriétés et comportements de classes existantes. Les interfaces permettent de définir des contrats (ensembles de méthodes) que plusieurs classes peuvent implémenter, sans imposer d’héritage de l’implémentation. Elles favorisent la flexibilité, la réutilisation du code, car une même interface peut être partagée par des classes n’ayant pas de lien hiérarchique direct. Le polymorphisme, quant à lui, offre la possibilité d’utiliser des objets de différentes classes de manière uniforme, en s’appuyant sur des interfaces ou des classes parentes. À travers des exemples pratiques issus du manuel Java pas à pas et du site du cours, ce module enseigne comment appliquer ces principes pour construire des programmes Java structurés, flexibles et maintenables.\nObjectifs du module # À la fin de ce module, vous serez capable de :\nExpliquer les principes de l’héritage et du polymorphisme en programmation orientée objet (POO). Concevoir des hiérarchies de classes en Java en utilisant l’héritage pour factoriser et réutiliser du code. Utiliser le polymorphisme pour manipuler des objets de différentes classes via des références communes (interfaces, classes abstraites). Implémenter et utiliser des interfaces pour définir des comportements communs à plusieurs classes. Comprendre et appliquer le principe de substitution de Liskov (LSP) dans la conception de classes. Identifier les avantages et les limites de l’héritage et du polymorphisme dans la conception de programmes robustes et évolutifs. Résoudre des problèmes concrets en appliquant ces concepts à travers des exercices et des projets Java. "},{"id":37,"href":"/inf1220-hugo/docs/modules/examen/","title":"Examen","section":"Modules","content":" Examen final # L\u0026rsquo;objectif principal de l\u0026rsquo;examen est de valider le savoir-faire que vous avez intégré tout au long du cours. Comme la question revient sans cesse, soyons clair sur ce point: l'examen couvre toute la matière du cours. Prenez note qu'il est permis d'utiliser le robot conversationnel du cours lors de l'examen. Cependant vous devez produire vos propres réponses et vos propres analyses.\nSi vous ne maîtrisez pas la matière du cours, vous ne réussirez probablement pas l'examen. Prenez le temps d'étudier, de réviser et de poser des questions le cas échéant. Pratiquez-vous à programmer.\nQuand il s'agit de programmer, plusieurs étudiants remettent du code qui n'est pas fonctionnel, qui ne peut en aucun cas répondre à la question. Vous devez autant que possible vous assurez que votre code est fonctionnel. Pour y arriver, vous pouvez le relire et l'exécuter dans votre esprit, en traçant la valeur des variables. Comme vous devez de toute manière toujours expliquer vos solutions, vous pouvez en profiter pour y inclure une séquence d'exécution de votre programme. Un programmeur doit toujours se relire, et tester, et retester son code. Il est facile de se tromper complètement en écrivant même du code simple si on ne se relit pas avec soin.\nEntretien de suivi # Vérifiez si vous êtes dans une version du cours qui nécessite un entretien de suivi. Vous trouverez cette information sur le portail étudiant. En cas de doute, vous pouvez communiquer avec la personne qui vous encadre au sein du cours.\nSi vous êtes inscrits dans un version du cours avec entretien de suivi, cet entretien est est obligatoire. L'entretien de suivi sert à confirmer votre identité et à démontrer que vous êtes bien la personne ayant réalisé cet examen.\nQu’est-ce que l’entretien de suivi? # L’entretien de suivi est une rencontre individuelle d’environ 15 minutes, par visioconférence, avec la personne qui a corrigé votre examen final. Durant cette discussion, vous avez à présenter une pièce d’identité. Ensuite, une discussion permet de s'assurer que vous êtes bien la personne qui a réalisé l’examen. Par exemple, on peut vous demander d’expliquer une réponse.\nL’entretien de suivi est-il obligatoire? # Oui. L'entretien de suivi constitue une étape obligatoire. Si vous ne vous présentez pas à l’entretien de suivi ou si n’êtes pas en mesure de présenter de pièce d’identité avec photo, la note 0 sera attribuée à votre examen.\nÀ quel moment se tient-il? # Une fois votre examen corrigé, vous disposez de trois jours ouvrables pour prendre un rendez-vous. Vous pouvez écrire à la personne qui vous encadre ou vous pouvez le faire dans votre portail si cette personne affiche ses disponibilités.\nComment se déroule-t-il? # Vous validez d’abord votre identité à l’aide d’une pièce d’identité avec photo. Ensuite, quelques questions vous sont posées dans le seul but de s’assurer que vous êtes bien la personne qui a réalisé l’examen.\nDois-je me préparer à l\u0026rsquo;entretien de suivi? # Aucune préparation n’est nécessaire.\nL’entretien de suivi est-il noté? # Oui. L’entretien de suivi fait l’objet d’une notation indiquant votre capacité d’expliquer vos réponses à l’examen de vive voix. Dans quelles conditions est-ce que l’entretien de suivi peut mener à une note de zéro dans le cours? # Vous ne vous présentez pas à l'entretien; Vous ne présentez pas de pièce d'identité avec photo; Il y a apparence d’infraction liée aux études. En cas d’irrégularité, un dossier de dénonciation pour infraction à l’intégrité intellectuelle pourrait être déposé. Qui puis-je contacter si j’ai des questions? En cas de besoin, n’hésitez pas à communiquer avec la personne responsable de votre encadrement.\nSe préparer # Les étudiants qui passent un examen en ligne doivent s'assurer d'avoir un environnement adéquat. Il se peut que vous deviez programmer pendant l'examen en ligne sur votre ordinateur: il est de votre responsabilité d'avoir un ordinateur configuré d'une manière efficace avec un bon clavier et tous les logiciels dont vous avez besoin. Si vous travaillez sur un ordinateur portable, gardez-le sous tension. Assurez-vous de travailler sur un ordinateur stable. Au besoin, prévoyez un second ordinateur. Assurez-vous d'avoir une bonne connection Internet avec une solution de rechange (par exemple, un branchement par l'entremise de votre téléphone cellulaire). Pour les étudiants qui passent l'examen en salle, assurez-vous d'arriver à l'heure et d'être bien reposé.\nNous comprenons que la vie vous réserve des surprises. Parfois un logiciel plante. Parfois il faut redémarrer un ordinateur et ainsi de suite. Néanmoins, vous êtes responsable d'être bien préparé.\nGestion du temps à l\u0026rsquo;examen # L'examen peut comporter plusieurs questions de programmation. Vous devez donc pouvoir fournir en quelques minutes du code fonctionnel ainsi que des explications précises. Vous devez donc pouvoir écrire un programme Java correct et l'expliquer en une trentaine de minutes. Même quand vous avez le droit à de la documentation lors de l'examen, vous n'avez néanmoins pas le temps de faire de la lecture. Vous devez donc arriver bien entraîné et bien préparé.\nExamen factice 1 # Pour vous pratiquer pour l'examen, prenez un maximum de trois heures pour répondre aux six questions suivantes :\nÉcrivez une fonction Java qui, étant donné une chaîne de caractères, retourne la même chaîne de caractères mais inversée. Par exemple, la fonction doit transformer la chaîne \"un chien\" en la chaîne \"neihc nu\". Vous pouvez faire l'hypothèse que les caractères de la chaîne originale se représentent tous en 2 octets selon la norme UTF-16. Écrivez une fonction Java qui prend un tableau d'entier et compte le nombre d'entiers négatifs. Écrivez une classe qui va lire, dans son constructeur, les chaînes de caractères trouvées dans un fichier texte. Le constructeur doit prendre le nom du fichier en argument. La classe doit être munie d'une méthode enregistre prenant un nom de fichier en paramètre. Lorsque la méthode enregistre est invoquée, les chaînes de caractères chargées par le constructeur sont écrites dans un fichier texte prenant le nom de fichier fourni à la méthode enregistre. Il doit être possible, en appelant la méthode enregistre ainsi qu'un constructeur de dupliquer une instance de classe. Écrivez une fonction Java qui, étant donné un tableau d'entier, calcule la moyenne des valeurs, sous la forme d'un nombre à virgule flottante. Mettez en oeuvre le jeu Fizz Buzz à l'aide d'une fonction Java, affichant les nombre de un à cent, en y ajoutant Fizz quand le nombre est divisible par trois et Buzz quand le nombre est divisible par cinq. Écrivez un programme Java qui utilise FileOutputStream et FileInputStream pour écrire une séquence de nombres entiers dans un fichier binaire, puis la relire. Gérez les exceptions. Dans tous les cas, vous devez expliquer vos solutions et produire du code valable.\nVous devriez arrivez sans mal à produire les solutions attendues en moins de 3 heures. Si vous n'y arrivez pas, c'est que vous manquez de pratique.\nExamen factice 2 # Pour vous pratiquer pour l'examen, prenez un maximum de trois heures pour répondre aux six questions suivantes :\nÉcrivez une classe « Tableau » munie d'une fonction « unique » qui prend comme paramètre un tableau (String[] t). La fonction doit trouver le nombre de valeurs répétées consécutivement dans le tableau. Une valeur est répétée si la valeur précédente lui est identique. Ainsi donc, étant donné le tableau {\"bah\", \"bah\", \"be\", \"bo\", \"bo\", \"bo\"}, votre fonction doit retourner l’entier 3 puisqu’il y a trois valeurs répétées. Écrivez une fonction occurrences(String s, char c) qui prend deux paramètres : une chaine de caractères et un caractère. Elle doit retourner un tableau comprenant les indices correspondant aux occurrences du caractère (second paramètre) dans la chaîne (premier paramètre). Les indices doivent être des entiers de 1 à s.length() inclusivement. Écrivez un programme qui demande à l’utilisateur de fournir un entier positif. Le programme doit vérifier si l’entier en question est un nombre premier. Un nombre premier n’est divisible que par lui-même et par le nombre 1. Écrivez un programme Java qui demande à l'utilisateur de choisir un nombre impair entre 0 et 100. Le programme doit ensuite offrir à l'utilisateur un nombre impair entre 0 et 100 et demander à celui-ci si le nombre choisi est (a) plus petit (b) plus grand ou (c) identique au nombre offert par le programme. Le programme doit continuer tant que la bonne valeur n'est pas trouvée par le programme informatique. Votre mise en œuvre doit être efficace pour obtenir tous les points. Vous devez pleinement expliquer votre solution. Créez une classe « Fruit » dotée de deux méthodes non-statiques nommées « mange » et « jette ». Les méthodes ne doivent prendre aucun paramètre et ne retourner qu’un entier. La méthode « mange » doit retourner le nombre de fois qu'elle a été appelée pendant la vie de l'objet (instance de classe) courante. La méthode « jette » doit retourner le nombre de fois qu'elle a été appelée, toutes instances confondues. Votre code doit inclure une méthode « main » qui démontre que le code répond bien à la question. Vous devez par ailleurs expliquer (en prose française) votre solution. Si votre explication est manquante ou peu claire, une note de zéro pourra être attribuée. Décrivez l’utilisation de la classe RandomAccessFile pour manipuler un fichier à adressage relatif. Donnez-un exemple de code. Dans tous les cas, vous devez expliquer vos solutions et produire du code valable.\nVous devriez arrivez sans mal à produire les solutions attendues en moins de 3 heures. Si vous n'y arrivez pas, c'est que vous manquez de pratique.\nPour se pratiquer à programmer # Si vous avez fait toutes les lectures, les deux examens factices, tous les exercices et tous les travaux du cours honnêtement, alors vous êtes prêt pour l'examen. Certains étudiants souhaitent se pratiquer davantage. Voici quelques suggestions de problèmes supplémentaires pour réviser:\nÉcrivez un programme qui lit un fichier contenant un mot par ligne et qui affiche les mots en question dans le sens inverse (en commençant par le dernier mot). Écrivez un programme qui calcule la somme des 100 premiers entiers divisibles par 3. Écrivez une fonction qui trouve dans une liste la valeur de tous les éléments répétés (par exemple dans 1,2,2,3,4, le nombre 2 est répété). Expliquez la différence entre une variable (attribute) statique (static) et une variable normale. Est-ce qu'une classe peut avoir plus d'un constructeur? Étant donné deux variables entières, i et j, je peux toujours calculer i/j? (vrai ou faux, expliquez) Combien de bits utilise le type double en Java? N'oubliez pas de tester vos solutions. S'il s'agit de produire du code Java, alors exécutez le code Java et passez du temps avec le programme pour vous assurez qu'il fait ce qu'il doit faire. C'est une erreur commune chez les étudiants d'aller trop rapidement et de supposer que parce que le programme a l'air correct, il doit être correct. Non! Testez et testez encore.\nLe projet Euler offre des centaines de problèmes similaires à ceux qui sont utilisés dans le cours.\nCertains étudiants apprécient JetBrains Academy (en anglais) qui offre certaines formations élémentaires en Java. Il y a aussi plusieurs manuels (en anglais) dédiés aux exercices que vous pouvez acquérir :\nJava Coding Problems: Improve your Java Programming skills by solving real-world coding challenges Java Cookbook: Problems and Solutions for Java Developers Les reports de la date de fin de cours # Rappel: L'enseignant ne peut modifier votre date de fin de cours peu importe votre situation. Le moment après la date de fin de cours où votre dossier est fermé et où vous recevez (éventuellement) un incomplet est géré par l'Université. Il est de votre responsabilité de bien planifier votre temps. Si vous avez des problèmes personnels qui limitent vos progrès (maladie, deuil, etc.), il faut voir avec l'Université: les enseignants n'ont aucune prise sur les dates de fin, sur les dates d'examen, etc.\nVotre date de fin de cours est inscrite dans votre dossier et vous pouvez la trouver sur le portail étudiant et sur la documentation qu'on vous a remise lors de votre inscription. Il est possible que votre examen ait lieu des semaines ou même des mois après votre date de fin de cours: cela ne constitue pas une extension de votre date de fin de cours. Tout travail remis après votre date de fin de cours pourra recevoir la note de zéro. En tout temps, la note «\u0026nbsp;incomplet\u0026nbsp;» peut être attribuée à un travail qui n'est pas remis après votre date de fin de cours, même si vous n'avez pas encore passé l'examen.\nDéroulement et le jour de l\u0026rsquo;examen # Le déroulement de l'examen, incluant sa date et son heure, est géré par l'Université. Il est inutile d'écrire à l'enseignant pour savoir quand votre examen aura lieu ou pour en changer la date. Si vous avez des questions au sujet de la plateforme technologique ou au sujet de l'heure de l'examen, il faut voir avec l'Université et au sein du portail étudiant. Par exemple, dans le portail étudiant, sous Dossier administratif, il est possible que vous trouviez une option pour modifier une date d’examen.\nL'enseignant ne peut changer la date, le lieu ou l'heure de votre examen. Il ne contrôle pas l'environnement technologique lors de l'examen. Un service distinct et indépendant au sein de l'Université gère les examens.\nRésultat et rétroaction sur l\u0026rsquo;examen # Une fois l'examen corrigé, vous trouverez votre note dans le portail étudiant. L'enseignant ne transmet jamais les examens (corrigés ou pas) par courriel. Si vous avez des questions suite à votre examen, il nous fera un plaisir d'en discuter avec vous. Nous ne transmettons toutefois jamais le corrigé de l'examen (à quiconque, et il n'y a pas d'exception).\nRétroaction sur le cours # N\u0026rsquo;oubliez pas que nous tenons compte de votre opinion. Si vous avez des critiques constructives, remplissez le formulaire à cet effet.\nVous avez aimé le cours ? # Si vous avez aimé le cours\u0026hellip;\nParlez du cours autour de vous, laissez des remarques positives en ligne. Consultez la page professeur et les autres cours qu\u0026rsquo;il a conçu. Si vous avez un compte sur GitHub, suivez-y le professeur. (Bouton follow.) Si vous lisez l\u0026rsquo;anglais, abonnez-vous au blog du professeur. Vous pouvez suivre le professeur sur X. Laissez une évaluation positive sur la page du manuel chez Amazon. Consultez les autres livres écrits par le professeur "},{"id":38,"href":"/inf1220-hugo/docs/modules/module2/exercices-2-2/","title":"Exercices sur les classes et méthodes","section":"Module 2: Introduction au langage Java","content":" Questions/Réponses # Veuillez répondre mentalement ou sur papier à ces questions avant de regarder la réponse.\nCertains étudiants aiment utiliser une Java Fundamentals Cheat Sheet (anglais) pour garder à l'esprit la syntaxe.\nComment faire ces exercices ? # N'allez pas trop vite. Il ne sert à rien de lire la question et d'immédiatement lire la réponse. Le but des exercices est de vous amener à travailler la matière. Si vous ne faites que regarder les solutions, vous n'apprenez pas grand chose. Réponses uniques? # Les exercices comportent une solution vous permettant de comparer votre approche avec la nôtre. Il n'y a pas de solution unique aux problèmes en général. Vous pouvez arriver avec une solution qui est préférable ou moins bonne que celle que nous offrons. Pour faire ces questions, vous devez avoir fait toutes les lectures préalables. Vous disposez alors toujours des fondements nécessaires pour faire les exercices. Nous vous encourageons tout de même à faire vos propres recherches en complément de vos lectures. Dans certains cas, au sein de la solution que nous offrons, nous pouvons utiliser des notions techniques qui n'ont pas été vues directement dans le cours, mais qui devraient vous être facilement accessibles.\nQuestion 1 # Proposez une classe Etudiant dont le constructeur prend en paramètre un identifiant (sous la forme d'un entier) et qui comprend une méthode monIdentifiant retournant l'identifiant en question.\nRéponse Etudiant.java public class Etudiant { int mIdentifiant; public Etudiant(int identifiant) { mIdentifiant = identifiant; } public int monIdentifiant() { return mIdentifiant; } } Exécuter Question 2 # Combien de constructeurs est-ce qu'une classe peut avoir en Java?\nRéponse Une classe Java peut avoir autant de constructeurs qu'on le souhaite. Question 3 # Soit la classe suivante:\npublic class Patate { static int y; public Patate(int x) { y = x; } public int nombre() { return y; } } Que va afficher le code suivant:\nPatate z1 = new Patate(1); Patate z2 = new Patate(2); System.out.println(z1.nombre()); RéponseLa valeur 2. Le mot-clef static indique que la classe Patate n'a qu'une variable y partagée par toutes les instances de la classe.\nQuestion 4 # Écrivez une classe nommée Somme comprenant une méthode nommée additionne qui additionne deux nombres et retourne le résultat.\nRéponsepublic class Somme { public int additionne(int a, int b) { return a + b; } } Question 5 # Expliquez pourquoi la méthode donne de cette classe va toujours retourner la valeur 2.\npublic class Somme { public void ajoute(int a) { a = a + 1; } public int donne() { int a = 2; ajoute(a); return a; } } RéponseLa valeur de la variable 'a' est passée à la méthode ajoute par valeur, c'est-à-dire que la méthode ajoute fait une copie de la variable 'a' et c'est cette variable locale qui est modifiée. Ainsi donc, la méthode ajoute ne sert effectivement à rien. Question 6 # Expliquez pourquoi la méthode donne de cette classe va toujours retourner la valeur 3.\npublic class Variable { public int a = 2; public static void ajoute(Variable x) { x.a = x.a + 1; } public int donne() { Variable x = new Variable(); ajoute(x); return x.a; } } RéponseCette fois-ci, la méthode ajoute reçoit un type qui n'est pas un type primitif (Variable) et va donc le recevoir par référence. C'est-à-dire que la variable 'x' n'est pas copiée. Quand la méthode ajoute modifie un attribut de la variable 'x', cette modification est visible hors de la fonction ajoute. Question 7 # Écrivez une classe Puissance qui comprend une méthode nommée deux qui prend un entier et retourne l'entier mis au carré.\nRéponsepublic class Puissance { public int deux(int a) { return a * a; } } Question 8 # Expliquez pourquoi la méthode donne de cette classe va toujours retourner la valeur 2.\npublic class Variable { public int a = 2; public static void ajoute(Variable x) { x = new Variable(); x.a = x.a + 1; } public int donne() { Variable x = new Variable(); ajoute(x); return x.a; } } RéponseLa méthode ajoute reçoit un type qui n'est pas un type primitif (Variable) et va donc le recevoir par référence. Par contre, la référence est immédiatement perdue et réassignée à une instance locale de la classe Variable. La méthode ajoute modifie donc une variable locale. Question 9 # Pourquoi le bout de code suivant va générer une erreur à la compilation ?\nclass T { private float x ; private static int n ; public static float test(){ return x*n; } } Réponse Une méthode statique ne peut accéder à un champ non statique comme la méthode statique test() tente de le faire avec le champ non statique x.\nQuestion 10 # On admet que la classe A existe.\nQue peut-on en déduire quant au(x)constructeur (s) de la classe A si l\u0026#x2019;instruction suivante génère une erreur de compilation ayant trait au(x) constructeur(s) de A ?\nA a = new A () ;\nRéponse A dispose d\u0026#x2019;au moins un constructeur (non par défaut) et tous ses constructeurs sont des constructeurs avec un argument.\nQuestion 11 # Est-ce qu'une méthode peut être à la fois static et private en java?\nRéponse Oui. La méthode ne peut être appelée que par les autres méthodes de la classe (soit les autres méthodes statiques ou les méthodes non-dynamiques).\nMain.java class Main { public static void main(String[] args) { joe(); System.out.println(\u0026#34;Hello world!\u0026#34;); } private static void joe() {} } Exécuter Question 12 # Quelle est la visibilité des attributs au sein de cette classe :\npublic class Joe { public int x = 0; protected int y = 0; private int z = 0; int t = 0; } Réponse public (accessible de partout), protected (accessible des classes dérivées et des classes du même package), private (accessible seulement par la classe) et default (accessible seulement par les classes du même package). Question 13 # Écrivez une classe représentant une valeur entière à laquelle je peux ajouter la valeur trois par l'entremise d'une méthode « public » nommée « patate ». La méthode doit retourner la valeur entière modifiée. Le constructeur doit me permettre d'initialiser la valeur entière. La classe doit n'avoir que des attributs «\u0026nbsp;private\u0026nbsp;».\nRéponse public class Entier { private int x = 0; public Entier(int m) { x = m; } public int patate() { x += 3; return x; } } Question 14 # Écrivez une classe représentant une valeur entière. Cette classe doit n'avoir qu'une seule méthode appelée « additionne » qui prend comme paramètre une instance de la classe et qui retourne une nouvelle instance de la classe. L'instance retournée doit comprendre la somme des deux valeurs entières.\nRéponse public class Entier { private int x = 0; public Entier(int m) { x = m; } public Entier additionne(Entier z) { return new Entier(z.x + x); } } Question 15 # Quelle est la différence entre public, private et protected pour un attribut ou une méthode en Java ?\nRéponse public : accessible partout ; private : accessible uniquement dans la classe ; protected : accessible dans la classe et ses sous-classes (même dans d’autres packages).\nQuestion 16 # Considérez le code suivant :\nvoid afficher(String message) {} int afficher(int nombre) { return nombre; } void afficher(String message, int nombre) {} Décrivez la signature de la méthode afficher(String message, int nombre) et expliquez pourquoi ces trois méthodes peuvent coexister dans la même classe.\nRéponse La signature de la méthode afficher(String message, int nombre) est composée des types et de l\u0026rsquo;ordre des paramètres, à savoir afficher(String, int). Ces trois méthodes peuvent coexister dans la même classe car elles ont des signatures différentes, c\u0026rsquo;est-à-dire un nombre ou un type de paramètres différent. En Java, la surcharge de méthode est permise tant que les signatures des méthodes sont différentes.\nQuestion 17 # Pourquoi la signature d’une méthode ne tient-elle pas compte du type de retour ? Donnez un exemple où deux méthodes auraient le même nom et les mêmes paramètres mais des types de retour différents, et expliquez pourquoi cela pose problème.\nRéponse La signature d’une méthode ne tient pas compte du type de retour, car cela rendrait l’appel de la méthode ambigu pour le compilateur. Par exemple, si on écrivait :\nint calculer(int x); double calculer(int x); Le compilateur ne saurait pas quelle version utiliser lors d’un appel comme calculer(5), car le choix ne peut pas se faire uniquement sur le type de retour. C’est pourquoi Java interdit d’avoir deux méthodes avec le même nom et les mêmes paramètres, même si leur type de retour diffère.\nQuestion 18 # Considérez l’expression suivante en Java :\nbool = (1 + 3 == 2) || f(x) || f(x); Combien de fois la fonction f(x) est-elle appelée lors de l’évaluation de cette expression ? Expliquez pourquoi.\nRéponse f(x) n’est appelée qu’une seule fois. En Java, l’opérateur logique || (OU logique) est évalué de façon « paresseuse » (short-circuit). Dès qu’une des conditions est vraie, les suivantes ne sont pas évaluées. Ici, (1 + 3 == 2) est faux, donc on évalue le premier f(x). Si ce premier appel retourne vrai, le second f(x) n’est pas évalué. Si le premier retourne faux, alors le second est évalué. Mais dans tous les cas, au maximum un seul des deux appels à f(x) sera exécuté.\nAllez plus loin? # Plusieurs étudiants apprécient la plateforme Jetbrains Academy pour aller plus loin et se pratiquer (en anglais seulement). Bien que Jetbrains Academy soit un service commercial, ils offrent une période d'essai sans frais. C'est sans aucune doute un excellent complément à notre cours.\nIl y a aussi plusieurs manuels (en anglais) dédiés aux exercices que vous pouvez acquérir :\nJava Coding Problems: Improve your Java Programming skills by solving real-world coding challenges Java Cookbook: Problems and Solutions for Java Developers Certains étudiants ne souhaitent pas dépenser davantage d'argent pour l'accès à des ressources supplémentaires. Et absolument rien ne vous y oblige. Nous offrons ces liens parce plusieurs étudiants considèrent que ces ressources supplémentaires sont utiles.\n"},{"id":39,"href":"/inf1220-hugo/docs/modules/module3/exercices-3-1/","title":"Exercices sur les structures de contrôle, les structures de données, les structures itératives","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" Exercices sur les structures de contrôle, les structures de données, les structures itératives # Questions/Réponses # Veuillez répondre mentalement, sur papier ou bien en créant le code nécessaire pour répondre à ces questions avant de regarder la réponse.\nQuand on vous demande de produire du code, vous devez le tester. C'est une erreur commune chez les étudiants: ils produisent rapidement du code en supposant qu'il est fonctionnel. Prenez le temps de vous relire, d'être attentif. Et testez votre code. Encore et encore.\nPrenez note qu'il est permis d'utiliser le robot conversationnel du cours lors des exercises. Cependant vous devriez vous entraîner à produire vos propres réponses.\nRéponses uniques? # Les exercices comportent une solution vous permettant de comparer votre approche avec la nôtre. Il n'y a pas de solution unique aux problèmes en général. Vous pouvez arriver avec une solution qui est préférable ou moins bonne que celle que nous offrons. Pour faire ces questions, vous devez avoir fait toutes les lectures préalables. Vous disposez alors toujours des fondements nécessaires pour faire les exercices. Nous vous encourageons tout de même à faire vos propres recherches en complément de vos lectures. Dans certains cas, au sein de la solution que nous offrons, nous pouvons utiliser des notions techniques qui n'ont pas été vues directement dans le cours, mais qui devraient vous être facilement accessibles.\nQuestion 1 # Si x == true et que l'on utilise le code suivant, quel sera la sortie en ligne de commande?\nif(x != true \u0026amp;\u0026amp; x == true) { System.out.println(\u0026#34;AAA\u0026#34;); } else { System.out.println(\u0026#34;BBB\u0026#34;); } Réponse Le résultat affiché sera BBB, car x != true donnera Faux et x == true donnera Vrai. Par définition, Faux ET Vrai = FAUX\nQuestion 2 # Le code suivant contient 5 erreurs, veuillez les identifier :\nint x = 5; if((x \u0026gt; 1) \u0026amp;\u0026amp; (x =\u0026lt; 10) { x = \u0026#34;5\u0026#34;; } if (x !!= 5) { x = 100; } Réponse Voici les erreurs :\nl'opérateur =\u003c n'existe pas, c'est plutôt \u003c= il manque une parenthèse \")\" à la première ligne if (avant le }) on ne peut assigner une String à un int en supposant que l'indentation est correcte, il manque le else pour } else if ( l'opérateur !!= n'existe pas, c'est plutôt != int x = 5; if((x \u0026gt; 1) \u0026amp;\u0026amp; (x \u0026lt;= 10)) { x = 5; } else if (x != 5) { x = 100; } Question 3 # Quelle est la différence entre une boucle while et une boucle do-while?\nRéponse Le contrôle se fait au départ dans la boucle while alors que le contrôle se fait à la fin dans le do-while. Dans la boucle while, il y a donc un contrôle avant même de faire la première itération.\nQuestion 4 # Quelle sera la sortie d'affichage de ce block switch-case et pourquoi?\nint index = 10; switch (index) { case 1: System.out.println(11); break; case 2: System.out.println(22); break; case 3: System.out.println(33); break; default: System.out.println(\u0026#34;Default\u0026#34;); break; } Réponse La sortie sera \"Default\", car la valeur de la variable index = 10 ne correspond à aucun des cas du switch. C'est donc le sous-bloc \"Default\" qui est exécuté.\nQuestion 5 # Vrai ou faux: un tableau de type int[10] occupera 40 octets en mémoire parce qu'il y a 10 entiers (int) et que chaque entier occupe 4 octets (32 bits).\nRéponse Faux. Il est vrai qu'il y a 10 entiers (int) et que chaque entier occupe 4 octets. Cependant, Java doit aussi garder une trace de la longueur du tableau (10 éléments). Il y a aussi d'autres contraintes. Il serait plus juste de dire que le tableau va utiliser plus de 40 octets. Question 6 # Supposons que dans un code, nous avons créé un tableau d'une dimension de 10 éléments (int[] tableau = new int[10]) et que nous accédons, suite à son instanciation, au 20e élément du tableau ( int x = tableau[20]), qu'adviendra-t-il?\nRéponse À l'exécution l'opération int x = tableau[20] va générer une erreur du type : java.lang.ArrayIndexOutOfBoundsException: 20, car nous tentons d'accéder à des index du tableau qui n'existe pas.\nQuestion 7 # Est-ce possible de créer une structure de données de type ArrayList d'entier en utilisant la déclaration suivante : ArrayList = new ArrayList(); ?\nRéponse Le Java est un langage OO et même si le Java intègre des types de base (int, float, etc.) qui ne sont pas des objets. L'objet ArrayList ne peut que contenir des objets. Il faut donc utiliser plutôt : ArrayList = new ArrayList(); où l'objet Integer est la version objet de int. Dans les dernières versions de Java, une mécanique de conversion automatique permet d'assigner des types à leur objet équivalent. Par exemple : Integer i = 5; ou bien :\nArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;Integer\u0026gt;(); list.add(5); Question 8 # Votre employeur vous demande créer une fonction en Java qui vous permettra de trouver dans un tableau à deux dimensions, un couple {clé,valeur}. Pour démarrer, vous avez le code suivant, veuillez créer une fonction trouver qui reçoit en paramètre la clé et retourne la valeur :\npublic class Dictionnaire { int[][] tableau2D = {{5,3},{2,5},{4,3},{8,10},{105,32},{55,34},{12,21}, {15,51},{44,1},{6,3},{19,3},{65,13},{1235,1353},{51515,32143}, {15155,3555}}; public static void main(String[] args) { Dictionnaire dict = new Dictionnaire(); //Trouver la valeur associée à la clé //System.out.println(\u0026#34;Valeur =\u0026#34; + dict.trouver(12)); } } Réponse Voici le code\npublic class Dictionnaire { int[][] tableau2D = {{5,3},{2,5},{4,3},{8,10},{105,32},{55,34},{12,21}, {15,51},{4,1},{6,3},{19,3},{65,13},{1235,1353},{51515,32143}, {15155,3555}}; /** * Fonction permettant de trouver une valeur à partir d\u0026#39;une clé * @param clef * @return valeur */ int trouver(int clef) { // Initialiation de la variable valeur. Si la clef n\u0026#39;est pas trouvé alors on retourne -1. int valeur = -1; // Itération dans le tableau pour trouver le bon for(int i = 0; i \u0026lt; tableau2D.length; i++) { // Vérification de la cle avec l\u0026#39;index courant; if (tableau2D[i][0] == clef) { // Si oui, arrêter l\u0026#39;exécution et retourner la valeur. return tableau2D[i][1]; // ou valeur = tableau2D[i][1]; break; } } return valeur; } public static void main(String[] args) { Dictionnaire dict = new Dictionnaire(); //Trouver la valeur associée à la clé System.out.println(\u0026#34;Valeur =\u0026#34; + dict.trouver(12)); } } Question 9 # Montrer comment on peut trier un tableau d'entiers en Java.\nRéponse Le plus simple est d'utiliser la méthode Arrays.sort.\nimport java.util.Arrays; class Main { public static void main(String[] args) { int[] tableauTest = {4, 6, 9, 1, 2, 76, 222, 5, 22}; Arrays.sort(tableauTest); for (int i : tableauTest) { System.out.print(i + \u0026#34; \u0026#34;); } System.out.println(); } } Question 10 # Veuillez créer une fonction, recevant un ArrayList en entrée, et qui retourne une nouvelle ArrayList avec les éléments inversés, i.e. le premier élément à la fin, le dernier élément en premier et ainsi de suite. Réponse Voici une solution possible. Elle est grossièrement inefficace sur le plus du temps de calcul: vous pouvez sans doute faire mieux.\nimport java.util.ArrayList; public class ArrayListUtils { public static ArrayList inverser(ArrayList liste) { ArrayList inverse = new ArrayList(); for(Object o : liste) { inverse.add(0, o); } return inverse; } public static void main(String[] args) { ArrayList\u0026lt;String\u0026gt; test = new ArrayList\u0026lt;String\u0026gt;(); test.add(\u0026#34;1\u0026#34;); test.add(\u0026#34;2\u0026#34;); test.add(\u0026#34;3\u0026#34;); test.add(\u0026#34;4\u0026#34;); test.add(\u0026#34;5\u0026#34;); ArrayList\u0026lt;String\u0026gt; testInverse = ArrayListUtils.inverser(test); for(String s : testInverse) { System.out.print(s + \u0026#34; \u0026#34;); } } } Voici une autre solution (n'oubliez pas 'import java.util.Collections').\nArrayList\u0026lt;String\u0026gt; test = new ArrayList\u0026lt;String\u0026gt;(); test.add(\u0026#34;1\u0026#34;); test.add(\u0026#34;2\u0026#34;); test.add(\u0026#34;3\u0026#34;); test.add(\u0026#34;4\u0026#34;); test.add(\u0026#34;5\u0026#34;); Collections.reverse(test); for(String s : test) { System.out.print(s + \u0026#34; \u0026#34;); } Question 11 # Vous devez créer une méthode supplémentaire au code de la Question #10, permettant de fusionner deux ArrayList ensemble. Cette méthode prend deux ArrayLists en paramètre et retourne le nouvel ArrayList fusionné.\nRéponse La méthode addAll de la classe ArrayList permet de rapidement faire cette fusion :\nimport java.util.ArrayList; public class ArrayListUtils { public static ArrayList inverser(ArrayList liste) { ArrayList inverse = new ArrayList(); for(Object o : liste) { inverse.add(0, o); } return inverse; } public static ArrayList fusion(ArrayList a, ArrayList b) { // Permet de cloner la structure. Nécessite un cast ArrayList liste = (ArrayList) a.clone(); // Ajouter l\u0026#39;ArrayList b à la fin de liste liste.addAll(b); return liste; } public static void main(String[] args) { ArrayList\u0026lt;String\u0026gt; test = new ArrayList\u0026lt;String\u0026gt;(); test.add(\u0026#34;1\u0026#34;); test.add(\u0026#34;2\u0026#34;); test.add(\u0026#34;3\u0026#34;); test.add(\u0026#34;4\u0026#34;); test.add(\u0026#34;5\u0026#34;); ArrayList\u0026lt;String\u0026gt; listFusion = ArrayListUtils.fusion(test, test); for(String s : listFusion) { System.out.print(s + \u0026#34; \u0026#34;); } } } Question 12 # Veuillez écrire le code (classe et méthode(s)) permettant de faire afficher le texte suivant à la console. Vous ne pouvez utiliser qu'une seule fois la méthode System.out.println.\n###?###?###?###?###?###?###?### ???#???#???#???#???#???#???#??? ??###?###?###?###?###?###?###?? ?????#???#???#???#???#???#????? ????###?###?###?###?###?###???? ???????#???#???#???#???#??????? ??????###?###?###?###?###?????? ?????????#???#???#???#????????? ????????###?###?###?###???????? ???????????#???#???#???#??????? ??????????###?###?###?????????? ?????????????#???#????????????? ????????????###?###???????????? ???????????????#??????????????? ??????????????###?????????????? Réponse import java.util.ArrayList; // solution par Francis Beauchemin-Côté public class Main { public static String trioMotif(String caractere1, String caractere2, int nombreCaractere1) { String motif = \u0026#34;\u0026#34;; for (int i = 1; i \u0026lt;= nombreCaractere1; i++) { // On veut mettre le nombre de trio demandé. motif += caractere1 + caractere1 + caractere1; // Le premier argument est un String pour ne pas faire la somme en // int (si un char avait été utilisé). Donc + est une // concaténation. if (i != nombreCaractere1) { // On n’ajoute pas de motif de séparation après le dernier trio. motif += caractere2; // Comme motif est un String, la somme avec un char devient en fait une // concaténation. On utilise ici un String dans le but d\u0026#39;uniformiser et // simplifier l\u0026#39;utilisation. } } return motif; } public static String nbInter(String carac, int nombreInterrogation) { // Crée le String entourant // les motifs de trio. String chaine = \u0026#34;\u0026#34;; for (int i = 1; i \u0026lt;= nombreInterrogation; i++) { chaine += carac; } return chaine; } public static void pyramide(String premierChar, String deuxiemeChar, int nombreDeLignes) { ArrayList \u0026lt; String \u0026gt; texte = new ArrayList \u0026lt; String \u0026gt; (); // Notre texte sera un vecteur de String. for (int i = 0; i \u0026lt; (nombreDeLignes + 1) / 2; i++) { // Comme c\u0026#39;est une division entière, la division ne prend que // le quotient entier. texte.add(nbInter(deuxiemeChar, 2 * i) + trioMotif(premierChar, deuxiemeChar, (nombreDeLignes + 1) / 2 - i) + nbInter(deuxiemeChar, 2 * i)); texte.add(nbInter(deuxiemeChar, 2 * i) + trioMotif(deuxiemeChar, premierChar, (nombreDeLignes + 1) / 2 - i) + nbInter(deuxiemeChar, 2 * i)); } // On imprime deux lignes à la fois! On ajuste le nombreDeLignes par + 1. Il y a // un nombre pair de motifs qui entourent les motifs avec les trios if (nombreDeLignes % 2 == 1) { // Comme on imprime un nombre pair de lignes, il faut retirer // la dernière dans le cas où le nombre de lignes est impair. texte.remove(nombreDeLignes); // Le rang du n+1 ième élément est n. } for (String e: texte) { // Affiche le texte à l\u0026#39;écran ligne par ligne. System.out.println(e); } } public static void main(String[] args) { pyramide(\u0026#34;#\u0026#34;, \u0026#34;?\u0026#34;, 100); } } Question 13 # Écrivez un programme efficace Java qui prend la chaîne de caractère « 124213 » et en extrait les nombres 1, 2, 4, 2, 1, 3.\nRéponse class Exemple { public static int[] extrait(String s) { int[] answer = new int[s.length()]; for(int index = 0; index \u0026lt; s.length(); index++) { answer[index] = Character.digit(s.charAt(index), 10); } return answer; } public static void main(String[] args) { for(int x: extrait(\u0026#34;124213\u0026#34;)) { System.out.println(x); } } } Question 14 # Qu’est-ce qui s’affiche à l’exécution du bout de code suivant :\npublic class Main { public static void main(String args[]) { if (true) if (false) if (true) System.out.println(\u0026#34;avant le premier else\u0026#34;); else System.out.println(\u0026#34;après le premier else\u0026#34;); if (true) System.out.println(\u0026#34;avant le second else\u0026#34;); else System.out.println(\u0026#34;après le second else\u0026#34;); } } Expliquer pourquoi.\nRéponse Le code affiche « avant le second else ».\nEn effet le second if est évalué à false, et toute l’instruction qui suit (y compris l’évaluation du else qui se rapporte au if de cette instruction) n’est pas exécutée ; l’instruction suivante c’est le tout dernier if, qui est évalué à true, et donc le else qui s’y rapporte n’est pas évalué.\nQuestion 15 # Soit les deux bouts de code suivants :\na)\nfor (int j=0; j \u0026lt; 10; j++) { if (j\u0026gt;=5) { continue; } Instruction } b)\nfor (int j=0; j \u0026lt; 10;j++) { if (j\u0026gt;=5) { break; } Instruction } Que se passe-t-il dans chacun des cas quant à l’exécution de Instruction quand j vaut 5?\nRéponse En a) Instruction n’est pas exécutée et on passe au tour suivant, le 7eme tour de la boucle (i=6) où, comme lors des autres tours précédant i=5, Instruction sera exécutée.\nEn b) on sort de la boucle, Instruction ne sera plus jamais exécutée.\nQuestion 16 # Soit les deux bouts de code suivants :\na)\nlabel: for (int i=0; i \u0026lt; 10;i++) { for (int j=0; j \u0026lt; 6; j++) { if (condition) { continue label; } Instruction1 } Instruction2 } b)\nfor (int i=0; i \u0026lt; 10; i++) { for(int j=0; j \u0026lt; 6; j++) { if(condition) { continue ; } Instruction1 } Instruction2 } Dans quel cas (quel bout de code et quelle condition) Instruction1 n'est pas exécuté? Y'a-t-il une situation où Instruction2 n'est pas exécuté? Si oui laquelle?\nRéponse Instruction1 n’est pas exécuté, dans tous les cas lorsque condition est vraie.\nInstruction2 est toujours exécuté.\nQuestion 17 # Soit le code suivant :\npublic class Main { public static void main(String[] args) { final int NBRE = 10; int i; double harmonique; harmonique = 0; System.out.println(\u0026#34;somme des \u0026#34; + NBRE + \u0026#34; premiers termes de la série harmonique\u0026#34;); for (i = 0; i \u0026lt; NBRE; i++) { harmonique += (double)1/(i+1); } System.out.println(\u0026#34;Somme : \u0026#34; + harmonique); } } Réécrire le même code en utilisant les syntaxes de l’instruction while et de l’instruction do…while.\nRéponse Instruction while.\npublic class Main { public static void main(String[] args) { final int NBRE = 10; int i=0; double harmonique; harmonique = 0; System.out.println(\u0026#34;somme des \u0026#34; + NBRE + \u0026#34; premiers termes de la série harmonique\u0026#34;); while (i \u0026lt; NBRE) { harmonique += (double)1/(i+1); i++; } System.out.println(\u0026#34;Somme : \u0026#34; + harmonique); } } Instruction do…while\npublic class Main { public static void main(String[] args) { final int NBRE = 10; int i = 0; double harmonique; harmonique = 0; System.out.println(\u0026#34;somme des \u0026#34; + NBRE + \u0026#34; premiers termes de la série harmonique\u0026#34;); do { harmonique += (double)1/(i+1); i++; } while (i \u0026lt; NBRE); System.out.println(\u0026#34;Somme : \u0026#34; + harmonique); } } Question 18 # Soit le code suivant :\nimport java.util.Scanner; public class Main { public static void main(String[] args) { System.out.println(\u0026#34;Donnez un nombre entier\u0026#34;); Scanner scan = new Scanner(System.in); int n = scan.nextInt(); if (n\u0026gt;=10) { System.out.println(\u0026#34;Le nombre vaut 10\u0026#34;); } else if (n \u0026gt;= 100) { System.out.println(\u0026#34;Le nombre vaut 100\u0026#34;); } else if (n \u0026gt;= 1000) { System.out.println(\u0026#34;Le nombre vaut 1000\u0026#34;); } else { System.out.println(\u0026#34;Le nombre n\u0026#39;est pas une puissance de 10 ou il est plus grand que 1000\u0026#34;); } } } Réécrire le même programme avec l'instruction switch.\nRéponse import java.util.Scanner; public class Main { public static void main(String[] args) { System.out.println(\u0026#34;Donnez un nombre entier\u0026#34;); Scanner scan = new Scanner(System.in); int n = scan.nextInt(); switch(n) { case 10 : System.out.println(\u0026#34;Le nombre vaut 10\u0026#34;); break; case 100 : System.out.println(\u0026#34;Le nombre vaut 100\u0026#34;); break; case 1000 : System.out.println(\u0026#34;Le nombre vaut 1000\u0026#34;); break; default: System.out.println(\u0026#34;Le nombre n\u0026#39;est pas une puissance de 10 ou il est plus grand que 1000\u0026#34;); break; } } } Question 19 # Étant donné le tableau String[] x = new String[10], que vaut x[0].\nRéponse En Java, les tableaux sont initialisées à une valeur nulle par défaut. Dans ce cas, x[0] prendra donc la valeur null. Cette valeur spéciale ne correspond pas à une instance de la classe String. On peut, par contre, assigner une valeur (x[0]=\"123\").\nQuestion 20 # Énumérer toutes les paires d'entiers entre 0 et 1000 en ordre lexicographique.\nRéponse public class Liste { public static void main(String[] args) { for(int i = 0; i \u0026lt;= 1000; i++) { for(int j = 0; j \u0026lt;= 1000; j++) { System.out.println(i+\u0026#34; \u0026#34;+j); } } } } Question 21 # Écrivez un programme Java qui trie le tableau de chaînes de caractères suivant : {\"Pomme\", \"banane\", \"Cerise\", \"abricot\", \"Datte\"}, en ignorant la casse (par exemple, \"Pomme\" et \"pomme\" doivent être traités de manière identique). Utilisez la méthode Arrays.sort avec une expression lambda pour effectuer un tri alphabétique insensible à la casse.\nUne expression lambda est une fonctionnalité introduite dans Java 8 qui permet d'écrire du code plus concis pour représenter des fonctions anonymes. Elle est particulièrement utile lorsqu'une méthode attend une interface fonctionnelle (une interface avec une seule méthode abstraite). Dans le contexte du tri avec Arrays.sort, la lambda remplace une implémentation explicite d'un Comparator.Une lambda a la forme générale suivante : (paramètres) -\u003e expression La lambda (s1, s2) -\u003e s1.compareToIgnoreCase(s2) signifie : s1 et s2 sont deux chaînes de caractères à comparer, la méthode compareToIgnoreCase est appelée pour déterminer l'ordre alphabétique sans tenir compte de la casse, le résultat de cette comparaison est retourné directement.\nRéponse TriChainesSansCasse.java import java.util.Arrays; public class TriChainesSansCasse { public static void main(String[] args) { String[] tableau = {\u0026#34;Pomme\u0026#34;, \u0026#34;banane\u0026#34;, \u0026#34;Cerise\u0026#34;, \u0026#34;abricot\u0026#34;, \u0026#34;Datte\u0026#34;}; // Tri du tableau en ignorant la casse avec une lambda Arrays.sort(tableau, (s1, s2) -\u0026gt; s1.compareToIgnoreCase(s2)); // Affichage du tableau trié System.out.println(\u0026#34;Tableau trié :\u0026#34;); for (String s : tableau) { System.out.println(s); } } } Exécuter Question 22 # Écrivez un programme Java qui affiche la somme des éléments d’un tableau d’entiers donné.\nRéponse int[] t = {1, 2, 3, 4, 5}; int somme = 0; for (int v : t) { somme += v; } System.out.println(\u0026#34;Somme : \u0026#34; + somme); Question 23 # Expliquez la différence entre une boucle for et une boucle while en Java, et donnez un exemple pour chacune.\nRéponse La boucle for est généralement utilisée quand on connaît le nombre d’itérations à l’avance ; la boucle while est utilisée quand on ne le connaît pas.\n// Boucle for for (int i = 0; i \u0026lt; 5; i++) { System.out.println(i); } // Boucle while int j = 0; while (j \u0026lt; 5) { System.out.println(j); j++; } Question 24 # Quelle est la différence entre un tableau et une ArrayList en Java ?\nRéponse Un tableau a une taille fixe et ne peut pas être redimensionné après sa création. Une ArrayList est une structure de données dynamique qui peut changer de taille et offre des méthodes pratiques pour ajouter, supprimer ou rechercher des éléments.\nQuestion 25 # Écrivez un programme Java qui affiche tous les éléments d’un tableau d’entiers dans l’ordre inverse.\nRéponse int[] t = {1, 2, 3, 4, 5}; for (int i = t.length - 1; i \u0026gt;= 0; i--) { System.out.println(t[i]); } Question 26 # Qu'est-ce qu'une HashMap en Java ? Donnez un exemple simple d'utilisation pour associer des noms d'étudiants à leurs notes.\nRéponse Une HashMap est une structure de données qui associe des clés à des valeurs. Elle permet de retrouver rapidement une valeur à partir de sa clé. Exemple :\nimport java.util.HashMap; HashMap\u0026lt;String, Integer\u0026gt; notes = new HashMap\u0026lt;\u0026gt;(); notes.put(\u0026#34;Alice\u0026#34;, 85); notes.put(\u0026#34;Bob\u0026#34;, 92); System.out.println(notes.get(\u0026#34;Alice\u0026#34;)); // Affiche 85 Question 27 # Que se passe-t-il si on ajoute deux fois la même clé dans une HashMap en Java ? Par exemple :\nHashMap\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;clé\u0026#34;, 1); map.put(\u0026#34;clé\u0026#34;, 2); Quelle sera la valeur associée à la clé \u0026ldquo;clé\u0026rdquo; ?\nRéponse La deuxième insertion écrase la première : la valeur associée à la clé \"clé\" sera 2. Une HashMap ne peut contenir qu'une seule valeur par clé ; si on ajoute une clé déjà existante, la nouvelle valeur remplace l'ancienne.\nQuestion 28 # Comment utiliser une Stack en Java pour inverser l'ordre des éléments d'une liste ? Donnez un exemple de code qui empile les éléments d'un tableau d'entiers, puis les dépile pour les afficher dans l'ordre inverse.\nRéponse On peut utiliser une Stack pour inverser l'ordre des éléments : on empile chaque élément, puis on les dépile un à un (LIFO : Last In, First Out).\nimport java.util.Stack; int[] t = {1, 2, 3, 4, 5}; Stack\u0026lt;Integer\u0026gt; pile = new Stack\u0026lt;\u0026gt;(); for (int x : t) { pile.push(x); } while (!pile.isEmpty()) { System.out.println(pile.pop()); } Question 29 # Qu’est-ce que l’interface CharSequence en Java ? Donnez un exemple d’utilisation de la méthode subSequence() sur une chaîne de caractères.\nRéponse L’interface CharSequence représente une séquence de caractères et est implémentée par String, StringBuilder, etc. La méthode subSequence(start, end) permet d’obtenir une sous-séquence de caractères.\nExemple :\nString texte = \u0026#34;Bonjour le monde\u0026#34;; CharSequence sousTexte = texte.subSequence(8, 14); // \u0026#34;le mon\u0026#34; System.out.println(sousTexte); On peut ainsi éviter de faire des copies.\nQuestion 30 # Pourquoi est-il préférable d’utiliser StringBuilder plutôt que l’opérateur + pour concaténer des chaînes dans une boucle ? Donnez un exemple.\nRéponse StringBuilder permet de modifier une chaîne sans créer de nouveaux objets à chaque opération, ce qui améliore la performance, surtout dans les boucles. L’opérateur + de la classe String peut créer une nouvelle chaîne à chaque concaténation, ce qui est coûteux en mémoire et en temps.\nExemple :\nStringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; 5; i++) { sb.append(\u0026#34;Ligne \u0026#34;).append(i).append(\u0026#34;\\n\u0026#34;); } System.out.println(sb.toString()); Question 31 # Quels sont les types et classes immuables en Java ? Donnez quelques exemples et expliquez pourquoi l’immuabilité peut être utile.\nRéponse Un type ou une classe est dit immuable si son état ne peut pas être modifié après sa création. En Java, les principaux types et classes immuables sont :\nString Les classes enveloppes des types primitifs : Integer, Double, Boolean, Long, Short, Byte, Character, Float L’immuabilité facilite la programmation (pas de risque de modification imprévue), rend les objets sûrs à partager, et simplifie le raisonnement sur le code.\nQuestion 32 # Considérez le code suivant :\npublic class Main { public static void main(String[] args) { String str1 = \u0026#34;Java\u0026#34;; String str2 = \u0026#34;Java\u0026#34;; String str3 = new String(\u0026#34;Java\u0026#34;); System.out.println(str1 == str2); System.out.println(str1 == str3); } } Qu’affichera ce programme ? Expliquez pourquoi.\nRéponse Le premier affichage (str1 == str2) retournera true car les deux variables pointent vers la même chaîne littérale dans le pool de chaînes de Java. Le second (str1 == str3) retournera false car str3 est un nouvel objet créé explicitement, différent de la chaîne littérale, même si leur contenu est identique. Pour comparer le contenu des chaînes, il faut utiliser equals() :\nSystem.out.println(str1.equals(str3)); // true En Java, les chaînes de caractères sont des objets particuliers : les chaînes littérales (comme \u0026ldquo;Java\u0026rdquo;) sont stockées dans une zone spéciale appelée « pool de chaînes ». Quand on écrit deux fois la même chaîne littérale dans le code, Java réutilise le même objet pour économiser de la mémoire. C’est pourquoi str1 == str2 retourne true : les deux variables pointent vers le même objet en mémoire.\nEn revanche, lorsque l’on crée une chaîne avec new String(\u0026ldquo;Java\u0026rdquo;), Java crée explicitement un nouvel objet, même si le contenu est identique à une chaîne littérale existante. Ainsi, str1 == str3 retourne false car les deux variables pointent vers des objets différents.\nPour comparer le contenu de deux chaînes (et non leur emplacement en mémoire), il faut utiliser la méthode equals(). Cette méthode vérifie caractère par caractère si les deux chaînes ont le même contenu, ce qui est généralement ce que l’on souhaite en pratique.\n"},{"id":40,"href":"/inf1220-hugo/docs/modules/module1/algorithmes2/","title":"Les algorithmes : conception et syntaxe","section":"Module 1: Algorithme et pseudocode","content":" Les algorithmes : conception et syntaxe # Un algorithme est une méthode structurée pour résoudre un problème de manière systématique et efficace. Comparable à une recette culinaire, il fournit des instructions précises, exécutables pas à pas, pour transformer des données d’entrée en résultats attendus. Comprendre la conception et la syntaxe des algorithmes est essentiel pour tout programmeur souhaitant traduire une solution abstraite en code fonctionnel, quel que soit le langage utilisé.\nConcevoir un algorithme # Pour concevoir un algorithme, il convient d’analyser minutieusement le problème en identifiant les entrées, les sorties et les étapes de traitement nécessaires pour obtenir les résultats souhaités. Un algorithme se présente comme une suite logique d’instructions qu’un programmeur peut adapter à un langage comme Java, C++ ou Python. La démarche de conception suit généralement ces étapes :\nÉtape 1 : lire et comprendre l’énoncé du problème à résoudre.\nÉtape 2 : définir les sorties (résultats attendus), les entrées (données initiales) et le traitement (relations permettant de passer des entrées aux sorties).\nÉtape 3 : rédiger l’algorithme en pseudo-code, en respectant une structure claire et compréhensible.\nSyntaxe d’un algorithme # La syntaxe d’un algorithme repose sur des conventions souples, contrairement aux langages de programmation qui imposent des règles strictes. Le pseudo-code privilégie la clarté et la précision des instructions, en s’appuyant sur des structures standardisées. Si une étape semble ambiguë ou trop complexe, il est souvent préférable de la décomposer en sous-étapes pour en faciliter la compréhension.\nLes entrées, variables et sorties # Un algorithme débute par la déclaration des entrées, c’est-à-dire les données fournies directement (comme un texte à analyser ou des données financières) ou saisies par un utilisateur (via un clavier, une souris, etc.). Viennent ensuite les variables, qui portent un nom et une valeur, comme une variable x valant 1. Ces valeurs peuvent évoluer au fil du traitement. Les variables, utilisées pour stocker des informations intermédiaires, se déclinent en divers types : chaînes de caractères, entiers, nombres décimaux, etc. Enfin, les sorties correspondent aux résultats finaux du traitement, transmis à l’utilisateur ou à d’autres algorithmes. Un problème complexe peut en effet être résolu par plusieurs algorithmes interconnectés, un concept que nous relierons plus tard aux fonctions dans les langages de programmation.\nLes opérations # Un algorithme se décrit comme une séquence d’opérations, par exemple additionner deux nombres ou incrémenter une variable. Les opérations disponibles dépendent du modèle de calcul adopté, mais on presume généralement que les opérations mathématiques de base (addition, soustraction, multiplication, comparaison) sont prises en charge.\nLes notations varient selon les conventions. Une multiplication peut s’écrire x * y, x × y ou simplement x y. De même, pour assigner la valeur 1 à une variable x, on peut utiliser x ← 1 ou x = 1. Cependant, dans certains contextes, x = 1 pourrait indiquer une comparaison (« x vaut-il 1 ? »). Pour lever l’ambiguïté, une notation comme x == 1 est parfois préférée pour les comparaisons, en s’inspirant de langages de programmation. L’essentiel reste que chaque opération soit exprimée de manière claire et sans équivoque pour le lecteur.\nCompter le nombre de voyelles d\u0026rsquo;un mot entrées au clavier # L\u0026rsquo;algorithme suivant compte le nombre de voyelles saisies :\nEntrées : Chaîne de caractères : chaine = \u0026#34;\u0026#34; Sorties : Entier : nbVoyelle = 0 Imprimer à l\u0026#39;écran \u0026#34;Veuillez entrer un mot au clavier suivi de la touche entrée\u0026#34; Saisir le mot au clavier et assigner à la variable chaine POUR TOUT caractère c dans chaine FAIRE SI c == \u0026#39;a\u0026#39; OU c == \u0026#39;e\u0026#39; OU c == \u0026#39;i\u0026#39; OU c == \u0026#39;o\u0026#39; OU c == \u0026#39;u\u0026#39; OU c == \u0026#39;y\u0026#39; ALORS nbVoyelle = nbVoyelle + 1 FIN SI FIN POUR Initialement, une variable chaine est définie comme une chaîne vide, et une variable nbVoyelle est initialisée à 0 pour compter les voyelles. L’algorithme affiche un message invitant l’utilisateur à entrer un mot suivi de la touche Entrée, puis stocke l’entrée dans chaine. Une boucle (POUR TOUT caractère c dans chaine FAIRE) parcourt chaque caractère c de la chaîne. Pour chaque caractère, une condition vérifie si c est une voyelle (a, e, i, o, u ou y) en utilisant une série de comparaisons avec l’opérateur OU. Si le caractère est une voyelle, nbVoyelle est incrémenté de 1. À la fin de la boucle, nbVoyelle contient le nombre total de voyelles dans la chaîne.\nLe compteur de voyelles est un outil interactif conçu pour t’aider à comprendre comment un algorithme traite une chaîne de caractères pour compter ses voyelles. Commence par saisir un mot ou une phrase dans le champ de texte, par exemple « bonjour ». Clique sur le bouton « Prochaine étape » pour exécuter l’algorithme pas à pas. À chaque clic, une ligne du pseudocode s’illumine, et une explication apparaît dans la zone de journalisation en bas. Tu verras aussi l’état actuel : la chaîne saisie, le caractère en cours d’analyse et le nombre de voyelles comptées. Si tu veux recommencer, clique sur « Réinitialiser » pour effacer les résultats et repartir de zéro. Assure-toi que ta saisie n’est pas vide, sinon un message te demandera de corriger.\nCet outil vous permet de suivre la logique de l’algorithme de manière visuelle. Le pseudocode, affiché à gauche, détaille chaque étape : initialisation des variables (comme la chaîne et le compteur de voyelles), lecture de la saisie, parcours de chaque caractère et vérification s’il s’agit d’une voyelle (a, e, i, o, u, y). En avançant étape par étape, tu peux observer comment l’algorithme « pense » pour résoudre le problème. Prenez le temps de lire les messages du journal pour comprendre ce qui se passe à chaque moment. Cet exercice est parfait pour t’entraîner à traduire un problème en une série d’instructions claires, une compétence essentielle en programmation.\nCompteur de voyelles Entrez une chaîne de caractères et exécutez le pseudocode pour compter les voyelles.\nPseudocode\nEntrées : Chaîne de caractères : chaine = \"\" Sorties : Entier : nbVoyelle = 0 Imprimer à l'écran \"Veuillez entrer un mot au clavier suivi de la touche entrée\" Saisir le mot au clavier et assigner à la variable chaine POUR TOUT caractère c dans chaine FAIRE SI c == 'a' OU c == 'e' OU c == 'i' OU c == 'o' OU c == 'u' OU c == 'y' ALORS nbVoyelle = nbVoyelle + 1 FIN SI FIN POUR Prochaine étape Réinitialiser État\nChaîne : \"\"\nCaractère courant : -\nNombre de voyelles : 0\nMaintenant que tu as exploré le compteur de voyelles, réfléchis à la manière dont cet algorithme pourrait être adapté ou amélioré. Par exemple, que se passerait-il si tu voulais compter uniquement certaines voyelles, comme « a » et « e », ou inclure les voyelles accentuées (é, è, ô) ? Comment modifierais-tu le pseudocode pour gérer ces cas ? Pense aussi à la structure de l’algorithme : quelles étapes pourraient être simplifiées ou rendues plus efficaces ? En te posant ces questions, tu commenceras à voir les algorithmes non pas comme des recettes figées, mais comme des solutions flexibles que tu peux ajuster pour répondre à différents besoins.\n"},{"id":41,"href":"/inf1220-hugo/docs/extra/ressources/","title":"Ressources","section":"Autres ressources","content":" Ressources pour apprendre Java # Ce document regroupe des ressources variées pour apprendre Java, des livres aux tutoriels en ligne, en passant par des vidéos et des conseils pratiques. Il s’adresse aux débutants comme aux apprenants intermédiaires souhaitant approfondir leurs compétences en programmation.\nOuvrages de référence # Les livres suivants offrent une introduction ou un approfondissement en Java, adaptés à différents niveaux :\nClaude Delannoy, Programmer en Java, Eyrolles : un ouvrage complet pour les débutants et intermédiaires. Barry Burd, Java pour les nuls, 4e édition (environ 25 $) : une approche conviviale, idéale pour les novices. Cyrille Herby, Apprenez à programmer en Java (environ 11 $) : un manuel axé sur la programmation professionnelle. Documentation officielle # La documentation d’Oracle est une référence incontournable pour comprendre les bases et explorer les fonctionnalités avancées :\nTutoriel officiel d’Oracle (en anglais) : une introduction progressive aux concepts fondamentaux.\nhttps://docs.oracle.com/javase/tutorial/ API Java 8 : une documentation détaillée pour cette version stable et largement utilisée.\nhttps://docs.oracle.com/javase/8/docs/api/ API Java 24 : la version la plus récente, incluant les dernières évolutions du langage.\nhttps://docs.oracle.com/en/java/javase/24/docs/api/ Guides en ligne # Les ressources numériques gratuites permettent un apprentissage autonome et flexible :\nSébastien Combéfis, Apprendre Java et la programmation orientée objet : un cours structuré pour débutants.\nhttps://www.ukonline.be/cours/java/apprendre-java Programmation Java sur Wikibooks : un guide collaboratif couvrant les bases et des sujets avancés.\nhttps://fr.wikibooks.org/wiki/Programmation_Java Stack Overflow : une plateforme pour poser des questions ou trouver des solutions à des problèmes concrets.\nhttps://stackoverflow.com/ Vidéos pédagogiques # YouTube propose des séries en français pour apprendre Java de manière visuelle :\nCours d’introduction à Java par FormationVideo : une série appréciée pour son approche claire.\nhttps://www.youtube.com/playlist?list=PLrSOXFDHBtfHkq8dd3BbSaopVgRSYtgPv Apprendre le Java : une série complète pour découvrir les bases.\nhttps://www.youtube.com/playlist?list=PLMS9Cy4Enq5LKYxJmD1ZIu3C7f3vA00hM Tuto Java : des explications simples pour progresser rapidement.\nhttps://www.youtube.com/playlist?list=PLBNheBxhHLQxfJhoz193-dRwvc2rl8AOW Java apprendre à coder : une approche pratique pour les débutants.\nhttps://www.youtube.com/playlist?list=PLvWq8NyUnHacq2hJ7S4FKhaQGN3xotKb7 Programmer en Java : des vidéos détaillées pour approfondir ses compétences.\nhttps://www.youtube.com/playlist?list=PLlxQJeQRaKDRnvgIvfHTV6ZY8M2eurH95 Conseils pour apprendre efficacement # Aucune ressource unique ne suffit pour maîtriser la programmation. Voici une approche recommandée :\nCommencez par un livre ou un tutoriel adapté à votre niveau pour poser des bases solides. Consultez la documentation officielle pour des précisions techniques sur des points spécifiques. Utilisez les vidéos pour visualiser les concepts et clarifier les notions abstraites. Pratiquez régulièrement avec des exercices ou des petits projets pour ancrer vos connaissances. En cas de blocage, Stack Overflow ou les forums de cours peuvent fournir des solutions concrètes. L’apprentissage de la programmation suit un processus itératif. Revisitiez les mêmes notions à travers différentes ressources (livres, vidéos, guides) pour consolider votre compréhension. Explorez au-delà des ressources proposées, car la recherche autonome est essentielle pour progresser. Par exemple, un manuel ne peut remplacer la pratique, tout comme un tutoriel vidéo ne suffit pas sans exercices. Adoptez une approche variée et persévérante.\n"},{"id":42,"href":"/inf1220-hugo/docs/modules/module4/travail-note-4/","title":"Travail noté 4","section":"Module 4: Les entrées et sorties","content":" Travail noté 4 - Les flux d\u0026rsquo;entrées et de sorties # Ce travail noté du cours INF1220 requiert de lire un fichier, valider ses données selon des règles spécifiques et afficher les résultats dans un autre format, exigeant une maîtrise des entrées/sorties, des chaînes de caractères et des structures de données en Java. Avant de commencer, il est impératif d’avoir complété et compris les lectures et exercices préparatoires, car sans cette préparation, la réussite du travail et des questions d’examen est compromise. L’utilisation du robot conversationnel du cours est permise, mais les réponses et analyses doivent être personnelles. Les étudiants doivent planifier leur temps rigoureusement, car la manipulation des entrées/sorties peut être complexe, et les travaux doivent être soumis avant la date de fin de cours, disponible sur le portail étudiant, sans possibilité de report sauf validation par l’Université pour des raisons exceptionnelles (maladie, deuil, etc.).\nLes travaux doivent être soumis sous forme de fichier PDF via l’outil de dépôt de la TÉLUQ, sans envoi par courriel, sous peine de note zéro. Le PDF doit permettre le copier-coller du code, être exempt de saisies d’écran ou de contenu manuscrit, et inclure du code testé et fonctionnel, car un code non fonctionnel peut entraîner une note de zéro. Les recherches sur Internet sont encouragées, mais aucun indice supplémentaire ne sera fourni au-delà de l’énoncé. La date de fin de cours, non négociable par les enseignants, marque la limite pour les soumissions, et tout travail remis tardivement risque une note de zéro ou un « incomplet », même si l’examen a lieu plus tard.\nLes travaux sont strictement individuels, et tout échange, notamment sur les réseaux sociaux, constitue une faute académique pouvant entraîner une note de zéro ou une exclusion du programme. Les étudiants doivent répartir leur code sur plusieurs pages si nécessaire pour en faciliter la lecture et accompagner celui-ci d’explications claires. La responsabilité du dépôt dans les délais et de la résolution des problèmes techniques avec l’outil de dépôt incombe à l’étudiant, qui doit contacter l’Université en cas de difficulté. Une préparation sérieuse et une vérification rigoureuse du travail avant soumission sont essentielles pour éviter les erreurs et maximiser la réussite.\nProblème\nDans un jeu de Sudoku, nous devons re-construire une grille comprenant 9 rangées et 9 colonnes. Chaque rangée et chaque colonne doit contenir tous les entiers de 1 à 9.\nVous devez créer un logiciel qui permet de charger des grilles de Sudoku à partir de fichiers, de manipuler les grilles (placements, vérifications), puis enfin de reproduire de nouveau les grilles soit à l'écran soit dans des fichiers. Les fichiers de Sudoku comportent une suite de triplets de chiffres séparés par des espaces, où chaque triplet correspond à : x: numéro de la ligne. y: numéro de la colonne. z: valeur En informatique, on numérote le plus souvent des colonnes et des rangées en commençant par zéro.\nExemples :\nContenu du fichier partie1.txt\n001 012 023 034 045 056 067 078 089 102 113 124 135 146 157 168 179 181 203 214 225 236 247 258 269 271 282 304 315 326 337 348 359 361 372 383 405 416 427 438 449 451 462 473 484 506 517 528 539 541 552 563 574 585 607 618 629 631 642 653 664 675 686 708 719 721 732 743 754 765 776 787 809 811 822 833 844 855 866 877 888 Contenu du fichier partie2.txt\n016 112 214 319 417 511 618 713 815 027 129 221 328 425 523 626 722 824 033 138 235 332 436 534 631 737 839 048 141 243 347 449 545 644 746 842 059 157 252 351 454 556 655 758 853 065 164 266 363 462 568 667 769 861 074 173 279 376 471 577 672 775 878 081 186 288 385 483 582 689 784 887 092 195 297 394 498 599 693 791 89 Contenu du fichier partie3.txt\n014 116 218 313 411 517 615 712 819 022 127 225 324 428 529 623 726 821 031 133 239 335 436 532 637 734 838 045 148 246 349 447 541 642 743 844 057 159 252 356 454 553 651 758 855 063 161 264 362 465 568 669 767 866 079 174 273 371 472 576 678 775 877 086 182 287 388 489 585 684 781 883 098 195 291 397 493 594 696 799 892 Dans ces exemples, les données ne sont pas nécessairement correctes. C'est votre travail de créer un programme qui peut traiter les erreurs.\nVous pouvez créer un tel fichier sur votre machine avec un éditeur de texte, vous pouvez utiliser le système du site du cours, ou vous pouvez utiliser le projet repl.it préconfiguré où ces fichiers apparaissent déjà.\nFonctionnalités/classes demandées\nVotre programme doit faire trois opérations spécifiques:\nCharger un fichier contenant des données selon le format spécifié (une suite de triplets de chiffres séparés par des espaces). Vous pouvez choisir l'approche que vous préférez. Le fichier peut être récupéré en ligne, par l'ouverture d'un fichier sur votre disque ou par l'entrée standard (stdin). Votre code doit gérer les erreurs de lecture. Valider que le fichier correspond à un tableau Sudoku valable. C'est-à-dire qu'il doit correspondre à un tableau 9x9 où chaque chiffre de 1 à 9 apparaît une seule fois par colonne et une seule fois par rangée. Pour les fins de ce travail, nous n’exigeons pas que chaque sous-grille de 3×3 contienne tous les chiffres de 1 à 9 (vous pouvez cependant faire cette vérification supplémentaire si vous le souhaitez). En cas d'erreur, votre programme doit générer une exception. Votre programme doit ensuite appliquer une transposition au tableau correspondant à un calcul de matrice transposée et afficher le résultat à l'écran. Au lieu de l'afficher à l'écran, vous (en tant que programmeur) pouvez l'enregistrer comme nouveau fichier ou utiliser un autre moyen de transmission. Choisissez l'approche qui vous plaît le plus en tant que programmeur. Vous devez tester votre solution avec plus d'une grille; en particulier, incluez une grille qui est asymétrique (qui n'est pas identique à sa transposée) dans vos tests. Donnez le résultat d'au moins deux tests différents, au-delà du fichier partie1.txt. Vous pouvez utiliser des saisies d'écran pour présenter vos résultats. Vous devez expliquer votre programme avec soin et en détail. Chaque fonction et chaque variable du programme doit être justifiée. Les qualifiants (static, public, protected et private) doivent être justifiés un par un: vous ne pouvez pas utiliser le mot-clé « static » sans le justifier. Si vous remettez votre code sans explications claires et sans tout justifier, une note de zéro pourra être attribuée, sans possibilité de reprise.\nSi le code de votre solution n'est pas du Java valable, s'il ne compile pas, une note de zéro pourra être attribuée. Pour réussir ce cours, vous devez être capable d'écrire du code Java fonctionnel et correct.\nEn ligne sur le site du cours # Vous pouvez écrire votre programme directement sur le site du cours.\nTravail4.javaimport java.io.*; class Travail4 { public static void main(String[] args) throws IOException { File FichierALire = new File(\u0026#34;partie1.txt\u0026#34;); try ( FileReader unFichier = new FileReader(FichierALire); BufferedReader leBuffer = new BufferedReader(unFichier); ) { // Nous avons les fichiers partie1.txt, // partie2.txt et partie3.txt. System.out.println(\u0026#34;ligne: \u0026#34;\u0026#43; leBuffer.readLine()); } catch (FileNotFoundException exception) { System.out.println(\u0026#34; Fichier introuvable!\u0026#34;); } } } partie1.txt001 012 023 034 045 056 067 078 089 102 113 124 135 146 157 168 179 181 203 214 225 236 247 258 269 271 282 304 315 326 337 348 359 361 372 383 405 416 427 438 449 451 462 473 484 506 517 528 539 541 552 563 574 585 607 618 629 631 642 653 664 675 686 708 719 721 732 743 754 765 776 787 809 811 822 833 844 855 866 877 888 partie2.txt016 112 214 319 417 511 618 713 815 027 129 221 328 425 523 626 722 824 033 138 235 332 436 534 631 737 839 048 141 243 347 449 545 644 746 842 059 157 252 351 454 556 655 758 853 065 164 266 363 462 568 667 769 861 074 173 279 376 471 577 672 775 878 081 186 288 385 483 582 689 784 887 092 195 297 394 498 599 693 791 89 partie3.txt014 116 218 313 411 517 615 712 819 022 127 225 324 428 529 623 726 821 031 133 239 335 436 532 637 734 838 045 148 246 349 447 541 642 743 844 057 159 252 356 454 553 651 758 855 063 161 264 362 465 568 669 767 866 079 174 273 371 472 576 678 775 877 086 182 287 388 489 585 684 781 883 098 195 291 397 493 594 696 799 892 Exécuter Repl.it Vous pouvez écrire votre programme en ligne avec repl.it.\nVous avez un certain degré de liberté dans la réalisation de ce travail. Par exemple...\nSi ça vous plaît, vous pouvez offrir un choix à l'utilisateur. Est-ce qu'il souhaite avoir le résultat à l'écran, ou sur disque, ou autrement? Si ça vous plaît, vous pouvez offrir à l'utilisateur de choisir où enregistrer le fichier sur disque. Si ça vous plaît, vous pouvez offrir à l'utilisateur de choisir comment il souhaite que les données s'affichent à l'écran. Nous vous donnons cette liberté intentionnellement. Vous pouvez aller au plus simple, ou développer une solution sophistiquée. Vous pouvez utiliser un affichage des résultats élégant ou faire quelque chose de plus minimaliste. Pour les notes, seule les fonctions essentielles comptent. Ainsi donc, si vous faites une solution très complexe, vous n'aurez pas nécessairement plus de points.\nNote : En programmation, il est considéré comme étant disgracieux d'inclure directement dans votre code une adresse ou un chemin.\nIndice. Rendez-vous sur la page du robot conversationnel du cours et saisissez l'énoncé dans la boîte de saisie: « Dans un jeu de Sudoku, nous devons re-construire une grille comprenant 9 rangées et 9 colonnes. Chaque rangée et chaque colonne doit contenir tous les entiers de 1 à 9. Vous devez créer un logiciel qui permet de charger des grilles de Sudoku à partir de fichiers, de manipuler les grilles (placements, vérifications), puis enfin de reproduire de nouveau les grilles soit à l'écran soit dans des fichiers. Les fichiers de Sudoku comportent une suite de triplets de chiffres séparés par des espaces, où chaque triplet correspond à : x: numéro de la ligne, y: numéro de la colonne, z: valeur. Charger un fichier contenant des données selon le format spécifié (une suite de triplets de chiffres séparés par des espaces). Vous pouvez choisir l'approche que vous préférez. Le fichier peut être récupéré en ligne, par l'ouverture d'un fichier sur votre disque ou par l'entrée standard (stdin). Votre code doit gérer les erreurs de lecture. Valider que le fichier correspond à un tableau Sudoku valable. C'est-à-dire qu'il doit correspondre à un tableau 9x9 où chaque chiffre de 1 à 9 apparaît une seule fois par colonne et une seule fois par rangée. Pour les fins de ce travail, nous n’exigeons pas que chaque sous-grille de 3×3 contienne tous les chiffres de 1 à 9 (vous pouvez cependant faire cette vérification supplémentaire si vous le souhaitez). En cas d'erreur, votre programme doit générer une exception. Votre programme doit ensuite appliquer une transposition au tableau correspondant à un calcul de matrice transposée et afficher le résultat à l'écran. ».\nEn terminant Dans plusieurs cas, vos travaux sont corrigés par un « correcteur ». Il est possible que vous puissiez identifier cette personne en examinant le document de rétroaction que vous recevez au sein du portail étudiant. Vous ne devriez jamais joindre cette personne. Cette personne n'a pas comme mandat de répondre à vos questions suite à la correction. Vos courriels seront ignorés. Il faut plutôt joindre la personne qui vous encadre au sein du cours.\n"},{"id":43,"href":"/inf1220-hugo/docs/modules/module1/algorithmes3/","title":"Les algorithmes: les structures de contrôle","section":"Module 1: Algorithme et pseudocode","content":" Les structures de contrôle # Les structures de contrôle sont au cœur de la conception d’algorithmes, car elles permettent de guider l’exécution en fonction de conditions ou de répéter des opérations sur des données. Elles offrent la flexibilité nécessaire pour traiter des situations dynamiques, comme des données de taille variable, et évitent la répétition inutile d’instructions. En combinant des branchements (choix conditionnels) et des boucles (répétitions), elles permettent de construire des solutions logiques et efficaces, adaptées à une grande variété de problèmes.\nLes structures de contrôle alternatives (l\u0026rsquo;embranchement) # On peut concevoir un algorithme qui ne comprend qu\u0026rsquo;une liste d\u0026rsquo;opérations simples (addition, soustraction, etc.). Cependant sans structures de contrôle, nous auront du mal à gérer les données dynamiques, par exemple un tableau qui peut contenir un nombre variable d\u0026rsquo;éléments, et on risque de devoir répéter beaucoup d\u0026rsquo;opérations. Les structures de contrôle permettent à l\u0026rsquo;algorithme de faire des choix de traitement en fonction de conditions. On peut également parler de branchement, terme provenant des premiers ordinateurs où les sorties de cartes de contrôle correspondaient littéralement à des câbles menant à d\u0026rsquo;autres composantes de l\u0026rsquo;ordinateur. Une structure de contrôle correspond à l\u0026rsquo;action de tester des variables de contrôle et selon les résultats d\u0026rsquo;effectuer des opérations ou non. En pratique, ces structures correspondent à poser des questions avec la syntaxe suivante : SI conditions ALORS opérations FIN SI. Il peut y avoir plusieurs conditions dans une structure de contrôle et la logique booléenne est utilisée pour les construire. Par exemple, SI a est égal 0 ET b est égal 1 ALORS faire c FIN SI.\nDans la notion de pseudo-code, il est également possible de faire une suite de structures de contrôle avec la syntaxe suivante : SI conditionA ALORS opérations SINON SI conditionB ALORS opérations SINON SI conditionC ALORS [et ainsi de suite] FIN SI.\nConsidérons l\u0026rsquo;exemple suivant. Il s\u0026rsquo;agit d\u0026rsquo;un outil interactif qui t’aide à comprendre comment un algorithme utilise des conditions pour classer une personne selon son âge. Pour commencer, saisis un âge entier positif dans le champ prévu, par exemple « 25 ». Ensuite, clique sur « Prochaine étape » pour exécuter l’algorithme étape par étape. À chaque clic, une ligne du pseudocode s’illumine, et un message explicatif apparaît dans la zone de journalisation en bas. Tu verras également l’état mis à jour : l’âge saisi et la catégorie déterminée (comme « Vous êtes un adulte »). Si tu veux recommencer, clique sur « Réinitialiser » pour effacer les résultats. Attention, l’âge doit être un nombre entier positif, sinon un message te demandera de corriger.\nCet outil vous permet de suivre le raisonnement de l’algorithme de manière claire. Le pseudocode, affiché à gauche, utilise une structure conditionnelle (SI, SINON SI, SINON) pour évaluer l’âge et assigner une catégorie : enfant (≤ 10 ans), adolescent (\u0026gt; 10 et \u0026lt; 18 ans), adulte (≥ 18 et \u0026lt; 65 ans) ou personne âgée (≥ 65 ans). En progressant dans les étapes, observe comment l’algorithme teste chaque condition et choisit la bonne catégorie. Lisez attentivement les messages du journal pour comprendre les décisions prises.\nCatégorie d'âge Entrez un âge et exécutez le pseudocode pour déterminer la catégorie d'âge.\nPseudocode\nÉtat\nÂge : 0\nSortie : -\nProchaine étape Réinitialiser Après avoir utilisé l’outil, prends un moment pour réfléchir à la flexibilité de cet algorithme. Comment pourrais-tu le modifier pour ajouter de nouvelles catégories, comme « bébé » pour les âges de 0 à 2 ans, ou pour inclure des critères supplémentaires, comme une distinction entre « jeune adulte » et « adulte senior » ? Que se passerait-il si l’âge pouvait être négatif ou non entier ? Comment adapterais-tu le pseudocode pour gérer ces cas ? En explorant ces questions, tu commenceras à voir comment personnaliser un algorithme pour répondre à des besoins spécifiques, une étape essentielle pour devenir un programmeur créatif.\nLes structures de contrôle itératives (la boucle) # Il arrive régulièrement dans la résolution d\u0026rsquo;un problème qu\u0026rsquo;il est nécessaire de réaliser à plusieurs reprises une ou des opérations sur un ensemble de données. Par exemple, supposons qu\u0026rsquo;il est nécessaire de trouver le plus petit nombre dans un tableau d\u0026rsquo;entiers. Il sera forcément nécessaire d\u0026rsquo;itérer dans le tableau, une ligne à la fois, et de comparer les nombres entre eux. Pour ce faire, nous utiliserons deux éléments de syntaxe, soit le TANT QUE _ FAIRE ou bien le POUR TOUT _ FAIRE. Voici deux exemples de l\u0026rsquo;utilisation de ces deux approches :\nPseudocode 1 : Boucle POUR TOUT Entrées : Tableau d\u0026#39;entiers : tableau[100] Sorties : Entier minimum minimum = tableau[0] POUR TOUT Entier e de tableau FAIRE SI e \u0026lt; minimum ALORS minimum = e; FIN SI FIN POUR TOUT Ce pseudocode décrit un algorithme pour trouver la valeur minimale dans un tableau d’entiers de taille 100. L’algorithme commence par initialiser la variable minimum à la première valeur du tableau (tableau[0]), en supposant que le tableau n’est pas vide. Ensuite, une boucle (POUR TOUT Entier e de tableau FAIRE) parcourt chaque élément e du tableau. À chaque itération, si l’élément e est inférieur à la valeur actuelle de minimum, alors minimum est mis à jour avec la valeur de e (minimum = e). À la fin de la boucle, minimum contient la plus petite valeur du tableau, qui est retournée comme résultat.\nPseudocode 2 : Boucle TANT QUE Entrées : Tableau d\u0026#39;entiers : tableau[100] Sorties : Entier minimum minimum = tableau[0] Entier iterateur = 0; TANT QUE iterateur \u0026lt; 100 FAIRE SI tableau[iterateur] \u0026lt; minimum ALORS minimum = tableau[iterateur]; FIN SI iterateur = iterateur + 1; FIN TANT QUE Ce pseudocode décrit un algorithme pour trouver la valeur minimale dans un tableau d’entiers de taille 100. Une variable minimum est initialisée avec la première valeur du tableau (tableau[0]), supposant que le tableau n’est pas vide. Une variable iterateur est initialisée à 0 pour suivre la position dans le tableau. La boucle (TANT QUE iterateur \u0026lt; 100 FAIRE) parcourt le tableau tant que iterateur est inférieur à 100. À chaque itération, si l’élément à l’indice iterateur (tableau[iterateur]) est inférieur à minimum, alors minimum est mis à jour avec cette valeur. Ensuite, iterateur est incrémenté de 1 (iterateur = iterateur + 1) pour passer à l’élément suivant. À la fin de la boucle, minimum contient la plus petite valeur du tableau, qui est retournée.\nComposition # Dans la pratique, un algorithme peut comporter plusieurs structures de contrôle itératives, plusieurs structures de contrôle alternatives et plusieurs opérations. On peut les combiner de diverses manières. Il est possible, par exemple, d\u0026rsquo;avoir une boucle TANT QUE au sein d\u0026rsquo;une autre boucle TANT QUE.\nTANT QUE x \u0026gt; 0 FAIRE TANT QUE x \u0026gt; 10 FAIRE x = x - 1 FIN TANT QUE FIN TANT QUE Ce pseudocode décrit une structure de boucles imbriquées qui modifie la valeur de la variable x jusqu\u0026rsquo;à ce qu\u0026rsquo;elle devienne inférieure ou égale à 0. La boucle externe (TANT QUE x \u0026gt; 0 FAIRE) continue tant que x est strictement positif. À l\u0026rsquo;intérieur, la boucle interne (TANT QUE x \u0026gt; 10 FAIRE) s\u0026rsquo;exécute uniquement si x est supérieur à 10, et dans ce cas, elle décrémente x de 1 à chaque itération (x = x - 1). Une fois que x devient inférieur ou égal à 10, la boucle interne s\u0026rsquo;arrête, mais la boucle externe ne se termine pas immédiatement, car elle vérifie seulement si x \u0026gt; 0. Cependant, comme il n\u0026rsquo;y a aucune instruction dans la boucle externe pour modifier x lorsque x ≤ 10, le programme entre dans une boucle infinie si x est compris entre 1 et 10 inclus. Si x est initialement supérieur à 10, il sera décrémenté jusqu\u0026rsquo;à atteindre 10, puis le programme se bloquera. Si x est initialement inférieur ou égal à 0, aucune des boucles ne s\u0026rsquo;exécute.\nLa fin d\u0026rsquo;un algorithme # Un algorithme continue à s\u0026rsquo;exécuter tant qu\u0026rsquo;il reste des operations à faire. L\u0026rsquo;algorithme prend fin lorsque nous rencontrons la fin du pseudo-code ou lorsque le programmeur invoque la fin spécifiquement. Dans l\u0026rsquo;exemple suivant, le programmeur demander à ce que l\u0026rsquo;on cesse l\u0026rsquo;exécution dès que la valeur 5 est rencontrée.\nx = 0 TANT QUE x \u0026lt; 10 ALORS ajoute un à x SI x == 5 ALORS TERMINE FIN TANT QUE AFFICHE x La valeur x ne sera donc jamais affichée.\nIl arrive aussi qu\u0026rsquo;un pseudo-code doit retourner une valeur. Par convention, dès que la valeur attendue est retournée, l\u0026rsquo;algorithme prend fin. Ainsi donc, dans le cas suivant, la valeur 5 sera retournée.\nx = 0 TANT QUE x \u0026lt; 10 ALORS ajoute un à x SI x == 5 ALORS RETOURNE x FIN TANT QUE RETOURNE x Exécution d\u0026rsquo;un pseudo-code # Pour comprendre un pseudo-code que vous venez de recevoir, ou pour tester un pseudo-code que vous venez de créer, il est essentiel de l\u0026rsquo;exécuter. Quand on exécute un pseudo-code, on se contente de lire les consignes logiques.\nPrenons un exemple:\nVariable test = 0 TANT QUE test \u0026lt; 100 test = test + 22 FIN TANT QUE retourne test graph TD A[Début] --\u003e B[Initialiser test = 0] B --\u003e C{test \u003c 100 ?} C -- Vrai --\u003e D[test = test + 22] D --\u003e C C -- Faux --\u003e E[Retourner test] E --\u003e F[Fin] Je débute le pseudo-code avec la valeur 0 stockée dans la variable test. J\u0026rsquo;entre dans la boucle TANT QUE. J\u0026rsquo;ajoute 22 à la variable test, le résultat est 22. J\u0026rsquo;entre dans la boucle TANT QUE. J\u0026rsquo;ajoute 22 à la variable test, le résultat est 44. J\u0026rsquo;entre dans la boucle TANT QUE. J\u0026rsquo;ajoute 22 à la variable test, le résultat est 66. J\u0026rsquo;entre dans la boucle TANT QUE. J\u0026rsquo;ajoute 22 à la variable test, le résultat est 88. J\u0026rsquo;entre dans la boucle TANT QUE. J\u0026rsquo;ajoute 22 à la variable test, le résultat est 110. Je quitte la boucle TANT QUE. Je retourne la valeur stockée dans la variable test, soit 110. Vous devez absolument être capable de faire de telles exécutions. Dans certains cas, votre pseudo-code va dépendre de paramètres: il faut alors exécuter le pseudo-code plus d\u0026rsquo;une fois, sur plusieurs cas de test. Dans certains cas, le pseudo-code peut prendre trop d\u0026rsquo;étapes pour qu\u0026rsquo;un humain puisse l\u0026rsquo;exécuter entièrement : vous devriez au moins en faire une partie.\nVidéo suggérée # "},{"id":44,"href":"/inf1220-hugo/docs/modules/module3/activite-3-4/","title":"Les exceptions","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" Les exceptions # En programmation, il est essentiel de pouvoir gérer les erreurs qui peuvent survenir lors de l’exécution d’un programme. Java propose un mécanisme puissant et structuré : les exceptions. Plutôt que de laisser le programme s’arrêter brutalement en cas de problème (comme une division par zéro ou l’ouverture d’un fichier inexistant), Java permet de « lancer » une exception. Cette exception peut alors être capturée et traitée, ce qui rend le code plus robuste, plus lisible et plus facile à maintenir.\nLes erreurs et exceptions en Java # La plupart des langages modernes distinguent deux types de fautes : celles détectées à la compilation (par exemple, l’oubli d’un point-virgule) et celles qui surviennent à l’exécution. En Java, lorsqu’une erreur se produit à l’exécution, la machine virtuelle Java (JVM) génère une exception ou une erreur. Il est important de distinguer :\nUne erreur (Error) : événement grave, souvent lié au système, que l’on ne cherche généralement pas à intercepter (ex. : manque de mémoire). Une exception (Exception) : situation inhabituelle ou fautive que le programme peut choisir de gérer (ex. : division par zéro, fichier absent). Gérer les exceptions permet d’éviter que le programme ne s’arrête de façon inattendue et d’informer l’utilisateur ou le développeur de ce qui s’est passé. Par exemple, si une application perd la connexion réseau, elle peut afficher un message d’erreur et tenter de se reconnecter, plutôt que de planter.\nLa structure try-catch # Pour gérer les exceptions, on utilise la structure try-catch. On place dans le bloc try le code susceptible de provoquer une erreur. Si une exception survient, le flux d’exécution passe dans le bloc catch, où l’on peut réagir de façon appropriée.\ntry { // Code susceptible de générer une exception } catch (Exception e) { // Code exécuté si une exception est levée } On peut aussi intercepter des erreurs, mais ce n’est généralement pas recommandé :\ntry { // Code... } catch (Error e) { // Gestion d’une erreur système } Dans le bloc catch, on peut :\nAfficher un message d’erreur Journaliser l’erreur Relancer l’exception (throw e;) Arrêter le programme (System.exit(1);) Exemples :\ntry { // ... } catch (Exception e) { e.printStackTrace(); // Affiche la trace de l’erreur } try { // ... } catch (Exception e) { e.printStackTrace(); throw e; // Relance l’exception } try { // ... } catch (Exception e) { e.printStackTrace(); System.exit(1); // Arrête le programme } try { // ... } catch (Exception e) { Logger.getLogger(\u0026#34;Erreur.log\u0026#34;).severe(e.getMessage()); // Journalise l’erreur } On peut utiliser plusieurs blocs catch pour gérer différents types d’exceptions :\ntry { String test = null; test.charAt(0); } catch (NullPointerException e) { // Gestion spécifique du cas où test est null e.printStackTrace(); } catch (Exception e) { // Gestion générale e.printStackTrace(); } Les blocs catch sont évalués dans l’ordre : le premier qui correspond à l’exception levée sera exécuté.\nLes exceptions peuvent être causées par :\nDes erreurs de programmation (ex. : accès à un index hors limites) Des événements extérieurs (ex. : fichier absent, réseau coupé) Des conditions prévues par le programmeur (qui peut lancer une exception volontairement) Lancer des exceptions # Pour signaler une situation anormale, un programmeur peut lancer une exception avec le mot-clé throw :\nthrow new Exception(); throw new SQLException(\u0026#34;Utilisateur inconnu\u0026#34;); Si l’exception n’est pas capturée, elle remonte la pile d’appels jusqu’à la méthode main, puis provoque l’arrêt du programme. On peut aussi déclarer qu’une méthode peut lancer une exception avec le mot-clé throws :\npublic void maMethode() throws IOException { // ... } Voici un exemple illustrant la propagation d’une exception à travers plusieurs méthodes :\nExempleTryCatch.java import java.time.DateTimeException; import java.util.logging.Level; import java.util.logging.Logger; public class ExempleTryCatch { public static void main(String[] args) { ExempleTryCatch ex = new ExempleTryCatch(); try { ex.deuxiemeMethode(); } catch (Exception ex1) { Logger.getLogger( ExempleTryCatch.class.getName()).log( Level.SEVERE, null, ex1); } try { ex.quatriemeMethode(); } catch (Exception ex1) { Logger.getLogger( ExempleTryCatch.class.getName()).log( Level.SEVERE, null, ex1); } } public void premiereMethode() throws NullPointerException { String test = null; test.charAt(0); } public void deuxiemeMethode() throws Exception { premiereMethode(); } public void troisiemeMethode() throws DateTimeException { throw new DateTimeException(\u0026#34;Wrong Date Format\u0026#34;); } public void quatriemeMethode() throws Exception { troisiemeMethode(); } } Exécuter Les exceptions vérifiées # Les exceptions dites « vérifiées » (checked) sont des exceptions que le compilateur Java oblige à traiter explicitement, soit en les capturant avec un bloc try/catch, soit en les déclarant avec throws dans la signature de la méthode. Elles héritent de la classe Exception (mais pas de RuntimeException).\nUn exemple classique d’exception checked est IOException, qui peut survenir lors de la lecture ou l’écriture de fichiers. Voici un exemple :\nimport java.io.*; public class ExempleChecked { public static void main(String[] args) { try { BufferedReader reader = new BufferedReader(new FileReader(\u0026#34;fichier.txt\u0026#34;)); String ligne = reader.readLine(); System.out.println(ligne); reader.close(); } catch (IOException e) { System.out.println(\u0026#34;Erreur d\u0026#39;entrée/sortie : \u0026#34; + e.getMessage()); } } } Dans cet exemple, FileReader et readLine peuvent lancer une IOException : le compilateur oblige à traiter cette exception.\nOn peut aussi propager l’exception à la méthode appelante avec throws :\npublic void lireFichier(String nom) throws IOException { BufferedReader reader = new BufferedReader(new FileReader(nom)); String ligne = reader.readLine(); reader.close(); } Ici, la méthode signale qu’elle peut lancer une IOException, et c’est à l’appelant de la gérer.\nLes exceptions non vérifiées # Les exceptions non vérifiées (ou « unchecked ») héritent de la classe RuntimeException. Elles ne sont pas vérifiées par le compilateur : il n’est pas obligatoire de les capturer ni de les déclarer avec throws. Elles surviennent souvent lors d’erreurs de programmation (ex. : accès à un index hors limites, division par zéro, etc.).\nExemple classique : ArrayIndexOutOfBoundsException, qui se produit lorsqu’on tente d’accéder à un indice inexistant dans un tableau.\npublic class ExempleUnchecked { public static void main(String[] args) { int[] t = {1, 2, 3}; System.out.println(t[5]); // Provoque ArrayIndexOutOfBoundsException } } Dans cet exemple, aucune gestion d’exception n’est requise : si l’erreur survient, le programme s’arrête avec un message d’erreur.\nLa clause finally # Le bloc finally permet d’exécuter du code qui sera toujours exécuté à la fin d’un bloc try, que l’exception soit levée ou non, et même si un return est rencontré dans le try ou le catch. Il est souvent utilisé pour libérer des ressources (fichiers, connexions, etc.).\nExemple :\npublic class ExempleFinally { public static void main(String[] args) { try { System.out.println(\u0026#34;Début du try\u0026#34;); int x = 10 / 0; // Provoque une exception } catch (ArithmeticException e) { System.out.println(\u0026#34;Exception capturée\u0026#34;); } finally { System.out.println(\u0026#34;Bloc finally exécuté\u0026#34;); } System.out.println(\u0026#34;Après le try-catch-finally\u0026#34;); } } Sortie attendue :\nDébut du try Exception capturée Bloc finally exécuté Après le try-catch-finally La pile d’appels # La pile d’appels (ou « call stack ») est une structure de données interne utilisée par la machine virtuelle Java pour suivre l’enchaînement des appels de méthodes pendant l’exécution d’un programme. Chaque fois qu’une méthode est appelée, une nouvelle « case » (ou frame) est ajoutée au sommet de la pile ; quand la méthode se termine, cette case est retirée. Cela permet à Java de savoir où reprendre l’exécution après chaque appel de méthode.\nCe mécanisme est essentiel pour comprendre la gestion des exceptions et la récursivité. Lorsqu’une exception est levée, Java parcourt la pile d’appels de haut en bas pour trouver un bloc catch approprié. Si aucun n’est trouvé, le programme s’arrête et affiche la trace de la pile (stack trace), qui montre la séquence des appels ayant mené à l’erreur.\nExemple :\npublic class ExemplePileAppels { public static void main(String[] args) { methodeA(); } static void methodeA() { methodeB(); } static void methodeB() { int x = 1 / 0; // Provoque une exception } } La trace d’erreur affichera :\nException in thread \"main\" java.lang.ArithmeticException: / by zero at ExemplePileAppels.methodeB(ExemplePileAppels.java:9) at ExemplePileAppels.methodeA(ExemplePileAppels.java:6) at ExemplePileAppels.main(ExemplePileAppels.java:3) On voit que la pile d’appels retrace le chemin des méthodes jusqu’à l’origine de l’exception. Cela aide beaucoup à déboguer les programmes.\nLecture optionnelle dans le livre de référence (Delannoy) # Pour aller plus en profondeur sur les structures try-catch (optionnel), vous pouvez lire le chapitre 10 dans Programmer en Java de Claude Delannoy.\nVidéo # "},{"id":45,"href":"/inf1220-hugo/docs/modules/module2/conseils/","title":"Recommandations","section":"Module 2: Introduction au langage Java","content":" Recommandations # Il est important d\u0026rsquo;écrire du code lisible et bien documenté. Il s\u0026rsquo;agit d\u0026rsquo;un compétence nécessaire pour développer du logiciel en pratique.\nImportance de la lisibilité du code en Java # La lisibilité du code est essentielle en Java pour faciliter la maintenance et la collaboration. Un code lisible réduit les erreurs et permet à d\u0026rsquo;autres développeurs (ou à vous-même dans le futur) de comprendre rapidement l\u0026rsquo;intention du programme. Pour y parvenir, il faut adopter des conventions de nommage claires et commenter judicieusement. Les normes de codage, comme celles définies par Oracle ou Google, standardisent la structure du code, rendant les projets cohérents. Une variable bien nommée, comme nombreEtudiants au lieu de n, et des commentaires explicatifs améliorent la compréhension.\nNormes d\u0026rsquo;écriture de code en Java # Les normes de codage en Java, comme les Java Coding Conventions d\u0026rsquo;Oracle, définissent des règles précises. Les noms de classes commencent par une majuscule et suivent le style CamelCase (ex. : GestionEtudiants). Les méthodes et variables utilisent lowerCamelCase (ex. : calculerMoyenne). Les constantes sont en majuscules avec des underscores (ex. : MAX_ETUDIANTS). L\u0026rsquo;indentation est de 4 espaces, et les accolades {} suivent des conventions strictes, généralement placées à la fin de la ligne d\u0026rsquo;ouverture. Respecter ces normes garantit un code uniforme.\nComment commenter son code en Java # En Java, les commentaires servent à expliquer le code sans affecter son exécution. Il existe trois types de commentaires :\nCommentaire sur une ligne : // pour des explications courtes. Commentaire multi-lignes : /* */ pour des blocs plus longs. Javadoc : /* */ pour documenter classes, méthodes ou variables, générant une documentation automatique. Les commentaires doivent être concis, pertinents et éviter de paraphraser le code. Par exemple, un commentaire comme // Incrémente i est inutile si le code dit i++, mais // Calcule la moyenne des notes pour chaque étudiant est utile. 4. Exemple de bonne pratique : nommage et commentaires # Voici un exemple de code Java bien écrit, respectant les normes et utilisant des commentaires utiles :\npublic class GestionEtudiants { // Nombre maximum d\u0026#39;étudiants dans le système private static final int MAX_ETUDIANTS = 100; /** * Calcule la moyenne des notes d\u0026#39;un étudiant. * @param notes Tableau des notes de l\u0026#39;étudiant * @return La moyenne des notes, ou 0 si le tableau est vide */ public double calculerMoyenne(double[] notes) { if (notes.length == 0) { return 0.0; } double somme = 0.0; for (double note : notes) { somme += note; // Ajoute chaque note à la somme } return somme / notes.length; } } Ce code utilise des noms clairs (calculerMoyenne, notes), une constante bien nommée, et des commentaires Javadoc explicatifs.\nExemple de mauvaise pratique : code illisible # Voici un exemple de code mal écrit, à éviter :\npublic class C { int x = 100; double m(double[] a) { // calcul double s = 0; for(int i=0;i\u0026lt;a.length;i++) s+=a[i]; return a.length\u0026gt;0?s/a.length:0; } } Ce code utilise des noms de variables cryptiques (C, x, m, a), manque de commentaires clairs, et est mal indenté, rendant sa compréhension difficile.\nStructure et indentation # Une bonne indentation améliore la lisibilité. En Java, chaque niveau de bloc (méthodes, boucles, conditions) est indenté avec 4 espaces. Les accolades doivent être alignées, et chaque instruction est sur une nouvelle ligne. Par exemple :\nif (condition) { // Action si condition vraie faireQuelqueChose(); } else { // Action alternative faireAutreChose(); } Un code non indenté ou avec des instructions sur une seule ligne (ex. : if (x) y(); z();) est difficile à suivre.\nUtilisation des commentaires Javadoc # Les programmeurs Java utilisent généralement Javadoc. Javadoc est un outil fourni par Oracle, intégré à l\u0026rsquo;environnement de développement Java, qui permet de générer automatiquement une documentation à partir du code source Java. Il analyse les commentaires écrits dans un format spécifique (commentaires Javadoc) pour produire des pages HTML décrivant les classes, interfaces, méthodes, constructeurs et champs d\u0026rsquo;un programme.\nLes commentaires Javadoc sont placés directement dans le code, généralement avant une déclaration, et utilisent une syntaxe particulière commençant par /* et se terminant par */. Ces commentaires peuvent inclure des balises spécifiques pour structurer les informations, comme :\n@param : décrit un paramètre d\u0026rsquo;une méthode. @return : indique ce que retourne une méthode. @throws ou @exception : précise les exceptions lancées. @author : mentionne l\u0026rsquo;auteur du code. @version : indique la version de la classe ou de la méthode. Exemple de commentaire Javadoc pour une méthode :\n/** * Calcule la somme de deux entiers. * @param a Premier entier. * @param b Second entier. * @return La somme des deux entiers. * @throws IllegalArgumentException Si les paramètres sont négatifs. */ public int somme(int a, int b) { if (a \u0026lt; 0 || b \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;Les paramètres doivent être positifs.\u0026#34;); } return a + b; } Pour générer la documentation, on utilise la commande javadoc dans un terminal, suivie des fichiers source ou des packages à documenter. Par exemple :\njavadoc -d doc MonFichier.java Cela crée un dossier doc contenant des fichiers HTML consultables dans un navigateur, avec une navigation structurée (index, liste des classes, détails des méthodes, etc.).\nLes commentaires Javadoc sont essentiels pour documenter les API publiques. Ils doivent décrire le but de la classe ou de la méthode, les paramètres, la valeur de retour, et les exceptions possibles. Par exemple :\n/** * Représente un étudiant avec un nom et une liste de notes. */ public class Etudiant { /** * Ajoute une note à la liste de l\u0026#39;étudiant. * @param note La note à ajouter (entre 0 et 20) * @throws IllegalArgumentException si la note est invalide */ public void ajouterNote(double note) { if (note \u0026lt; 0 || note \u0026gt; 20) { throw new IllegalArgumentException(\u0026#34;Note invalide\u0026#34;); } // Logique d\u0026#39;ajout } } Un Javadoc clair aide à générer une documentation professionnelle. Par contre, il faut utilise son bon jugement. Il est parfois plus clair de produire un code concis sans commentaires.\nPar ailleurs les commentaires ne devraient pas simplement décrire le code. Dans de tels cas, les commentaires ajoutent du bruit, comme dans l\u0026rsquo;exemple suivant. Par exemple, un commentaire comme // Vérifie si la note est négative avant if (note \u0026lt; 0) est redondant. Voici un mauvais exemple :\n/** * Définit le nom de l\u0026#39;étudiant. * @param n Le nom à définir */ // Met le nom dans la variable nom public void setNom(String n) { nom = n; // Assigne n à nom } Dans cet exemple, les commentaires répètent l\u0026rsquo;évidence et encombrent le code. En revanche, un commentaire expliquant pourquoi une méthode est conçue d\u0026rsquo;une certaine manière (ex. : contraintes spécifiques ou cas d\u0026rsquo;utilisation) est pertinent. L\u0026rsquo;objectif est de commenter de manière stratégique pour maximiser la clarté sans alourdir le code.\nConsidérons un autre exemple. Écrire // Boucle sur les éléments avant une boucle for est inutile, car le code est explicite. En revanche, expliquer pourquoi une boucle est utilisée est pertinent. Mauvais exemple :\n// Boucle sur i for (int i = 0; i \u0026lt; 10; i++) { // Incrémente x x++; } Voici un meilleur exemple.\n// Parcourt les 10 premières entrées pour initialiser le compteur for (int i = 0; i \u0026lt; 10; i++) { compteurInitial++; } Avec les versions récentes de Java, je recommande d\u0026rsquo;utiliser MarkDown pour les commentaires, comme dans cet exemple :\n/** * # Exemple * * Ceci est un commentaire en *Markdown*. * * - Partie 1 * - Partie 2 * * [Ceci est un lien](http://www.exemple.com/) */ public class Example { // Class implementation } Markdown est un langage de balisage léger conçu pour formater du texte de manière simple et lisible, tout en permettant une conversion facile vers du HTML. Il a été créé en 2004 par John Gruber, avec l’aide d’Aaron Swartz, dans le but de rendre l’écriture de documents structurés accessible à tous, sans complexité technique. John Gruber, blogueur et développeur américain, a développé Markdown pour répondre au besoin d’un format de texte qui soit à la fois facile à lire en brut et simple à convertir en HTML pour le web. Aaron Swartz, programmeur et militant de l’Internet, a contribué à l’implémentation du premier convertisseur Markdown. Le nom « Markdown » évoque l’idée de « réduire » (mark down) la complexité du balisage traditionnel.\nMarkdown permet de structurer un texte avec des titres, des listes, des liens, des images, des citations, du code, etc., en utilisant une syntaxe intuitive :\nTitres : Utilisation du symbole # (un ou plusieurs) en début de ligne. Listes : Listes à puces avec -, * ou +, listes numérotées avec des chiffres suivis d’un point. Liens : [texte du lien](URL) Images : ![texte alternatif](URL) Texte en gras : *gras* ou __gras__ Texte en italique : *italique* ou _italique_ Citations : \u0026gt; citation Markdown est largement utilisé pour la documentation, les fichiers README, les blogs, et de nombreux outils collaboratifs (GitHub, GitLab, forums, etc.). Sa simplicité et sa portabilité en font un standard de facto pour la rédaction technique et pédagogique.\nTestez votre compréhension du MarkDown avec l\u0026rsquo;outil suivant.\nOrganisation des classes # Une classe Java bien organisée suit un ordre logique : constantes, attributs, constructeurs, méthodes publiques, puis méthodes privées. Chaque section est séparée par des lignes vides ou des commentaires. Exemple :\npublic class CompteBancaire { // Constantes private static final double SOLDE_MINIMUM = 0.0; // Attributs private double solde; // Constructeurs public CompteBancaire(double soldeInitial) { this.solde = soldeInitial; } // Méthodes publiques public void deposer(double montant) { solde += montant; } } Une organisation chaotique rend le code difficile à naviguer.\nMaintenir la cohérence dans un projet # Dans un projet Java, tous les développeurs doivent suivre les mêmes conventions pour garantir l\u0026rsquo;uniformité. Utiliser des outils comme Checkstyle ou SonarLint aide à détecter les violations des normes (mauvaise indentation, noms non conformes). Par exemple, si une équipe décide que les noms de variables doivent toujours inclure le type (ex. : listeEtudiants au lieu de etudiants), cette règle doit être appliquée partout. Une cohérence rigoureuse réduit les frictions lors des révisions de code et améliore la qualité globale du projet.\nEn conclusion, écrire du code Java lisible nécessite des noms explicites, une indentation soignée, des commentaires pertinents, et le respect des normes. En évitant les pièges comme les noms cryptiques ou les commentaires inutiles, vous produisez un code clair, maintenable et professionnel.\nPackages # Pour les projets qui prennent beaucoup d\u0026rsquo;ampleur, il peut être nécessaire d\u0026rsquo;organiser votre code Java en packages. Ça ne sera pas nécessaire dans ce cours, mais vous devriez comprendre le principle.\nPour utiliser les packages dans votre propre code, commencez par structurer votre projet en créant une arborescence de répertoires qui correspond à la hiérarchie des packages. Par exemple, pour un package nommé com.monentreprise.monapplication, créez un dossier com/monentreprise/monapplication dans votre répertoire source. Placez vos fichiers Java, comme MaClasse.java, dans ce dossier, et ajoutez la ligne package com.monentreprise.monapplication; en haut de chaque fichier. Cette organisation permet de regrouper les classes par fonctionnalité, par exemple, un package com.monentreprise.monapplication.model pour les classes de données et un autre com.monentreprise.monapplication.util pour les utilitaires. Compilez et exécutez votre code en veillant à ce que le répertoire racine des packages soit inclus dans le chemin de classe (classpath).\nLors de l’utilisation de vos propres packages, vous pouvez importer vos classes dans d’autres parties du projet avec import. Par exemple, si une classe Utilisateur est définie dans com.monentreprise.monapplication.model, vous pouvez l’importer dans une autre classe avec import com.monentreprise.monapplication.model.Utilisateur;. Si vos classes se trouvent dans le même package, aucune importation n’est nécessaire. Pour partager votre code ou le déployer, vous pouvez empaqueter vos classes dans un fichier JAR, en respectant la structure des packages. Une convention courante pour nommer les packages est d’utiliser le domaine de votre organisation en sens inverse (par exemple, com.monentreprise), ce qui garantit l’unicité des noms et facilite la collaboration ou l’intégration avec d’autres projets.\n"},{"id":46,"href":"/inf1220-hugo/docs/evaluation/","title":"Évaluation","section":"Docs","content":" Évaluation # Ce cours compte 5 travaux notés à remettre au cours des 15 semaines et d'un examen final à réaliser à la fin du cours. Voici la grille de pondération des travaux :\nÉvaluations Sujets Travail Noté #1 Les algorithmes Travail Noté #2 Types, opérateurs et méthodes Travail Noté #3 Structures de contrôle, itérations et données Travail Noté #4 Les flux d\u0026rsquo;entrée et de sortie Travail Noté #5 Héritage et polymorphismes Examen L\u0026rsquo;ensemble du cours Avant de faire les travaux, il faut avoir fait les lectures et les exercices de préparation. Essayez d'aller directement aux travaux notés est une stratégie perdante pour la plupart des étudiants. Prenez le temps d'étudier la matière! Dans tous les cas, vous devez expliquer vos solutions. Les travaux notés sont des travaux individuels. Vous devez les réaliser seul. "},{"id":47,"href":"/inf1220-hugo/docs/modules/module3/activite-3-5/","title":"La récursivité","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" La récursivité # La récursivité est une technique fondamentale en informatique qui consiste pour une fonction à s’appeler elle-même afin de résoudre un problème en le divisant en sous-problèmes plus simples. Cette approche permet d’exprimer élégamment des solutions à des problèmes complexes, comme le calcul de suites, la recherche dans des structures arborescentes ou la résolution de certains algorithmes mathématiques. Comprendre la récursivité est essentiel pour progresser en algorithmique et en programmation.\nLe concept de récursivité # La récursivité est un concept de programmation qui remonte aux premières années des langages de programmation (avec LISP et Algol'60). Il s'agit de faire un appel à la méthode/fonction dans la propre portée d'une méthode. Donc d'appeler, par exemple, la méthode calcul à l'intérieur même de la fonction calcul. En quelque sorte, la récursivité peut permettre de remplacer ou imiter des algorithmes itératifs, en faisant un nombre fini d'itérations sur une portion de code. La suite de Fibonacci est une suite mathématique célèbre dans laquelle chaque terme est la somme des deux termes précédents. Elle commence généralement par 0 et 1, puis se poursuit ainsi : 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \u0026hellip; Cette suite apparaît dans de nombreux domaines des mathématiques, de l’informatique et même de la nature (croissance des plantes, spirales, etc.\nEn programmation, le calcul des nombres de Fibonacci est un exemple classique pour illustrer la récursivité. La version récursive du calcul est élégante.\npublic class ExempleRecursivite { public static void main(String[] args) { int nb = fibonacci(10); System.out.println(\u0026#34;nb = \u0026#34; + nb); } public static int fibonacci(int n) { if(n \u0026lt;= 1) { return n; } else { return fibonacci(n - 1) + fibonacci(n - 2); } } } Malheureusement, cette fonction est inefficace pour de grandes valeurs de n, car elle recalcule plusieurs fois les mêmes valeurs, ce qui entraîne une explosion du nombre d’appels récursifs et peut provoquer un dépassement de pile. Par exemple, calculer le 40e ou le 100e nombre de Fibonacci de façon récursive est très lent et peut faire planter le programme.\npublic class ExempleRecursivite { public static void main(String[] args) { int nb = fibonacci(100); System.out.println(\u0026#34;nb = \u0026#34; + nb); } public static int fibonacci(int n) { if(n \u0026lt;= 1) { return n; } else { return fibonacci(n - 1) + fibonacci(n - 2); } } } Lorsque Java appelle une fonction, celle-ci dispose d\u0026rsquo;une certaine quantité de mémoire appelée pile (ou stack en anglais). La pile est une zone de la mémoire utilisée pour stocker les variables locales, les paramètres de la fonction et les informations nécessaires pour revenir à l’appelant une fois la fonction terminée. À chaque nouvel appel de fonction (y compris les appels récursifs), une nouvelle « trame d’activation » (ou frame) est ajoutée au sommet de la pile.\nLorsque la fonction se termine, sa trame d’activation est retirée de la pile et la mémoire correspondante est libérée. Si les appels de fonction s’enchaînent trop profondément (par exemple, dans une récursion mal contrôlée), la pile peut se remplir complètement, ce qui provoque une erreur appelée StackOverflowError. C’est pourquoi il est important de bien maîtriser la récursivité et de s’assurer que chaque fonction récursive possède un cas d’arrêt (ou condition de terminaison) pour éviter une croissance infinie de la pile.\nPour pallier ce problème, on privilégie une version itérative, qui utilise une simple boucle et deux variables pour mémoriser les deux derniers résultats. Cette approche est beaucoup plus efficace et permet de calculer rapidement des valeurs élevées de la suite de Fibonacci sans risque de débordement de pile. Dans l\u0026rsquo;exemple suivant, modifiez le nombre de Fibonacci calculé.\nExempleRecursivite.java public class ExempleRecursivite { public static void main(String[] args) { long nb = fibonacci(10); System.out.println(\u0026#34;nb = \u0026#34; \u0026#43; nb); } public static long fibonacci(int n) { if (n \u0026lt;= 1) { return n; } long prev = 0; long current = 1; long result = 0; for (int i = 2; i \u0026lt;= n; i\u0026#43;\u0026#43;) { result = prev \u0026#43; current; prev = current; current = result; } return result; } } Exécuter Cependant, il faut aussi faire attention au type de variable utilisé (int, long, BigInteger) pour éviter les débordements lors du calcul de grands nombres.\nLa récursivité demeure utile par son élégance et sa simplicité. Prenons cet exemple où on trouve le plus grand diviseur commun de deux entiers, basée sur l\u0026rsquo;algorithme d\u0026rsquo;Euclide.\nL’algorithme d’Euclide est une méthode ancienne et très efficace pour calculer le plus grand commun diviseur (PGCD) de deux entiers. Le principe repose sur l’observation suivante : le PGCD de deux nombres \\( a \\) et \\( b \\) (avec \\( a \\geq b \\)) est le même que le PGCD de \\( b \\) et du reste de la division de \\( a \\) par \\( b \\), soit \\( a \\bmod b \\). On répète ce processus jusqu’à ce que le reste soit nul ; à ce moment, le PGCD est le dernier diviseur non nul. Cette approche permet de réduire rapidement la taille des nombres à chaque étape, ce qui rend l’algorithme très performant, même pour de grands entiers.\nEn Java, l’algorithme d’Euclide s’exprime naturellement de façon récursive : si le second nombre (\\( q \\)) est nul, on retourne le premier (\\( p \\)) ; sinon, on rappelle la fonction avec les arguments \\( (q, p \\bmod q) \\). Cette simplicité et cette efficacité expliquent pourquoi l’algorithme d’Euclide est encore largement utilisé aujourd’hui, aussi bien dans les calculs mathématiques que dans des applications pratiques comme la cryptographie ou la simplification de fractions.\nExempleRecursivite.java public class ExempleRecursivite { public static void main(String[] args) { System.out.println(\u0026#34;Plus grand diviseur commun :\u0026#34; \u0026#43; plusGrandCommunDiviseur(455,322) ); } public static int plusGrandCommunDiviseur(int p, int q) { if (q == 0) { return p; } else { return plusGrandCommunDiviseur(q, p % q); } } } Exécuter Lecture optionnelle dans le livre de référence (Delannoy) # Pour aller plus en profondeur sur la récursivité (optionnel), vous pouvez lire dans Programmer en Java de Claude Delannoy, Chapitre 6:\nSection 10 : La récursivité des méthodes Vidéos # "},{"id":48,"href":"/inf1220-hugo/docs/modules/module1/difficile/","title":"Les problèmes difficiles","section":"Module 1: Algorithme et pseudocode","content":" Les problèmes difficiles # Dans un cours d’introduction à la programmation, la plupart des exercices se concentrent sur des problèmes dont les algorithmes sont relativement simples à concevoir, surtout si vous maîtrisez les bases de la programmation et des mathématiques. Ces problèmes, comme calculer une moyenne ou trier une liste, demandent souvent une compréhension des structures de contrôle (conditions et boucles) et une application directe de concepts logiques. Cependant, dans des contextes plus avancés, certains problèmes se révèlent bien plus complexes, non pas à cause de la programmation elle-même, mais en raison de la difficulté à trouver un algorithme efficace. Ces défis, qualifiés de « problèmes difficiles », nécessitent des approches créatives et parfois des compromis, car leurs solutions idéales peuvent être hors de portée avec les ressources informatiques actuelles.\nLes problèmes difficiles se rencontrent fréquemment dans des domaines comme l’intelligence artificielle, l’optimisation ou la cryptographie. Par exemple, développer une intelligence artificielle capable de rivaliser avec un grand maître aux échecs exige non seulement de programmer des règles du jeu, mais aussi de concevoir un algorithme capable d’évaluer des millions de positions possibles en un temps raisonnable. Ce type de problème est complexe, car il combine une exploration stratégique (choisir les meilleurs coups) avec des contraintes de performance (limiter le temps de calcul). De même, des problèmes d’optimisation, comme déterminer le chemin le plus court pour un livreur effectuant plusieurs arrêts, peuvent sembler simples en théorie, mais deviennent rapidement ingérables à mesure que le nombre de destinations augmente, en raison du nombre exponentiel de combinaisons possibles.\nUn exemple classique de problème difficile est le problème du voyageur de commerce (TSP, pour Traveling Salesman Problem). Ce problème consiste à trouver le chemin le plus court permettant à un voyageur de visiter une liste de villes exactement une fois avant de revenir à son point de départ. Pour un petit nombre de villes, il est possible d’énumérer toutes les permutations et de calculer la distance totale de chaque trajet. Cependant, avec seulement 20 villes, le nombre de trajets possibles dépasse les milliards, rendant une approche par force brute (tester toutes les combinaisons) impraticable, même sur des ordinateurs puissants. Ce problème est dit « NP-difficile », un terme technique que les informaticiens utilisent pour désigner un problème qu\u0026rsquo;il est difficile de résoudre rapidement en général.\nPour aborder le problème du voyageur de commerce, des algorithmes approchés, comme l’algorithme du plus proche voisin, sont souvent utilisés. Cet algorithme commence par une ville arbitraire, puis choisit à chaque étape la ville la plus proche non visitée, jusqu’à ce que toutes les villes soient incluses, avant de revenir à la ville de départ. Bien que cette méthode ne garantisse pas toujours le chemin le plus court, elle produit une solution acceptable dans un temps de calcul bien plus court que l’énumération complète. Voici un pseudocode pour cet algorithme :\nEntrées : Liste de villes : villes[n] Matrice des distances : distances[n][n] Sorties : Liste ordonnée des villes : trajet Initialiser trajet comme une liste vide Choisir une ville de départ (par exemple, villes[0]) et l’ajouter à trajet Marquer la ville de départ comme visitée TANT QUE toutes les villes ne sont pas visitées FAIRE Trouver la ville non visitée la plus proche de la dernière ville dans trajet Ajouter cette ville à trajet Marquer cette ville comme visitée FIN TANT QUE Ajouter la ville de départ à la fin de trajet pour boucler RETOURNER trajet Ce pseudocode décrit une solution gloutonne au problème du voyageur de commerce (TSP), qui cherche un circuit visitant chaque ville d’une liste exactement une fois et revenant à la ville de départ, en minimisant la distance totale. Les entrées sont une liste de n villes (villes[n]) et une matrice distances[n][n] indiquant les distances entre chaque paire de villes. Une liste trajet est initialisée vide pour stocker l’ordre des villes. L’algorithme commence par choisir une ville de départ (par exemple, villes[0]), l’ajoute à trajet, et la marque comme visitée. Une boucle (TANT QUE toutes les villes ne sont pas visitées FAIRE) sélectionne à chaque étape la ville non visitée la plus proche de la dernière ville ajoutée à trajet, en consultant la matrice distances. Cette ville est ajoutée à trajet et marquée comme visitée. Une fois toutes les villes visitées, la ville de départ est ajoutée à la fin de trajet pour former un circuit fermé. La liste trajet est retournée comme résultat.\nConsidérons une table (fictive) des distances entre certains villes du Québec.\nVille Montréal Québec Laval Gatineau Longueuil Montréal - 250 20 200 15 Québec 250 - 240 450 245 Laval 20 240 - 210 30 Gatineau 200 450 210 - 210 Longueuil 15 245 30 210 - Vous pouvez vérifier que le trajet suivant représente 910 km.\nMontréal -\u0026gt; Gatineau -\u0026gt; Laval -\u0026gt; Québec -\u0026gt; Longueuil -\u0026gt; Montréal\nMaintenant, exécutez l\u0026rsquo;algorithme du plus proche voisin avec l\u0026rsquo;application suivante :\nProblème du voyageur de commerce (TSP) Pseudocode (Approche du plus proche voisin) Entrées : Liste de villes : villes[n] Matrice des distances : distances[n][n] Sorties : Liste ordonnée des villes : trajet Initialiser trajet comme une liste vide Choisir une ville de départ aléatoire et l’ajouter à trajet Marquer la ville de départ comme visitée TANT QUE toutes les villes ne sont pas visitées FAIRE Trouver la ville non visitée la plus proche de la dernière ville dans trajet Ajouter cette ville à trajet Marquer cette ville comme visitée FIN TANT QUE Ajouter la ville de départ à la fin de trajet pour boucler RETOURNER trajet, Distance totale Tableau des distances (km) Ville Montréal Québec Laval Gatineau Longueuil Montréal - 250 20 200 15 Québec 250 - 240 450 245 Laval 20 240 - 210 30 Gatineau 200 450 210 - 210 Longueuil 15 245 30 210 - Commencer Réinitialiser État actuel Cliquez sur 'Commencer' pour commencer l'initialisation.\nÉtape : 0\nTrajet actuel : Distance totale parcourue : 0 km\nPouvez-vous obtenir une distance aussi courte que 910 km ;? Comment pourriez-vous modifier le pseudocode pour obtenir toujours la distance la plus courte ? C\u0026rsquo;est une question difficile.\nCet exemple d\u0026rsquo;algorithme est un algorithme glouton. Un algorithme glouton est une méthode algorithmique qui résout un problème en faisant à chaque étape le choix localement optimal, dans l’espoir que ces choix mènent à une solution globale optimale. Il privilégie la simplicité et la rapidité, mais ne garantit pas toujours la meilleure solution pour tous les problèmes, car il ne revient jamais en arrière pour réévaluer les décisions prises. Ce type d’algorithme est souvent utilisé pour des problèmes d’optimisation où une solution approximative est acceptable ou lorsque le problème possède une structure particulière, comme la propriété de sous-structure optimale ou la propriété gloutonne.\nConsidérons d\u0026rsquo;autres exemples de l\u0026rsquo;approche gloutonne.\nSuppose que nous disposions d’un sac à dos de capacité limitée et d’objets ayant chacun un poids et une valeur. L’objectif est de maximiser la valeur totale des objets dans le sac, en autorisant des fractions d’objets. L\u0026rsquo;approche gloutonne dans ce cas consiste à d\u0026rsquo;abord trier les objets par rapport décroissant de leur rapport valeur/poids. Ensuite, il faut remplir le sac en prenant autant que possible de chaque objet dans cet ordre jusqu’à atteindre la capacité. Suppose que nous disposions d’un ensemble d’activités avec des heures de début et de fin, et l’objectif est de sélectionner le plus grand nombre d’activités compatibles (qui ne se chevauchent pas). Une approche gloutonne consiste à trier les activités par heure de fin croissante. Sélectionner la première activité, puis la prochaine activité compatible, et ainsi de suite. Les approches gloutonnes donnent généralement une solution qui n\u0026rsquo;est pas optimale.\nDans le cadre de ce cours, vous ne serez pas confronté à des problèmes aussi complexes que le voyageur de commerce. Les exercices proposés viseront à renforcer votre compréhension des bases algorithmiques, comme les boucles, les conditions et la manipulation de données simples. Cependant, il est utile de connaître l’existence de ces problèmes difficiles pour apprécier la profondeur de l’informatique. Ils illustrent l’importance de l’efficacité algorithmique et des compromis dans la conception de solutions. En explorant des cas plus simples, vous poserez les fondations nécessaires pour, un jour, peut-être, relever ces défis plus ardus.\n"},{"id":49,"href":"/inf1220-hugo/docs/modules/module2/travail-note-2/","title":"Travail noté 2","section":"Module 2: Introduction au langage Java","content":" Travail noté 2 - Les types, opérateurs et méthodes # Avant de commencer le travail noté, il est essentiel de maîtriser la matière en ayant complété toutes les lectures et exercices préparatoires, et de poser des questions si nécessaire. L’utilisation du robot conversationnel du cours est autorisée pour les travaux notés, mais les réponses et analyses doivent être personnelles. Les travaux doivent être soumis avant la date de fin de cours, inscrite dans le portail étudiant, sans possibilité de report, sauf en cas de situation exceptionnelle validée par l’Université. Toute soumission tardive peut entraîner une note de zéro ou un « incomplet », même si l’examen a lieu plus tard.\nLes travaux doivent être remis sous forme de fichier PDF via l’outil de dépôt officiel de la TÉLUQ, sans envoi par courriel, sous peine de note zéro. Le document doit être clair, lisible, permettre le copier-coller du code, et inclure des explications détaillées en français sous forme de texte suivi, en évitant les saisies d’écran ou les travaux manuscrits. Les réponses doivent être précises, personnelles, et accompagnées d’analyses, sans se limiter à du code ou à des extraits recopiés. Une fois soumis, le travail ne peut être modifié, d’où l’importance de le relire attentivement.\nLes travaux sont strictement individuels, et tout échange, notamment sur les réseaux sociaux, est considéré comme une faute académique pouvant mener à une note de zéro ou à une exclusion. La recherche sur le web est encouragée, mais aucun indice supplémentaire ne sera fourni au-delà de l’énoncé. La présentation, l’analyse et la clarté des explications sont prioritaires lors de la correction, qui valorise le raisonnement et la qualité du texte en français, plus que le code seul.\nQuestion #1 # Veuillez créer une classe et ses méthodes permettant de calculer le périmètre d'un cercle et l'aire de la surface délimitée par le cercle. Vous devez avoir 3 méthodes : 1 constructeur recevant un rayon, la méthode de calcul de l'aire et la méthode de calcul du périmètre. La classe doit se nommer Cercle.\nOn devrait pouvoir utiliser votre classe comme ceci : Cercle c = new Cercle(1); System.out.println(c.aire()); System.out.println(c.perimetre()); Le nom des méthodes aire et perimetre peut être différent si vous le souhaitez.\nVous devez expliquer votre solution en détail, une solution insuffisamment expliquée pourra recevoir la note de zéro. Tous les qualifiants que vous utilisez (static, protected, private, public) doivent être justifiés: vous ne pouvez pas utiliser le mot-clé « static » sans le justifier. Les explications sont obligatoires. Toutes les fonctions et variables doivent être justifiées et expliquées. Prenez la peine de bien présenter votre code et de l'expliquer. Prenez le temps de réfléchir à ce qui se produit si un programmeur utilise un rayon de zéro ou un rayon négatif et expliquez comment votre code va se comporter dans de tels cas. Vous pouvez expliquer votre code comme vous le souhaitez, tant que vous êtes clair. Vous n'êtes pas obligé de mettre systématiquement des commentaires dans le code. Utilisez votre bon jugement afin de produire du code clair et facile à lire. Note: Il ne faut pas nous écrire pour nous demander d'expliquer ce que nous voulons dire par « expliquer ». Si le code de votre solution n'est pas du Java valable, s'il ne compile pas, une note de zéro pourra être attribuée. Pour réussir ce cours, vous devez être capable d'écrire du code Java fonctionnel et correct.\nVotre classe n'a pas à inclure une méthode intitulée main. La méthode main est requise pour l'exécution d'un programme, mais n'est pas requise pour la compilation d'une classe. Toutes les classes Java doivent pouvoir compiler sans erreur, mais dans un projet logiciel, il peut n'y avoir qu'une seule fonction main (ou même aucune) et des milliers de classes. Votre code doit contenir un constructeur. Un constructeur en Java est une fonction qui a le nom de la classe. Dans ce cas, puisque votre classe se nomme Cercle, le constructeur doit prendre le nom Cercle. À part la méthode main que vous pouvez omettre, votre code ne devrait pas avoir besoin du mot-clé static. Attention: Vous devez remettre votre travail sous la forme d'un document PDF, et non comme un ensemble de fichiers Java. Pour faciliter la correction, assurez-vous qu'on puisse copier-coller du texte à partir du document PDF. N'utilisez pas des saisies d'écran.\nVidéo suggérée concernant le calcul de l'aire et du périmètre.\nVidéo suggérée concernant les classes et méthodes.\nIndice. Rendez-vous sur la page du robot conversationnel du cours et saisissez l'énoncé dans la boîte de saisie: « Veuillez créer une classe et ses méthodes permettant de calculer le périmètre d'un cercle et l'aire de la surface délimitée par le cercle. Vous devez avoir 3 méthodes : 1 constructeur recevant un rayon, la méthode de calcul de l'aire et la méthode de calcul du périmètre. La classe doit se nommer Cercle. ».\nMettre en forme votre code Java # Certains étudiants souhaitent publier leur code au sein de site web ou au sein de documents. Vous pouvez utiliser un site comme tohtml.com pour améliorer l'apparence de votre code Java. Certains éditeurs vous permettent aussi d'enjoliver votre code. Question #2 # Un programmeur souhaite représenter la valeur 10.000000000000001 en Java. Il a écrit le programme suivant. Exécutez le programme et expliquez le résultat. Une explication de deux lignes peut suffire.\nMain.java class Main { public static void main(String[] args) { double x = 10.000000000000001; System.out.println(x); } } Exécuter Indice 1 : La lecture complète des notes de cours est obligatoire comme préparation aux travaux notés.\nIndice 2 : On vous invite à consulter l'article Wikipédia concernant la norme IEEE 754.\nIndice 3 : Essayez différentes valeurs pour voir ce qui se produit.\nQuestion #3 # Quelle sera la valeur de 'a' après les lignes de code suivantes et pourquoi :\nint i = 3; int a = i++; Question #4 # Quelle sera la valeur (de la variable chaine) affichée par la ligne System.out.println(chaine) du code ci-dessous et pourquoi ? Donner une réponse concise en quelques phrases.\npublic class TestMethode { public static void test(String test) { test = test+test; } public static void main(String[] args) { String chaine =\u0026#34;test\u0026#34;; test(chaine); System.out.println(chaine); } } Question #5 # Quelle sera la valeur de la variable entier à la fin du code suivant et pourquoi ?\nboolean a = false; boolean b = false; int entier = (!a \u0026amp;\u0026amp; (b | !a)) ? 10 : 20; Indice: Assurez-vous de bien lire sur les opérateurs en Java avant de faire cette question.\nQuestion #6 # Expliquez en détail la différence entre les deux mises en oeuvre suivantes. Votre explication doit inclure un exemple de code illustrant la différence entre les deux morceaux de code.\nPremier code:\npublic class Bonhomme { public static String nom; public Bonhomme(String n) { nom = n; } } Second code:\npublic class Bonhomme { public String nom; public Bonhomme(String n) { nom = n; } } En terminant # Dans plusieurs cas, vos travaux sont corrigés par un « correcteur ». Il est possible que vous puissiez identifier cette personne en examinant le document de rétroaction que vous recevez au sein du portail étudiant. Vous ne devriez jamais joindre cette personne. Cette personne n'a pas comme mandat de répondre à vos questions suite à la correction. Vos courriels seront ignorés. Il faut plutôt joindre la personne qui vous encadre au sein du cours.\n"},{"id":50,"href":"/inf1220-hugo/docs/modules/module1/complex/","title":"Complexité algorithmique","section":"Module 1: Algorithme et pseudocode","content":" Complexité algorithmique # La plupart des problèmes ne sont pas fondamentalement difficiles, mais toutes les solutions ne sont pas également efficaces. La complexité algorithmique fournit une mesure de cette efficacité.\nLa complexité algorithmique mesure le temps ou la mémoire qu’un algorithme nécessite en fonction de la taille de l’entrée (souvent notée \\( n \\)). Pour comparer les algorithmes, on utilise la notation grand-O (ou O-grande), qui donne un ordre de grandeur du nombre d’opérations à effectuer lorsque la taille des données augmente.\nComprendre la complexité algorithmique permet de choisir ou d’inventer des solutions efficaces, surtout pour de grandes quantités de données. Il est souvent utile de commencer par une solution simple (même lente), puis de chercher à l’optimiser en utilisant des structures de données ou des propriétés mathématiques adaptées.\nDans ce cours, vous n\u0026rsquo;avez pas à maîtriser la notation grand-O et la complexité algorithmique. Néanmoins, il est utile d\u0026rsquo;être familier avec les principales notions.\nNotation grand-O # La notation \\( O(f(n)) \\) signifie que, pour des entrées de taille \\( n \\), l’algorithme effectue au plus un nombre d’opérations proportionnel à \\( f(n) \\) (à une constante près). On ne s’intéresse qu’au comportement pour de grandes valeurs de \\( n \\), et on ignore les détails d’implémentation ou les constantes cachées.\nOn considère souvent que l\u0026rsquo;accès à un élément d\u0026rsquo;un tableau par son index a une complexité \\( O(1) \\) puisqu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;une seul opération. Les operations arithmétique (+, -, etc.) ont aussi une complexité \\( O(1) \\).\nExemples d’algorithmes en \\( O(n) \\) # Un algorithme est en \\( O(n) \\) si le nombre d’opérations croît linéairement avec la taille de l’entrée. Par exemple, parcourir un tableau pour calculer la somme de ses éléments :\nsomme = 0 POUR i de 0 à n-1 somme = somme + tableau[i] FIN POUR Une variable somme est initialisée à 0 pour accumuler le résultat. La boucle (POUR i de 0 à n-1) parcourt chaque indice i du tableau, et à chaque itération, la valeur de l’élément tableau[i] est ajoutée à somme (somme = somme + tableau[i]). À la fin de la boucle, somme contient la somme totale des éléments du tableau.\nIci, chaque élément est visité une seule fois, donc le temps d’exécution est proportionnel à \\( n \\).\nExemples d’algorithmes en \\( O(n^2) \\) # Un algorithme est en \\( O(n^2) \\) si le nombre d’opérations croît comme le carré de la taille de l’entrée. C’est typique des algorithmes qui utilisent deux boucles imbriquées, comme la recherche de toutes les paires d’éléments dans un tableau :\nPOUR i de 0 à n-1 POUR j de 0 à n-1 faire quelque chose avec tableau[i] et tableau[j] FIN POUR FIN POUR Ce pseudocode décrit une double boucle imbriquée qui parcourt toutes les paires possibles d’éléments dans un tableau de taille n. La boucle externe (POUR i de 0 à n-1) itère sur chaque indice i du tableau, tandis que la boucle interne (POUR j de 0 à n-1) parcourt à nouveau tous les indices j du tableau, indépendamment de i. À chaque itération, une opération (désignée par « faire quelque chose ») est effectuée en utilisant les éléments tableau[i] et tableau[j]. Cela inclut les cas où i et j désignent le même élément (quand i = j) ainsi que toutes les combinaisons de paires, y compris les permutations (par exemple, (i,j) et (j,i)).\nIci, pour chaque valeur de \\( i \\), on parcourt toutes les valeurs de \\( j \\), ce qui donne \\( n \\times n = n^2 \\) opérations.\nUn algorithme \\( O(n^2) \\) est plus lent qu\u0026rsquo;un algorithme \\( O(n) \\) quand \\( n \\) est très grand.\nRecherche dans un tableau trié # Lorsqu’un tableau est trié, on peut utiliser la recherche dichotomique (ou recherche binaire) pour trouver rapidement un élément. Cette méthode consiste à comparer la valeur recherchée à l’élément du milieu du tableau : si la valeur est plus petite, on recommence la recherche dans la moitié gauche ; sinon, dans la moitié droite. On répète jusqu’à trouver l’élément ou à épuiser le tableau.\nVoici un exemple de pseudocode pour la recherche binaire :\nDEBUT debut ← 0 fin ← n - 1 TANT QUE debut ≤ fin milieu ← (debut + fin) // 2 SI tableau[milieu] == valeur retourner VRAI SINON SI tableau[milieu] \u0026lt; valeur debut ← milieu + 1 SINON fin ← milieu - 1 FIN SI FIN TANT QUE retourner FAUX FIN Le pseudocode décrit ce processus : on initialise deux indices, debut (0) et fin (n-1), délimitant la partie du tableau à explorer. À chaque itération, on calcule l’indice milieu (moyenne de debut et fin) et compare l’élément à cet indice (tableau[milieu]) avec la valeur recherchée. Si les deux sont égaux, l’élément est trouvé (retourner VRAI). Si la valeur est plus grande, la recherche se poursuit dans la moitié droite en ajustant debut à milieu + 1 ; sinon, dans la moitié gauche en ajustant fin à milieu - 1. Le processus se répète tant que debut ≤ fin. Si l’intervalle est épuisé sans trouver la valeur, l’algorithme retourne FAUX, indiquant que l’élément n’est pas dans le tableau.\nPour mieux comprendre l\u0026rsquo;algorithme, essayez de chercher des nombres dans un tableau trié avec l\u0026rsquo;application suivante.\nRechercher Entrez un nombre et cliquez sur \"Rechercher\" pour voir les étapes de la recherche binaire.\nObservez comment vous faites toujours moins de recherche qu\u0026rsquo;il y a d\u0026rsquo;éléments dans le tableau. Pouvez-vous faire en sorte qu\u0026rsquo;une seule étape soit nécessaire ? Quel est le nombre maximal d\u0026rsquo;étapes nécessaires ?\nCet algorithme a une complexité en \\( O(\\log n) \\), ce qui le rend très efficace pour les grands tableaux triés.\nCela signifie que le nombre d’opérations nécessaires pour trouver (ou ne pas trouver) un élément ne croît pas proportionnellement à la taille du tableau, mais beaucoup plus lentement. Par exemple, pour un tableau de 1 000 000 d’éléments, la recherche binaire nécessite au maximum environ 20 comparaisons (car \\( \\log_2 1\\,000\\,000 \\approx 20 \\)), alors qu’une recherche linéaire pourrait en demander jusqu’à 1 000 000 dans le pire cas. Plus le tableau est grand, plus l’avantage de la recherche binaire est important.\nÀ chaque étape de la recherche binaire, on divise le nombre d’éléments restants par deux. Si on commence avec \\( n \\) éléments, après une comparaison il en reste \\( n/2 \\), puis \\( n/4 \\), puis \\( n/8 \\), etc. On répète ce processus jusqu’à ce qu’il ne reste qu’un seul élément à examiner.\nOn cherche donc le nombre d’étapes \\( k \\) tel que : \\[ \\frac{n}{2^k} = 1 \\] En résolvant pour \\( k \\) : \\[ n = 2^k \\implies k = \\log_2 n \\]Ainsi, le nombre maximal de comparaisons est proportionnel à \\( \\log_2 n \\). C’est pourquoi on dit que la recherche binaire a une complexité en \\( O(\\log n) \\).\nTri # Le tri consiste à réorganiser les éléments d’un tableau ou d’une liste selon un ordre donné (par exemple, croissant). Un algorithme de tri naïf, comme le tri à bulles (bubble sort) ou le tri par insertion, compare chaque élément à tous les autres et échange leur position si nécessaire. Ces algorithmes effectuent environ \\( n^2 \\) comparaisons pour un tableau de taille \\( n \\), ce qui leur donne une complexité en \\( O(n^2) \\). Cela devient très lent dès que le nombre d’éléments augmente.\nPseudocode du tri à bulle:\nPOUR i de 0 à n-2 POUR j de 0 à n-2-i SI tableau[j] \u0026gt; tableau[j+1] ALORS échanger tableau[j] et tableau[j+1] FIN SI FIN POUR FIN POUR Le tri à bulle est un algorithme de tri simple qui parcourt un tableau de manière répétée pour comparer et échanger les éléments adjacents s’ils sont dans le mauvais ordre. Dans le pseudocode présenté, la boucle externe (i de 0 à n-2) contrôle le nombre de passes sur le tableau, chaque passe garantissant que l’élément le plus grand non encore trié est placé à la fin. La boucle interne (j de 0 à n-2-i) compare chaque paire d’éléments consécutifs (tableau[j] et tableau[j+1]) et les échange s’ils sont mal ordonnés (tableau[j] \u0026gt; tableau[j+1]). À chaque itération, les éléments les plus grands \u0026ldquo;remontent\u0026rdquo; comme des bulles vers la fin du tableau, d’où le nom de l’algorithme.\nUtilisez cette application pour mieux comprendre le tri à bulle. Lancer le tri Réinitialiser Un autre algorithme simple est le tri par insertion. Il parcourt le tableau élément par élément, insérant chaque nouvel élément à sa place dans la partie déjà triée.\nPOUR i de 1 à n-1 clé ← tableau[i] j ← i - 1 TANT QUE j ≥ 0 ET tableau[j] \u0026gt; clé tableau[j+1] ← tableau[j] j ← j - 1 FIN TANT QUE tableau[j+1] ← clé FIN POUR Le tri par insertion est un algorithme de tri qui construit progressivement une partie triée du tableau en insérant chaque élément à sa position correcte. Dans le pseudocode fourni, la boucle externe (i de 1 à n-1) sélectionne chaque élément (clé ← tableau[i]) à partir du deuxième élément. La boucle interne compare cette clé avec les éléments de la partie déjà triée (de j ← i-1 jusqu’à 0), en déplaçant les éléments plus grands que la clé d’une position vers la droite (tableau[j+1] ← tableau[j]) tant que tableau[j] \u0026gt; clé et j ≥ 0. Une fois la bonne position trouvée, la clé est insérée (tableau[j+1] ← clé). Ce processus répété garantit que, à chaque étape, la sous-partie du tableau jusqu’à l’indice i est triée, aboutissant à un tableau entièrement trié à la fin.\nUtilisez cette application pour mieux comprendre le tri par insertion.\nLancer le tri Réinitialiser Heureusement, il existe des algorithmes de tri plus efficaces. Par exemple, le tri fusion (merge sort) utilise une approche « diviser pour régner » : il divise le tableau en deux moitiés, trie chaque moitié récursivement, puis fusionne les deux moitiés triées en un seul tableau trié. Cette méthode réduit considérablement le nombre de comparaisons nécessaires et atteint une complexité en \\( O(n \\log n) \\).\nIdée générale du trie fusion :\nSi le tableau contient 0 ou 1 élément, il est déjà trié. Sinon, on divise le tableau en deux parties de taille à peu près égale. On trie récursivement chaque partie. On fusionne les deux parties triées pour obtenir un tableau final trié. Pseudocode du tri fusion:\nFONCTION triFusion(tableau) SI taille(tableau) ≤ 1 ALORS retourner tableau FIN SI milieu ← taille(tableau) // 2 gauche ← triFusion(tableau[0 .. milieu-1]) droite ← triFusion(tableau[milieu .. fin]) retourner fusionner(gauche, droite) FIN FONCTION FONCTION fusionner(gauche, droite) résultat ← tableau vide TANT QUE gauche et droite ne sont pas vides SI gauche[0] ≤ droite[0] ALORS ajouter gauche[0] à résultat retirer gauche[0] de gauche SINON ajouter droite[0] à résultat retirer droite[0] de droite FIN SI FIN TANT QUE ajouter le reste de gauche (s’il en reste) à résultat ajouter le reste de droite (s’il en reste) à résultat retourner résultat FIN FONCTION Le pseudocode décrit deux fonctions principales. La fonction triFusion divise récursivement le tableau en deux moitiés jusqu’à ce que chaque sous-tableau ait au plus un élément (déjà trié). Pour cela, elle calcule l’indice milieu, trie récursivement la moitié gauche (0 à milieu-1) et la moitié droite (milieu à fin), puis fusionne ces deux sous-tableaux triés. La fonction fusionner combine les sous-tableaux gauche et droite en un tableau trié : elle compare les premiers éléments de chaque sous-tableau, ajoute le plus petit à résultat, et retire cet élément de son sous-tableau d’origine. Ce processus continue jusqu’à ce qu’un des sous-tableaux soit vide, puis les éléments restants de l’autre sous-tableau sont ajoutés à résultat.\nLe tri fusion est donc beaucoup plus rapide que les tris naïfs pour les grands tableaux, et il illustre l’intérêt des algorithmes efficaces en informatique.\nUtilisez cette application pour mieux comprendre le tri fusion.\nLancer le tri Réinitialiser Un autre algorithme performant est le tri rapide (quick sort). Il choisit un élément pivot, partitionne le tableau en deux sous-tableaux (les éléments plus petits que le pivot et ceux plus grands), puis trie récursivement chaque sous-tableau. En moyenne, sa complexité est en \\( O(n \\log n) \\), bien qu’il puisse atteindre \\( O(n^2) \\) dans le pire cas (par exemple, si le tableau est déjà trié et que le pivot est mal choisi). Le choix du pivot est crucial : une stratégie courante est de sélectionner la médiane de trois valeurs ou un élément aléatoire.\nFONCTION triRapide(tableau, début, fin) SI début \u0026lt; fin ALORS pivot ← partitionner(tableau, début, fin) triRapide(tableau, début, pivot - 1) triRapide(tableau, pivot + 1, fin) FIN SI FIN FONCTION FONCTION partitionner(tableau, début, fin) pivot ← tableau[fin] i ← début - 1 POUR j de début à fin - 1 SI tableau[j] ≤ pivot ALORS i ← i + 1 échanger tableau[i] et tableau[j] FIN SI FIN POUR échanger tableau[i + 1] et tableau[fin] retourner i + 1 FIN FONCTION La fonction triRapide vérifie si l’intervalle à trier (de début à fin) contient plus d’un élément ; si oui, elle appelle partitionner pour réorganiser le tableau autour d’un pivot, puis trie récursivement les sous-tableaux à gauche (de début à pivot-1) et à droite (de pivot+1 à fin). La fonction partitionner sélectionne le dernier élément comme pivot (tableau[fin]) et réarrange le tableau de sorte que les éléments inférieurs ou égaux au pivot soient à gauche et les plus grands à droite. Elle utilise un indice i pour suivre la frontière des éléments plus petits et échange les éléments appropriés via un parcours (j de début à fin-1). Enfin, le pivot est placé à sa position finale (échange avec tableau[i+1]), et son indice (i+1) est retourné.\nUtilisez cette application pour mieux comprendre le tri rapide.\nStratégie de pivot : Médiane de trois Élément aléatoire Dernier élément Premier élément Lancer le tri Réinitialiser Le tri rapide est souvent le plus rapide en pratique pour plusieurs raisons. Premièrement, le tri rapide est efficace en termes de localité de mémoire. Il travaille directement sur le tableau (tri en place), ce qui minimise les accès mémoire et exploite bien la mémoire tampon des processeurs modernes. Comparé au tri fusion, qui nécessite un tableau auxiliaire pour la fusion, le tri rapide réduit les allocations de mémoire et les copies d’éléments. Deuxièmement, le tri rapide effectue moins de comparaisons en moyenne. Lors du partitionnement, il répartit les éléments autour d’un pivot, ce qui réduit rapidement la taille des sous-tableaux à trier. Si le pivot est bien choisi (par exemple, proche de la médiane), les sous-tableaux sont équilibrés, conduisant à une division efficace du problème. Même avec un choix de pivot aléatoire, les cas défavorables sont rares dans des données réelles. Troisièmement, le tri rapide est adaptable aux données. Dans des ensembles partiellement triés ou avec des motifs courants, il peut tirer parti de ces structures pour réduire le nombre d’échanges. Par exemple, un bon choix de pivot peut minimiser les réarrangements inutiles.\nUtilisez l\u0026rsquo;application suivante pour comparer les techniques de tri. Appuyez sur Lancer tous les tris et regardez les 4 algorithmes s\u0026rsquo;exécuter en même temps. Constatez que certains algorithmes sont plus rapides que d\u0026rsquo;autres. Que pensez-vous qu\u0026rsquo;il se passerait si nous avions moins d\u0026rsquo;éléments (par ex., 4) ou beaucoup plus d\u0026rsquo;éléments (par ex., 1000) ?\nLancer tous les tris Réinitialiser Stratégie de pivot (tri rapide) : Médiane de trois Élément aléatoire Dernier élément Premier élément Tri à bulles\nTri par insertion\nTri par fusion\nTri rapide\nLe Java utilise généralement Timsort. Timsort est un algorithme de tri hybride, conçu par Tim Peters. Il combine le tri par insertion et le tri fusion pour optimiser les performances sur des données réelles, en exploitant les séquences déjà triées, appelées runs. L’algorithme commence par diviser le tableau en petits runs, soit naturels (séquences croissantes ou décroissantes), soit créés en triant des blocs de taille minimale (souvent 32 éléments) avec le tri par insertion. Ces runs sont ensuite fusionnés deux à deux à l’aide d’une version optimisée du tri fusion, qui minimise les comparaisons et les copies. Sa complexité est en \\( O(n \\log n) \\) dans le pire cas, mais elle peut descendre à \\( O(n) \\) pour des données presque triées, rendant Timsort particulièrement efficace en pratique. De plus, Timsort est stable, préservant l’ordre relatif des éléments égaux, ce qui est crucial dans certaines applications.\nDans certains cas spécialisés, nous utilisons l’algorithme de tri par niches, également connu sous le nom de pigeonhole sort, est un algorithme de tri non comparatif adapté aux ensembles de données où les éléments appartiennent à un ensemble fini de valeurs entières, comme des nombres dans une plage limitée. Il repose sur le principe des \u0026ldquo;niches\u0026rdquo; (ou pigeonholes) : chaque valeur possible est associée à une niche, et les éléments sont placés dans la niche correspondant à leur valeur. Ensuite, les niches sont parcourues dans l’ordre pour reconstruire le tableau trié. Sa complexité est en \\( O(n + k) \\), où \\( n \\) est le nombre d’éléments et \\( k \\) la taille de la plage de valeurs. Cet algorithme est très efficace lorsque \\( k \\) est proche de \\( n \\), mais il nécessite un espace auxiliaire proportionnel à \\( k \\) et n’est pas adapté aux données non entières ou à des plages de valeurs très grandes.\nFONCTION triParNiches(tableau, min, max) k ← max - min + 1 // Taille de la plage de valeurs niches ← tableau de taille k, initialisé à vide // Étape 1 : placer les éléments dans les niches POUR chaque élément dans tableau index ← élément - min ajouter élément à niches[index] FIN POUR // Étape 2 : reconstruire le tableau trié index ← 0 POUR i de 0 à k-1 TANT QUE niches[i] n’est pas vide tableau[index] ← premier élément de niches[i] retirer premier élément de niches[i] index ← index + 1 FIN TANT QUE FIN POUR retourner tableau FIN FONCTION Le tri par niches (ou bucket sort) est un algorithme de tri non comparatif adapté aux données uniformément réparties dans une plage de valeurs connue (de min à max). Le pseudocode décrit un processus en deux étapes. D’abord, il calcule la taille de la plage (k ← max - min + 1) et crée un tableau niches de taille k, où chaque niche correspond à une valeur possible. Dans l’étape 1, chaque élément du tableau est placé dans la niche correspondante (index ← élément - min), ce qui regroupe les éléments de même valeur. Dans l’étape 2, le tableau est reconstruit en parcourant les niches dans l’ordre (de 0 à k-1) et en extrayant leurs éléments pour les placer séquentiellement dans le tableau (tableau[index]). L’indice index suit la position d’insertion.\nTable de hachage # Une table de hachage (ou « hash table ») est une structure de données qui permet d’associer des clés à des valeurs et d’accéder très rapidement à une valeur à partir de sa clé. Le principe repose sur l’utilisation d’une fonction de hachage qui transforme la clé (par exemple, un texte ou un nombre) en un indice de tableau. Les opérations d’insertion, de recherche et de suppression se font en temps moyen \\( O(1) \\), c’est-à-dire en temps constant, quelle que soit la taille de la table (si la fonction de hachage est bonne et la table bien dimensionnée). La table de hachage est efficace pour retrouver rapidement une information à partir d’une clé.\nIdée générale :\nOn applique une fonction de hachage à la clé pour obtenir un indice. On stocke la valeur à cet indice dans un tableau. En cas de « collision » (deux clés différentes qui donnent le même indice), on utilise une technique de résolution (chaînage, sondage linéaire, etc.). Pseudocode d\u0026rsquo;une recherche dans une table de hachage (sans collision):\nFONCTION rechercher(table, clé) indice ← hachage(clé) SI table[indice] == clé ALORS retourner VRAI SINON retourner FAUX FIN SI FIN FONCTION Le pseudocode décrit une fonction de recherche dans une table de hachage, une structure de données optimisée pour retrouver rapidement un élément. La fonction rechercher prend une table (tableau représentant la table de hachage) et une clé à chercher (clé). Elle commence par calculer l’indice correspondant à la clé via une fonction de hachage (indice ← hachage(clé)), qui mappe la clé à une position dans la table. Ensuite, elle vérifie si l’élément à cet indice (table[indice]) est égal à la clé recherchée. Si c’est le cas, la fonction retourne VRAI, indiquant que la clé est présente. Sinon, elle retourne FAUX, signifiant que la clé est absente. Ce pseudocode suppose une table de hachage simple sans gestion des collisions (cas où plusieurs clés pointent vers le même indice), ce qui la rend efficace mais limitée aux cas où chaque indice contient au plus un élément.\nPour mieux comprendre, testez l\u0026rsquo;application suivante. Saisissez des chaînes de caractères qui seront ajoutées à la table de hachage. Pouvez-vous créer une collision ?\nAjouter Chaînes saisies Chaîne Valeur de hachage Position dans la table Table de hachage En Java, la classe HashMap que nous verrons plus loin dans le cours implémente une table de hachage. Par exemple :\nimport java.util.HashMap; HashMap\u0026lt;String, Integer\u0026gt; dico = new HashMap\u0026lt;\u0026gt;(); dico.put(\u0026#34;chat\u0026#34;, 1); dico.put(\u0026#34;chien\u0026#34;, 2); System.out.println(dico.get(\u0026#34;chat\u0026#34;)); // Affiche 1 Ce code Java utilise une HashMap pour créer une structure de données associant des clés à des valeurs. Une instance HashMap\u0026lt;String, Integer\u0026gt; est déclarée, avec des clés de type String et des valeurs de type Integer. Deux paires clé-valeur sont ajoutées via la méthode put : \u0026ldquo;chat\u0026rdquo; associé à 1 et \u0026ldquo;chien\u0026rdquo; à 2. La méthode get(\u0026ldquo;chat\u0026rdquo;) récupère la valeur liée à la clé \u0026ldquo;chat\u0026rdquo;, soit 1, qui est ensuite affichée avec System.out.println.\nLes tables de hachage sont omniprésentes en informatique car elles rendent possible la recherche rapide dans de grands ensembles de données.\nImaginons que l’on souhaite stocker un ensemble de chaînes de caractères de différentes longueurs, par exemple « chat », « chien », « girafe », « lion ». Pour retrouver rapidement une chaîne, on peut utiliser une table de hachage où la fonction de hachage choisie est simplement la longueur de la chaîne. Ainsi, « chat » (4 lettres) sera stocké à l’indice 4, « chien » (5 lettres) à l’indice 5, « girafe » (6 lettres) à l’indice 6, et ainsi de suite. Pour rechercher une chaîne, il suffit de calculer sa longueur et d’aller directement à l’indice correspondant dans le tableau. Cette opération ne dépend pas du nombre total de chaînes stockées, ce qui explique pourquoi la recherche est dite « en temps constant » : on ne parcourt pas toute la table, on accède directement à la bonne case.\nCependant, ce choix de fonction de hachage est très simple et peut provoquer des « collisions » : deux chaînes de même longueur, comme « lion » et « chat », auraient le même indice. Dans ce cas, il faut une méthode pour gérer ces collisions, par exemple en stockant les deux chaînes dans une liste à cet indice. En pratique, les tables de hachage utilisent des fonctions de hachage beaucoup plus sophistiquées, capables de transformer n’importe quelle clé (texte, nombre, etc.) en un indice réparti de façon plus uniforme dans le tableau. L’objectif reste toujours de minimiser les collisions, car tant qu’il y en a peu, la recherche, l’insertion et la suppression restent très rapides et efficaces, même avec de très grands ensembles de données.\nUn problème résoluble en \\( O(n^2) \\) ou en \\( O(n) \\) # Prenons le problème suivant : « Trouver s’il existe deux éléments dans un tableau qui, additionnés, donnent une valeur cible. »\nSolution naïve (\\( O(n^2) \\)) :\nPOUR i de 0 à n-1 POUR j de i+1 à n-1 SI tableau[i] + tableau[j] == cible retourner VRAI FIN SI FIN POUR FIN POUR retourner FAUX La boucle externe (POUR i de 0 à n-1) parcourt chaque élément du tableau, tandis que la boucle interne (POUR j de i+1 à n-1) examine tous les éléments suivants (à partir de i+1) pour éviter de considérer le même élément deux fois ou des paires redondantes. À chaque itération, la condition SI tableau[i] + tableau[j] == cible teste si la somme des éléments aux indices i et j égale la valeur cible. Si une telle paire est trouvée, la fonction retourne VRAI, indiquant que la solution existe. Si aucune paire ne satisfait la condition après avoir exploré toutes les combinaisons, la fonction retourne FAUX.\nIci, on teste toutes les paires possibles, ce qui prend un temps quadratique.\nSolution optimisée (\\( O(n) \\)) :\nOn peut résoudre ce problème en temps linéaire en utilisant une structure de données comme un ensemble (set) :\ninitialiser un ensemble vide POUR chaque élément x du tableau SI (cible - x) est dans l’ensemble retourner VRAI AJOUTER x à l’ensemble FIN POUR retourner FAUX Initialement, un ensemble vide est créé pour stocker les éléments rencontrés. La boucle (POUR chaque élément x du tableau) parcourt chaque élément x du tableau. Pour chaque x, l’algorithme vérifie si cible - x (la valeur nécessaire pour atteindre la somme cible) est déjà dans l’ensemble. Si c’est le cas, une paire d’éléments dont la somme vaut cible a été trouvée, et la fonction retourne VRAI. Sinon, l’élément x est ajouté à l’ensemble pour être utilisé dans les itérations suivantes. Si la boucle se termine sans trouver une telle paire, la fonction retourne FAUX.\nIci, chaque élément est traité une seule fois, et si la recherche dans l’ensemble se fait en temps constant (en moyenne) ou \\( O(1) \\), la solution est en \\( O(n) \\). Dans la solution optimisée, la vérification « (cible - x) est dans l’ensemble » est cruciale. Il n\u0026rsquo;est pas garanti que la recherche se fasse en temps \\( O(1) \\), mais c\u0026rsquo;est possible avec une table de hachage.\nAnalyse amortie # L’analyse amortie est une méthode utilisée pour évaluer la complexité moyenne d’une séquence d’opérations sur une structure de données, même si certaines opérations individuelles peuvent être coûteuses. Plutôt que de se concentrer sur le pire cas d’une seule opération, l’analyse amortie considère le coût total de nombreuses opérations et le répartit uniformément, offrant ainsi une vision plus réaliste de la performance globale. Le tri rapide (quick sort) est un algorithme qui a techniquement une complexité \\( O(n^2) \\), mais qui a une complexité amortie de \\( O(n \\log n) \\). En d\u0026rsquo;autres termes, le tri rapide est généralement rapide, mais il existe des cas rares où il est lent.\nVidéo optionnelle # "},{"id":51,"href":"/inf1220-hugo/docs/modules/module3/exercices-3-2/","title":"Exercices sur les exceptions et la récursivité","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" Exercices sur les exceptions et la récursivité # Questions/Réponses # Veuillez répondre mentalement, sur papier ou bien en créant le code nécessaire pour répondre à ces questions avant de regarder la réponse.\nQuand on vous demande de produire du code, vous devez le tester. C'est une erreur commune chez les étudiants: ils produisent rapidement du code en supposant qu'il est fonctionnel. Prenez le temps de vous relire, d'être attentif. Et testez votre code. Encore et encore.\nPrenez note qu'il est permis d'utiliser le robot conversationnel du cours lors des exercises. Cependant vous devriez vous entraîner à produire vos propres réponses.\nRéponses uniques? # Les exercices comportent une solution vous permettant de comparer votre approche avec la nôtre. Il n'y a pas de solution unique aux problèmes en général. Vous pouvez arriver avec une solution qui est préférable ou moins bonne que celle que nous offrons. Pour faire ces questions, vous devez avoir fait toutes les lectures préalables. Vous disposez alors toujours des fondements nécessaires pour faire les exercices. Nous vous encourageons tout de même à faire vos propres recherches en complément de vos lectures. Dans certains cas, au sein de la solution que nous offrons, nous pouvons utiliser des notions techniques qui n'ont pas été vues directement dans le cours, mais qui devraient vous être facilement accessibles.\nQuestion 1 # Expliquez ce qu\u0026rsquo;est la récursivité en Java. Donnez un exemple simple de fonction récursive qui calcule la factorielle d\u0026rsquo;un nombre.\nRéponse La récursivité est une technique où une fonction s'appelle elle-même pour résoudre un problème en le divisant en sous-problèmes plus simples. Exemple :\nint factorielle(int n) { if (n \u0026lt;= 1) return 1; else return n * factorielle(n - 1); } Question 2 # Qu\u0026rsquo;est-ce qu\u0026rsquo;une exception en Java ? Donnez un exemple de code qui attrape une exception lors d\u0026rsquo;une division par zéro.\nRéponse Une exception est un mécanisme qui permet de gérer les erreurs ou situations inattendues lors de l'exécution d'un programme. Exemple :\ntry { int x = 10 / 0; } catch (ArithmeticException e) { System.out.println(\u0026#34;Division par zéro !\u0026#34;); } Question 3 # Que se passera-t-il si vous placez l\u0026rsquo;instruction return dans le bloc « try » ou « catch » ? Le bloc « finally » s\u0026rsquo;exécutera-t-il ?\nRéponse Oui, le bloc finally s'exécutera toujours, même si un return est exécuté dans le bloc try ou catch. Exemple :\npublic int exemple() { try { return 1; } catch (Exception e) { return 2; } finally { System.out.println(\u0026#34;Bloc finally exécuté\u0026#34;); } } Le message du bloc finally sera affiché avant que la méthode ne retourne sa valeur.\nQuestion 4 # Écrivez une fonction récursive qui calcule la somme des éléments d\u0026rsquo;un tableau d\u0026rsquo;entiers.\nRéponse int somme(int[] t, int n) { if (n == 0) return 0; else return t[n-1] + somme(t, n-1); } // Appel : somme(t, t.length) Question 5 # Que se passe-t-il si une fonction récursive n\u0026rsquo;a pas de cas d\u0026rsquo;arrêt (condition d\u0026rsquo;arrêt) ?\nRéponse La fonction s'appellera elle-même indéfiniment, ce qui provoquera une erreur de type StackOverflowError (dépassement de pile) en Java.\nQuestion 6 # Quelles sont les différences entre les exceptions vérifiées (checked) et non vérifiées (unchecked) en Java ?\nRéponse Les exceptions vérifiées (checked) doivent être déclarées dans la signature de la méthode ou capturées avec un bloc try/catch. Elles héritent de Exception (sauf RuntimeException). Les exceptions non vérifiées (unchecked) héritent de RuntimeException et ne nécessitent pas d’être déclarées ni capturées explicitement.\nQuestion 7 # Que se passe-t-il si une exception n’est pas capturée dans un bloc try/catch ?\nRéponse Si une exception n’est pas capturée, elle remonte la pile d’appels jusqu’à ce qu’un bloc catch la capture. Si aucune méthode ne la capture, le programme se termine avec un message d’erreur (stack trace).\nQuestion 8 # Comment créer sa propre exception personnalisée en Java ?\nRéponse On crée une classe qui hérite de Exception (pour une exception vérifiée) ou de RuntimeException (pour une non vérifiée). Exemple :\nclass MonException extends Exception { public MonException(String message) { super(message); } } Question 9 # À quoi sert le mot-clé throw en Java ? Donnez un exemple d’utilisation.\nRéponse Le mot-clé throw permet de lancer explicitement une exception. Exemple :\nif (x \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;x doit être positif\u0026#34;); } Question 10 # Que se passe-t-il si on place plusieurs blocs catch à la suite d’un try ? Dans quel ordre sont-ils évalués ?\nRéponse Les blocs catch sont évalués dans l’ordre d’apparition. Le premier bloc dont le type correspond à l’exception levée sera exécuté ; les autres seront ignorés. Il faut placer les exceptions les plus spécifiques avant les plus générales.\nQuestion 11 # Qu’est-ce que le ramasse-miettes (garbage collector) en Java ? Quels sont ses avantages et ses inconvénients par rapport à la gestion manuelle de la mémoire ?\nRéponse Le ramasse-miettes (garbage collector) est un mécanisme automatique de la machine virtuelle Java (JVM) qui libère la mémoire occupée par les objets qui ne sont plus utilisés (inaccessibles). Il permet d’éviter les fuites de mémoire et les erreurs de libération (comme les doubles libérations en C), ce qui rend la gestion de la mémoire plus sûre et plus simple pour le programmeur.\nAvantages : simplifie la programmation, réduit les risques d’erreurs, améliore la robustesse et la sécurité des programmes.\nInconvénients : le développeur a moins de contrôle sur le moment précis où la mémoire est libérée, et le ramasse-miettes peut provoquer des pauses imprévisibles dans l’exécution du programme, ce qui peut être gênant pour les applications temps réel ou très sensibles aux performances.\nQuestion 12 # Comment peut-on limiter le surcoût du ramasse-miettes (garbage collector) dans une application Java ? Donnez quelques bonnes pratiques pour réduire son impact sur les performances.\nRéponse Pour limiter le surcoût du ramasse-miettes, il est conseillé de :\nRéduire la création d’objets temporaires inutiles (par exemple, réutiliser les objets ou utiliser des types primitifs quand c’est possible). Privilégier les structures de données adaptées à l’usage (par exemple, préférer StringBuilder à la concaténation répétée de String). Limiter la taille des objets et des collections pour éviter une consommation excessive de mémoire. Pour les applications critiques, ajuster les paramètres de la JVM (options de tuning du garbage collector) selon le profil d’utilisation. En appliquant ces bonnes pratiques, on réduit la pression sur le ramasse-miettes et on améliore la réactivité et la performance globale de l’application.\nQuestion 13 # Qu’est-ce que l’encodage UTF-16 et pourquoi Java l’utilise-t-il pour représenter les chaînes de caractères (String) ?\nRéponse L’UTF-16 est un encodage qui permet de représenter tous les caractères Unicode à l’aide de séquences de 16 bits (un ou deux char). Java utilise l’UTF-16 pour garantir la compatibilité avec l’ensemble des caractères internationaux, y compris les symboles, emojis et alphabets non latins. Cela permet de manipuler du texte multilingue de façon uniforme, mais implique que certains caractères occupent deux char au lieu d’un seul.\nQuestion 14 # Expliquez pourquoi la méthode charAt(int index) sur une String Java ne retourne pas toujours un caractère complet pour l’utilisateur. Donnez un exemple.\nRéponse En UTF-16, certains caractères Unicode (comme les emojis ou des symboles rares) sont codés sur deux char (une paire de substitution). La méthode charAt retourne un seul char à l’index donné, qui peut ne représenter qu’une partie d’un caractère complet. Par exemple :\nString s = \u0026#34;A😊B\u0026#34;; System.out.println(s.charAt(1)); // Retourne un char de la paire, pas le smiley complet Question 15 # Comment peut-on parcourir correctement tous les caractères Unicode d’une String en Java, même ceux codés sur deux char ?\nRéponse Pour parcourir tous les caractères Unicode (code points) d’une chaîne, il faut utiliser les méthodes codePoints() ou codePointAt() de la classe String, ou la classe Character. Par exemple :\nString s = \u0026#34;A😊B\u0026#34;; s.codePoints().forEach(cp -\u0026gt; System.out.println(Character.toChars(cp))); Cette approche permet de traiter chaque caractère Unicode comme une entité logique, même s’il est codé sur deux char.\nQuestion 16 # Combien de mémoire une String Java utilise-t-elle par caractère ? Cette valeur est-elle toujours la même pour tous les caractères ?\nRéponse En Java, chaque élément du tableau interne d’une String occupe 2 octets (16 bits), car il s’agit d’un char en UTF-16. Pour la plupart des caractères courants (latin, accentués, etc.), un caractère occupe donc 2 octets. Cependant, certains caractères Unicode (comme les emojis ou des symboles rares) nécessitent deux char (soit 4 octets) pour être représentés, car ils sont codés sur une paire de substitution (surrogate pair). Ainsi, la mémoire utilisée par caractère visible peut varier selon le caractère.\nQuestion 17 # Écrivez un programme Java qui prend une chaîne de caractères en entrée et affiche la valeur numérique (code Unicode) de chaque char de la chaîne.\nRéponse import java.util.Scanner; public class AfficheCodes { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.print(\u0026#34;Entrez une chaîne : \u0026#34;); String s = sc.nextLine(); for (int i = 0; i \u0026lt; s.length(); i++) { char c = s.charAt(i); System.out.println(\u0026#34;Caractère : \u0026#39;\u0026#34; + c + \u0026#34;\u0026#39; | Code Unicode : \u0026#34; + (int) c); } } } Ce programme lit une chaîne au clavier et affiche, pour chaque char, sa valeur numérique (code Unicode en décimal).\nQuestion 18 # Qu’est-ce qu’un stream en Java ? À quoi sert-il ?\nRéponse Un stream est une séquence d’éléments sur laquelle on peut effectuer des opérations de traitement en chaîne (filter, map, etc.). Il permet de manipuler des collections de façon déclarative et fonctionnelle, souvent en une seule ligne de code.\nQuestion 19 # Expliquez le rôle de la méthode filter dans un stream Java. Donnez un exemple.\nRéponse filter permet de ne conserver que les éléments qui satisfont une condition (prédicat). Exemple :\nList\u0026lt;Integer\u0026gt; l = List.of(1, 2, 3, 4); l.stream().filter(x -\u0026gt; x % 2 == 0).forEach(System.out::println); // Affiche 2, 4 Question 20 # À quoi sert la méthode map dans un stream ? Donnez un exemple.\nRéponse map applique une fonction à chaque élément du stream et retourne un nouveau stream avec les résultats. Exemple :\nList\u0026lt;String\u0026gt; noms = List.of(\u0026#34;alice\u0026#34;, \u0026#34;bob\u0026#34;); noms.stream().map(String::toUpperCase).forEach(System.out::println); // ALICE, BOB Question 21 # Expliquez l’utilité de la méthode limit dans un stream Java.\nRéponse limit permet de ne traiter qu’un nombre maximum d’éléments du stream. Exemple :\nStream.iterate(0, n -\u0026gt; n + 1).limit(5).forEach(System.out::println); // 0 1 2 3 4 Question 22 # Que fait la méthode distinct sur un stream ? Donnez un exemple.\nRéponse distinct supprime les doublons du stream (en utilisant equals). Exemple :\nList\u0026lt;Integer\u0026gt; l = List.of(1, 2, 2, 3); l.stream().distinct().forEach(System.out::println); // 1 2 3 Question 23 # Quel est le rôle de la méthode sorted dans un stream Java ?\nRéponse sorted trie les éléments du stream selon l’ordre naturel ou un comparateur fourni. Exemple :\nList\u0026lt;String\u0026gt; noms = List.of(\u0026#34;bob\u0026#34;, \u0026#34;alice\u0026#34;); noms.stream().sorted().forEach(System.out::println); // alice, bob Question 24 # À quoi sert la méthode collect dans un stream ? Donnez un exemple d’utilisation avec Collectors.toList().\nRéponse collect permet de rassembler les éléments du stream dans une collection ou une autre structure de données. Exemple :\nList\u0026lt;Integer\u0026gt; pairs = List.of(1, 2, 3, 4).stream() .filter(x -\u0026gt; x % 2 == 0) .collect(Collectors.toList()); System.out.println(pairs); // [2, 4] Question 25 # Expliquez la différence entre un stream et une collection en Java.\nRéponse Une collection (List, Set, etc.) stocke des données en mémoire et permet d’y accéder plusieurs fois. Un stream est une vue temporaire sur ces données, qui permet de les traiter de façon déclarative : il ne stocke pas les données et ne peut être consommé qu’une seule fois.\nQuestion 26 # Donnez un exemple d’utilisation de stream() sur une liste de chaînes pour obtenir la liste des longueurs distinctes, triées, de ces chaînes.\nRéponse List\u0026lt;String\u0026gt; mots = List.of(\u0026#34;java\u0026#34;, \u0026#34;code\u0026#34;, \u0026#34;stream\u0026#34;, \u0026#34;java\u0026#34;); List\u0026lt;Integer\u0026gt; longueurs = mots.stream() .map(String::length) .distinct() .sorted() .collect(Collectors.toList()); System.out.println(longueurs); // [4, 5, 6] "},{"id":52,"href":"/inf1220-hugo/docs/extra/faq/","title":"FAQ","section":"Autres ressources","content":" Question: Qu\u0026rsquo;est-ce que Java et pourquoi est-il utilisé ? # Réponse: Java est un langage de programmation orienté objet, populaire pour sa portabilité et sa robustesse. Il est utilisé pour développer des applications web, mobiles (comme Android), des logiciels d\u0026rsquo;entreprise et des jeux, car il fonctionne sur de nombreuses plateformes grâce à la machine virtuelle Java (JVM).\nQuestion: Comment installer Java sur mon ordinateur ? # Réponse: Pour installer Java, téléchargez le JDK (Java Development Kit) depuis le site officiel d\u0026rsquo;Oracle ou adoptez une version open-source comme OpenJDK. Suivez les instructions d\u0026rsquo;installation pour votre système (Windows, macOS ou Linux). Vérifiez l\u0026rsquo;installation en tapant java -version dans une invite de commande.\nQuestion: Quelle est la différence entre JDK, JRE et JVM ? # Réponse: Le JDK (Java Development Kit) inclut des outils pour développer des programmes Java. Le JRE (Java Runtime Environment) permet d\u0026rsquo;exécuter des applications Java. La JVM (Java Virtual Machine) est le moteur qui exécute le code Java compilé, inclus dans le JRE.\nQuestion: Pourquoi dois-je écrire public static void main dans mon programme ? # Réponse: La méthode public static void main(String[] args) est le point d\u0026rsquo;entrée d\u0026rsquo;un programme Java. Elle est requise pour que la JVM sache où commencer l\u0026rsquo;exécution. public la rend accessible, static permet de l\u0026rsquo;appeler sans créer d\u0026rsquo;objet, et void indique qu\u0026rsquo;elle ne retourne rien.\nQuestion: Qu\u0026rsquo;est-ce qu\u0026rsquo;une variable en Java et comment la déclarer ? # Réponse: Une variable stocke des données, comme des nombres ou du texte. Pour la déclarer, indiquez son type, son nom et, optionnellement, une valeur initiale, par exemple : int nombre = 10; pour un entier ou String texte = \u0026quot;Bonjour\u0026quot;; pour du texte.\nQuestion: Comment afficher du texte dans la console en Java ? # Réponse: Utilisez la méthode System.out.println() pour afficher du texte dans la console. Par exemple, System.out.println(\u0026quot;Bonjour le monde !\u0026quot;); affiche \u0026ldquo;Bonjour le monde !\u0026rdquo; suivi d\u0026rsquo;un saut de ligne.\nQuestion: Qu\u0026rsquo;est-ce qu\u0026rsquo;une boucle en Java et à quoi sert-elle ? # Réponse: Une boucle exécute un bloc de code plusieurs fois. Par exemple, une boucle for comme for (int i = 0; i \u0026lt; 5; i++) { System.out.println(i); } affiche les nombres de 0 à 4. Les boucles sont utiles pour répéter des tâches, comme parcourir une liste.\nQuestion: C\u0026rsquo;est quoi une classe et un objet en Java ? # Réponse: Une classe est un modèle définissant des propriétés (attributs) et des comportements (méthodes). Un objet est une instance de cette classe. Par exemple, une classe Voiture peut définir une couleur et une méthode pour conduire, et un objet maVoiture est une voiture spécifique créée à partir de cette classe.\nQuestion: Pourquoi vois-je une erreur \u0026ldquo;NullPointerException\u0026rdquo; ? # Réponse: Une NullPointerException se produit quand vous essayez d\u0026rsquo;utiliser une variable ou un objet qui n\u0026rsquo;a pas été initialisé (sa valeur est null). Vérifiez si vous avez bien créé l\u0026rsquo;objet avec new ou si la variable a une valeur avant de l\u0026rsquo;utiliser.\nQuestion: Comment lire une entrée utilisateur en Java ? # Réponse: Utilisez la classe Scanner pour lire une entrée. Par exemple :\nimport java.util.Scanner; Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;Entrez votre nom : \u0026#34;); String nom = scanner.nextLine(); Cela lit une ligne de texte entrée par l\u0026rsquo;utilisateur et la stocke dans la variable nom.\nQuestion: Pourquoi est-ce que le cours ne s\u0026rsquo;offre pas en vidéoconférence ? # Réponse: Nous nous ferons un plaisir de répondre à vos questions par courriel, mais nous n\u0026rsquo;offrons pas d\u0026rsquo;enseignement par vidéoconférence au sein du cours INF 1220. La plupart des universités québécoises ont offert des cours d\u0026rsquo;informatique en vidéoconférence (zoom, etc.) lors de la grande pandémie de 2020-2021. L\u0026rsquo;Université Laval offre plusieurs cours selon ce modèle. Ce n\u0026rsquo;est pas le modèle de l\u0026rsquo;Université TÉLUQ. La plupart de nos étudiants ne souhaitent pas se présenter à heure fixe pour une session de cours de trois heures en vidéoconférence. Il est indéniable que l\u0026rsquo;enseignement par vidéoconférence répond bien aux besoins de certains étudiants, mais il est déjà offert ailleurs et nous ne croyons pas qu\u0026rsquo;il répond aux besoins de nos étudiants.\nQuestion: J\u0026rsquo;ai remis ma solution sans explication. Ma solution était correcte, mais j\u0026rsquo;ai quand même obtenu zéro, est-ce normal ? # Réponse: Oui, vous devez expliquer vos solutions.\nQuestion: J\u0026rsquo;ai terminé l\u0026rsquo;examen et je suis déçu de ma note. Est-ce que je peux avoir une explication de mon résultat ? # Réponse: Oui, suivez les consignes fournies par l\u0026rsquo;Université. Vous devez passer par les moyens sécurisés de l\u0026rsquo;Université.\nQuestion: Ma date de fin de cours était hier, et aujourd\u0026rsquo;hui, je n\u0026rsquo;arrive pas à déposer mon travail noté. Est-ce que je peux le transmettre par courriel ? # Réponse: Non. Si la date de fin de cours est passée, il est normal que vous ne puissiez pas déposer votre travail. Vous obtiendrez la note de zéro.\nQuestion: Il m\u0026rsquo;a fallu des heures pour compléter le module X et remettre le travail noté, est-ce normal ? # Réponse: Absolument. Il faut prévoir des dizaines d\u0026rsquo;heures par module (et donc par travail noté). Prévoyez entre 5 et 15 heures par semaine pendant 15 semaines pour compléter le cours.\nQuestion: Mon examen est dans trois mois, mais la date de fin de cours officiel est dans une semaine. Est-ce que cela signifie que j\u0026rsquo;ai trois mois supplémentaires pour remettre mes travaux ? # Réponse: Non. Tout travail remis après votre date de fin de cours peut recevoir la note de zéro.\nQuestion: Je n\u0026rsquo;ai pas reçu de lettre confirmant mon inscription au cours ? # Réponse: Dans ce cas, vous n\u0026rsquo;êtes pas reconnu comme étant inscrit au cours. Vérifiez auprès de l\u0026rsquo;Université. Vous devez avoir reçu une confirmation écrite concernant votre inscription. Bien que vous les receviez directement, les documents officiels sont aussi disponibles en cliquant sur l’onglet « Documents reçus » au sein du tableau de bord du portail étudiant.\nQuestion: J\u0026rsquo;ai besoin de plus de temps que prévu pour terminer le cours, on m\u0026rsquo;a dit que le professeur pouvait m\u0026rsquo;arranger ? # Réponse: Non. La date de fin de cours ainsi que le moment où votre dossier est fermé sont déterminés par l\u0026rsquo;Université.\nQuestion: J\u0026rsquo;ai été très malade et j\u0026rsquo;ai pris du retard, est-ce que vous pouvez me donner plus de temps ? # Réponse: Non. La date de fin de cours ainsi que le moment où votre dossier est fermé sont déterminés par l\u0026rsquo;Université.\nQuestion: Combien de temps faut-il investir dans ce cours ? # Réponse: Le temps nécessaire dépend de votre préparation individuelle, mais vous devriez prévoir environ 9 heures par semaine pendant quinze semaines. Les étudiants qui ont déjà de l\u0026rsquo;expérience en programmation peuvent aller beaucoup plus rapidement.\nQuestion: J\u0026rsquo;ai eu des difficultés personnelles, j\u0026rsquo;ai manqué de temps, est-ce que le professeur peut modifier ma date de fin de cours ? # Réponse: Non. Si vous devez reporter votre date de fin de cours, vous devez joindre l\u0026rsquo;Université.\nQuestion: J\u0026rsquo;ai du mal avec une question dans un des travaux, est-ce que je peux avoir un indice, une partie de la solution ? # Réponse: Non. Les travaux notés sont des travaux individuels. Assurez-vous de bien compléter les exercices et les lectures avant d\u0026rsquo;entreprendre les travaux notés.\nQuestion: Je dois passer l\u0026rsquo;examen le X, mais j\u0026rsquo;ai un empêchement, est-ce que vous pouvez déplacer l\u0026rsquo;examen ? # Réponse: Vous devez joindre l\u0026rsquo;Université.\nQuestion: Je viens de passer 35 heures sur la question X du travail noté Y, est-ce que vous pouvez me donner un indice ? # Réponse: Non. Ce serait inéquitable. Nous avons un grand volume d\u0026rsquo;étudiants avec un bon taux de succès (de bonnes notes) : nous savons donc que les travaux notés ne sont pas trop difficiles. Par contre, il arrive souvent que les étudiants ne fassent pas correctement tous les exercices et toutes les lectures préparatoires, croyant à tort qu\u0026rsquo;ils gagneront du temps en allant directement au travail noté. D\u0026rsquo;autres étudiants n\u0026rsquo;ont tout simplement pas la préparation suffisante : la programmation est un langage formel qui est difficile pour ceux qui n\u0026rsquo;ont pas acquis les bases en mathématiques.\nCeci étant dit, il est parfaitement normal de passer 35 heures sur un des modules. Il faut prévoir un total d\u0026rsquo;environ 135 heures (en moyenne) pour compléter le cours. Certains étudiants peuvent aller plus rapidement. Si vous partez de plus loin et qu\u0026rsquo;il vous manque des préalables (par exemple, mathématiques), il faut prévoir un peu plus de temps.\n"},{"id":53,"href":"/inf1220-hugo/docs/modules/module1/erreurs/","title":"Les erreurs communes","section":"Module 1: Algorithme et pseudocode","content":" Erreurs communes # Rédiger du pseudo-code n\u0026rsquo;a rien de sorcier, mais plusieurs étudiants font des erreurs. Voici quelques erreurs communes.\nCertains étudiants rédigent du pseudo-code qui a l\u0026rsquo;air formel et correct, mais qui est en fait ambigu et inutilisable. Prenons cet exemple: SI j'ai mal aux dos ALORS je prend des aspirines OU SI j'ai faim ALORS je mange. Bien sûr, je n\u0026rsquo;ai utilisé que des expressions logiques. Des SI, des ALORS des OU. Mais qu\u0026rsquo;est-ce que ça signifie ? Par exemple, est-ce que je peux à la fois manger et prendre des aspirines dans ce scénario ? La réponse est subjective. Votre pseudo-code doit être exécutable sans interprétation. Un pseudo-code n\u0026rsquo;est pas un texte à interprétation subjective. Vous ne pouvez pas faire semblant d\u0026rsquo;écrire du pseudo-code en utilisant simplement les termes qu\u0026rsquo;on trouve fréquemment au sein des pseudo-codes. Ce n\u0026rsquo;est pas une question de syntaxe. On peut parfaitement écrire du pseudo-code sans jamais utiliser SI, TANT QUE, etc. Plusieurs étudiants obsèdent sur la syntaxe, croyant à tort que si on leur donne les bons termes, la bonne grammaire, ils trouveront comment comprendre ce qu\u0026rsquo;est un pseudo-code. Or, c\u0026rsquo;est justement le contraire de la leçon ici: nous voulons que vous compreniez que la syntaxe exacte est secondaire dans la pensée algorithmique. On peut être imprécis et incohérent en utilisant une syntaxe formelle, et on peut être précis et cohérent en utilisant du français usuel. Ce n\u0026rsquo;est pas parce que vous utilisez des expressions qui vous semblent précises que vous l\u0026rsquo;êtes. Vous devez avoir une idée précise en tête et vous devez l\u0026rsquo;exprimer avec précision.\nAu sein d\u0026rsquo;une boucle (par ex., TANT QUE), les étudiants peuvent mettre par erreur une condition qui termine toujours le programme. Dans un tel cas, la boucle ne peut pas s\u0026rsquo;exécuter et elle est de facto brisée. Voici un exemple. Les instructions « retourner minimum » et « retourner tableau[iterateur] » terminent le pseudo-code. Assurez-vous de bien comprendre que ce pseudo-code ne va consulter que la première valeur du tableau. Si vous avez une condition ou les deux branches (SI et SINON) retournent une valeur et terminent donc l\u0026rsquo;algorithme, votre algorithme ne procèdera pas plus loin.\nVariable iterateur (entier) Variable minimum = tableau[0] iterateur = 0 TANT QUE iterateur \u0026lt; 100 FAIRE SI tableau[iterateur] \u0026lt; minimum ALORS retourner tableau[iterateur]; SINON retourner minimum FIN SI iterateur = iterateur + 1; FIN TANT QUE Certains étudiants construisent des boucles qui ne se terminent jamais. Dans une boucle TANT QUE, il faut s\u0026rsquo;assurer que la condition ne soit plus satisfaite pour ne pas avoir une boucle infinie. Consultez cet exemple. Si vous testez votre pseudo-code, vous saurez éviter de telles erreurs. iterateur = 0 TANT QUE iterateur \u0026lt; 100 FAIRE SI iterateur \u0026lt; 10 ALORS ajouter un à itérateur FIN SI FIN TANT QUE Les étudiants vont aussi fréquemment utiliser des variables et des constructions qui ne sont pas définies et dont le sens doit être deviné. Voici un exemple. Vous constaterez à la lecture de ce pseudo-code qu\u0026rsquo;il y a plusieurs conventions syntaxiques qui ne sont pas définies. Il y a plusieurs variables, mais il est difficile de connaître leur type et leurs relations. Assurez-vous donc de bien expliquer chaque variable et de bien définir votre syntaxe. Dans ce dernier exemple, que représente iterateur, iterateur[tableau], tableau[iterateur], etc.? Vous devez être précis. Souvent, nous avons un nombre limité de « types » pour les variables: nombres, entiers, chaînes de caractères. On utilise le plus souvent la convention t[i] pour désigner l\u0026rsquo;élément à l\u0026rsquo;index i du tableau t. Dans un tel cas, t doit être un tableau, i doit être une valeur entière. Vous être libre de concevoir vos propres conventions, mais vous devez être explicite et précis. Si votre pseudo-code doit retourner une valeur, il faut que le pseudo-code le spécifie explicitement. Entier iterateur[tableau] = 0; TANT QUE iterateur[i] \u0026lt; 100 FAIRE SI tableau[iterateur] \u0026lt; minimum ALORS retourner iterateur[tableau]; FIN SI iterateur = iterateur[tableau] + 1; FIN POUR TOUT Si vous avez bien défini le type de vos variables, et toutes vos conventions syntaxiques, il vous reste maintenant à vous assurer que les valeurs de vos variables sont toujours spécifiées. Si vous dites que x est un nombre et que vous posez ensuite l\u0026rsquo;inéquation x \u0026gt; 1, nous ne pouvons en connaître la valeur que si x a reçu une valeur. Assurez-vous donc de donner une valeur initiale à toutes vos variables. En tout temps, dans votre pseudo-code, le lecteur doit pouvoir déterminer la valeur d\u0026rsquo;une variable donnée.\nParfois les étudiants manquent tout simplement de rigueur. Pour vérifiez si votre pseudo-code est rigoureux, appliquez-le sur un exemple concret comme si vous étiez un robot. Par exemple, si quelqu\u0026rsquo;un écrit le pseudo-code suivant « je prend chacune des valeurs du tableau, et je l\u0026rsquo;additionne à la valeur suivante dans le tableau »\u0026hellip; vous pourriez alors prendre un tableau à titre d\u0026rsquo;exemple, comme [1,2,3] et tester l\u0026rsquo;instruction. Qu\u0026rsquo;est-ce que ça donnerait ? Je prend les valeurs une à une et je l\u0026rsquo;additionne à la valeur suivante dans le tableau. Je prend donc 1 et sa valeur suivante (1 + 2), ensuite 2 et sa valeur suivante (2 + 3), et ensuite 3 et sa valeur suivante\u0026hellip; ? Je me rend compte que l\u0026rsquo;expression « la valeur suivante » n\u0026rsquo;est pas bien définie. Voici un autre exemple. Quelqu\u0026rsquo;un pourrait avoir comme pseudo-code « j\u0026rsquo;initialise la variable comme ayant comme valeur le premier élément du tableau ». Testons ce pseudo-code sur le tableau vide (de taille zéro). Nous constatons qu\u0026rsquo;il n\u0026rsquo;y a pas de premier élément ! Donc si le tableau vide n\u0026rsquo;est pas exclu, nous avons un problème de rigueur. Voici un truc: testez toujours votre pseudo-code avec plusieurs exemples concrets. Prenez le temps d\u0026rsquo;appliquer les instructions de votre pseudo-code ligne par ligne, comme si vous étiez un robot. Pensez comme un ordinateur!\nNous vous invitons maintenant à passez aux premiers exercices du cours!\n"},{"id":54,"href":"/inf1220-hugo/docs/extra/manuel/","title":"Manuel","section":"Autres ressources","content":"Nous utilisons un manuel d\u0026rsquo;introduction à la programmation Java intitulé Java pas à pas par Robert Godin et Daniel Lemire. Vous pouvez charger le document PDF dès maintenant.\nCet ouvrage présente les concepts de base de la programmation et du langage Java. Le livre s’adresse à un auditoire très large, aussi bien un débutant qui désire apprendre la programmation pour le plaisir qu’à un étudiant qui entreprend une carrière d’informaticien. L’approche proposée introduit graduellement les concepts de base de la programmation et leur incarnation dans le langage Java à l’aide d’une série d’exemples et d’exercices.\nAfin de promouvoir l’aspect ludique de la programmation, le développement d’applications graphiques en deux dimensions et d’un jeu interactif simple est proposé pour illustrer des concepts de programmation importants, tels que la programmation objet et la modularisation du code, dans un contexte non trivial.\nLe lecteur y apprend les caractéristiques principales du langage Java et les outils et techniques de base du langage Java. Le manuel offre une initiation à la programmation orientée objet, mais il couvre aussi des sujets concrets comme l\u0026rsquo;accès aux fichiers.\nVous pouvez aussi acheter la version papier du manuel Java pas à pas chez Amazon:\nCorrespondance avec les modules # Module Chapitres/Sections du manuel recommandés Thème principal du manuel pour le module 1 Chapitre 1 : Concepts de base Introduction, concepts fondamentaux, exercices de base 2 Chapitre 2 : Introduction à Java\nChapitre 4 : Types/expressions Types, expressions, bases de la programmation Java 3 Chapitre 3 : Structures de contrôle Structures de contrôle (conditions, boucles, etc.) 4 Chapitre 9 : Traitement de fichiers Fichiers, entrées/sorties, gestion de données 5 Chapitres 5 à 8 : Graphisme 2D, animation, conception objet, jeu Programmation objet, graphisme, animation, projet jeu "},{"id":55,"href":"/inf1220-hugo/docs/modules/module3/conseils/","title":"Recommandations","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" Recommandations # Pour aborder un problème algorithmique, adoptez une démarche structurée. Analysez d’abord le problème en le décomposant en étapes simples. Avant de coder, rédigez un pseudo-code ou un plan pour clarifier la logique. Cette préparation limite les erreurs et facilite la maintenance.\nPrivilégiez un code lisible avec des noms de variables explicites. Testez chaque étape avec des cas simples avant d’explorer des scénarios complexes. Cette validation progressive permet de repérer rapidement les anomalies et de garantir la robustesse de la solution.\nIl faut toujours tester son code.\nIllustration : importance des tests # Voici comment on peut illustrer l’importance des tests en Java avec une fonction de recherche binaire dans un tableau trié. Si on veut créer une fonction de recherche binaire, nous pouvons commencer par écrire une fonction de test.\n// Fonction de test public static void tester() { int[] tab = {1, 3, 5, 7, 9, 11}; System.out.println(rechercheBinaire(tab, 7)); // Doit afficher 3 System.out.println(rechercheBinaire(tab, 1)); // Doit afficher 0 System.out.println(rechercheBinaire(tab, 11)); // Doit afficher 5 System.out.println(rechercheBinaire(tab, 4)); // Doit afficher -1 } La fonction de test tester() permet de vérifier rapidement si la recherche binaire fonctionne comme prévu. En pratique, les programmeurs écrivent des tests plus détaillés et ils utilisent des librairies logicielles dédiées. Néanmoins, l\u0026rsquo;idée générale demeure la même.\nLa première version contient un bogue classique (gauche \u0026lt; droite au lieu de gauche \u0026lt;= droite), ce qui fait échouer certains cas.\nTestRechercheBinaire.java public class TestRechercheBinaire { // Version boguée de la recherche binaire public static int rechercheBinaire(int[] tab, int valeur) { int gauche = 0; int droite = tab.length - 1; while (gauche \u0026lt; droite) { // Erreur : devrait être \u0026lt;= int milieu = (gauche \u0026#43; droite) / 2; if (tab[milieu] == valeur) { return milieu; } else if (tab[milieu] \u0026lt; valeur) { gauche = milieu \u0026#43; 1; } else { droite = milieu - 1; } } return -1; } // Fonction de test public static void tester() { int[] tab = {1, 3, 5, 7, 9, 11}; System.out.println(rechercheBinaire(tab, 7)); // Doit afficher 3 System.out.println(rechercheBinaire(tab, 1)); // Doit afficher 0 System.out.println(rechercheBinaire(tab, 11)); // Doit afficher 5 System.out.println(rechercheBinaire(tab, 4)); // Doit afficher -1 } public static void main(String[] args) { System.out.println(\u0026#34;Tests avec version boguée :\u0026#34;); tester(); } } Exécuter Après avoir constaté l’erreur grâce aux tests, on corrige la fonction et on vérifie que tous les cas passent. Cette démarche montre l’importance de toujours tester son code, même pour des algorithmes classiques.\nTestRechercheBinaire.java public class TestRechercheBinaire { // Version corrigée public static int rechercheBinaire(int[] tab, int valeur) { int gauche = 0; int droite = tab.length - 1; while (gauche \u0026lt;= droite) { // Correction ici int milieu = (gauche \u0026#43; droite) / 2; if (tab[milieu] == valeur) { return milieu; } else if (tab[milieu] \u0026lt; valeur) { gauche = milieu \u0026#43; 1; } else { droite = milieu - 1; } } return -1; } // Fonction de test public static void tester() { int[] tab = {1, 3, 5, 7, 9, 11}; System.out.println(rechercheBinaire(tab, 7)); // Doit afficher 3 System.out.println(rechercheBinaire(tab, 1)); // Doit afficher 0 System.out.println(rechercheBinaire(tab, 11)); // Doit afficher 5 System.out.println(rechercheBinaire(tab, 4)); // Doit afficher -1 } public static void main(String[] args) { System.out.println(\u0026#34;Tests avec version boguée :\u0026#34;); tester(); } } Exécuter Illustration : plus long sous-tableau à somme divisible par \\( k \\) # Considérons le problème suivant : trouver la longueur du plus long sous-tableau contigu dans un tableau d’entiers dont la somme est divisible par \\( k \\). Par exemple, pour le tableau \\([4, 5, 0, -2, -3, 1]\\) et \\( k = 5 \\), le sous-tableau \\([5, 0, -2, -3]\\) a une somme de \\( 0 \\), divisible par \\( 5 \\), et sa longueur est \\( 4 \\).\nComprendre le problème # Avant de se lancer dans la programmation, il est essentiel de bien comprendre ce que l’on cherche à résoudre. Ici, le problème porte sur les sous-tableaux : il s’agit de séquences continues d’éléments dans un tableau. On veut trouver, parmi tous ces sous-tableaux, celui qui a la plus grande longueur et dont la somme des éléments est un multiple de \\( k \\).\nIl est utile de se poser les questions suivantes :\nQu’est-ce qu’un sous-tableau ? C’est une portion du tableau, prise sans sauter d’éléments (par exemple, les éléments d’indice 2 à 5). Que signifie « somme divisible par \\( k \\) » ? Cela veut dire que si on additionne tous les éléments du sous-tableau, le résultat est un multiple de \\( k \\) (par exemple, 15 est divisible par 5). Que veut dire « longueur maximale » ? On cherche le sous-tableau le plus long possible qui respecte la condition. Il est important de bien lire l’énoncé, de reformuler le problème avec ses propres mots, et de donner un ou deux exemples concrets pour vérifier sa compréhension. Par exemple : « Si j’ai le tableau [4, 5, 0, -2, -3, 1] et \\( k = 5 \\), alors le sous-tableau [5, 0, -2, -3] a une somme de 0, qui est bien divisible par 5, et il contient 4 éléments. »\nDécomposer le problème # Décomposer un problème, c’est le diviser en étapes simples et logiques. Cela signifie :\nIdentifier les opérations de base à effectuer (par exemple, additionner des éléments, vérifier si un nombre est divisible par \\( k \\), parcourir un tableau). Écrire ces étapes sous forme de liste ou de pseudo-code, sans se soucier tout de suite du langage de programmation. Pour ce problème, une décomposition possible serait :\nParcourir toutes les positions de début possibles pour un sous-tableau. Pour chaque position de début, parcourir toutes les positions de fin possibles. Calculer la somme des éléments entre ces deux positions. Vérifier si cette somme est divisible par \\( k \\). Si oui, comparer la longueur de ce sous-tableau à la longueur maximale trouvée jusqu’ici, et mettre à jour si nécessaire. Cette démarche permet de clarifier la logique avant de coder, d’éviter de se perdre dans les détails, et de s’assurer que chaque étape est comprise. Plus tard, on pourra chercher à optimiser la solution, mais il est important de commencer par une version simple et correcte.\nSolution naïve # La solution naïve consiste à tester toutes les possibilités, sans chercher à optimiser. Pour ce problème, cela veut dire : on va examiner tous les sous-tableaux possibles du tableau, un par un, et vérifier pour chacun si la somme de ses éléments est divisible par \\( k \\).\nConcrètement, on utilise deux boucles : la première choisit le point de départ du sous-tableau, la seconde choisit le point d’arrivée. Pour chaque sous-tableau ainsi défini, on additionne ses éléments, puis on regarde si le résultat est un multiple de \\( k \\). Si c’est le cas, on regarde si ce sous-tableau est plus long que ceux trouvés précédemment, et on garde la plus grande longueur trouvée.\nCette méthode est facile à comprendre et à programmer, car elle suit directement l’énoncé : « regarder tous les cas possibles ». Mais elle est lente si le tableau est grand, car le nombre de sous-tableaux à tester augmente très vite (c’est ce qu’on appelle une complexité quadratique, ou \\( O(n^2) \\)).\nIl est important de commencer par cette approche, car elle permet de bien comprendre la logique du problème avant de chercher à l’optimiser.\npublic class SousTableauDivisibleNaif { public static int plusLongSousTableauDivisible(int[] tableau, int k) { int longueurMax = 0; for (int i = 0; i \u0026lt; tableau.length; i++) { int somme = 0; for (int j = i; j \u0026lt; tableau.length; j++) { somme += tableau[j]; if (somme % k == 0) { longueurMax = Math.max(longueurMax, j - i + 1); } } } return longueurMax; } public static void main(String[] args) { int[] test1 = {4, 5, 0, -2, -3, 1}; assert plusLongSousTableauDivisible(test1, 5) == 4 : \u0026#34;Test 1 échoué\u0026#34;; int[] test2 = {}; assert plusLongSousTableauDivisible(test2, 3) == 0 : \u0026#34;Test 2 échoué\u0026#34;; int[] test3 = {1, 2, 3}; assert plusLongSousTableauDivisible(test3, 5) == 0 : \u0026#34;Test 3 échoué\u0026#34;; System.out.println(\u0026#34;Tests naïfs réussis\u0026#34;); } } Solution optimisée avec sommes préfixes # La solution optimisée repose sur une idée mathématique puissante : les sommes préfixes. Plutôt que de recalculer la somme de chaque sous-tableau à chaque fois (comme dans la solution naïve), on va mémoriser la somme des éléments depuis le début du tableau jusqu’à chaque position. Cela permet de calculer rapidement la somme de n’importe quel sous-tableau en faisant une simple soustraction.\nMais l’astuce la plus importante ici, c’est d’utiliser le fait que deux sommes préfixes qui ont le même reste lorsqu’on les divise par \\( k \\) indiquent qu’il existe un sous-tableau entre ces deux positions dont la somme est divisible par \\( k \\). Pourquoi ? Parce que si \\( S_j \\mod k = S_{i-1} \\mod k \\), alors la différence \\( S_j - S_{i-1} \\) est un multiple de \\( k \\).\nPour exploiter cela, on parcourt le tableau une seule fois :\nÀ chaque étape, on calcule la somme courante des éléments (somme préfixe). On calcule le reste de cette somme modulo \\( k \\) (en gérant les cas négatifs pour que le reste soit toujours positif). On utilise une table de hachage (HashMap) pour mémoriser le premier indice où chaque reste a été vu. Si on retrouve le même reste plus tard, cela veut dire qu’il existe un sous-tableau entre ces deux indices dont la somme est divisible par \\( k \\). On calcule alors la longueur de ce sous-tableau et on garde la plus grande longueur trouvée. Cette méthode est très efficace : elle ne nécessite qu’un seul parcours du tableau (complexité linéaire \\( O(n) \\)), ce qui la rend adaptée même pour de très grands tableaux. C’est un exemple classique d’optimisation en algorithmique : on passe d’une solution simple mais lente à une solution plus subtile, mais beaucoup plus rapide, en utilisant des propriétés mathématiques et des structures de données adaptées.\nimport java.util.HashMap; import java.util.Map; public class SousTableauDivisibleOptimise { public static int plusLongSousTableauDivisible(int[] tableau, int k) { Map\u0026lt;Long, Integer\u0026gt; restes = new HashMap\u0026lt;\u0026gt;(); restes.put(0L, -1); // Cas où le sous-tableau commence à l’indice 0 long somme = 0; int longueurMax = 0; for (int i = 0; i \u0026lt; tableau.length; i++) { somme += tableau[i]; long reste = ((somme % k) + k) % k; // Gérer les restes négatifs if (restes.containsKey(reste)) { longueurMax = Math.max(longueurMax, i - restes.get(reste)); } restes.putIfAbsent(reste, i); // Stocker le premier indice du reste } return longueurMax; } public static void main(String[] args) { int[] test1 = {4, 5, 0, -2, -3, 1}; assert plusLongSousTableauDivisible(test1, 5) == 4 : \u0026#34;Test 1 échoué\u0026#34;; int[] test2 = {}; assert plusLongSousTableauDivisible(test2, 3) == 0 : \u0026#34;Test 2 échoué\u0026#34;; int[] test3 = {1, 2, 3}; assert plusLongSousTableauDivisible(test3, 5) == 0 : \u0026#34;Test 3 échoué\u0026#34;; int[] test4 = {-1, 2, -1}; assert plusLongSousTableauDivisible(test4, 2) == 2 : \u0026#34;Test 4 échoué\u0026#34;; int[] test5 = {3, 3, 3}; assert plusLongSousTableauDivisible(test5, 3) == 3 : \u0026#34;Test 5 échoué\u0026#34;; System.out.println(\u0026#34;Tests optimisés réussis\u0026#34;); } } Améliorations et cas particuliers # La solution optimisée gère les restes négatifs et utilise des clés de type Long pour éviter les débordements avec de grandes sommes. Les tests incluent des cas variés : tableau vide, absence de sous-tableau valide, nombres négatifs et sous-tableaux entiers divisibles par \\( k \\).\nCette approche illustre l’importance de passer d’une solution naïve à une solution optimisée en exploitant des propriétés mathématiques, tout en validant chaque étape avec des tests rigoureux.\n"},{"id":56,"href":"/inf1220-hugo/docs/modules/module1/exercices/","title":"Exercices sur les algorithmes","section":"Module 1: Algorithme et pseudocode","content":" Exercices sur les algorithmes et problèmes # La notion d\u0026rsquo;algorithme a été abordée implicitement dès les premiers cours de mathématiques, par exemple avec l\u0026rsquo;algorithme de la division longue. Ces exercices visent à vous faire décrire formellement un algorithme. La principale difficulté pour la plupart des étudiants réside dans la rigueur et la précision requises. Au-delà d’un certain point, il n’existe pas de lectures supplémentaires : la pratique est essentielle.\nIl est permis d’utiliser le robot conversationnel du cours pour ces exercices (voir ici). Toutefois, entraînez-vous à produire vos propres réponses.\nComment procéder pour les exercices :\nLisez attentivement la question. Cherchez une solution. Si vous ne trouvez pas immédiatement, consacrez 10 à 15 minutes à y réfléchir. Si le problème exact vous résiste, tentez une solution partielle. Pour cet exercice, vous devez produire du pseudo-code, et non du Java. Rédigez votre solution avec précision, comme une suite de consignes qu’un enfant pourrait suivre. Exécutez votre pseudo-code (voir l’exécution d’un pseudo-code à l’activité 1.2). Consultez ensuite la ou les solutions proposées. Assurez-vous de comprendre toutes les solutions. Posez des questions si nécessaire, en fournissant votre propre solution pour appuyer vos interrogations. Comprendre les solutions proposées est impératif. Ces exercices sont obligatoires et ne doivent pas être survolés ou omis.\nPour lire les formules mathématiques sur le site du cours, utilisez un navigateur compatible avec MathML, comme Chrome, Edge, Firefox ou Safari.\nCes exercices sont conçus pour l’autoévaluation ; ils ne sont pas corrigés. Nous répondons cependant à vos questions sur la matière.\nLes solutions à ces exercices ne sont pas uniques. Il existe plusieurs syntaxes possibles pour décrire un algorithme en pseudo-code. Cela ne signifie pas que toutes les solutions sont correctes. Un pseudo-code peut être erroné s’il ne décrit pas une solution logiquement correcte ou s’il manque de précision pour être considéré comme un algorithme. Un pseudo-code doit pouvoir être exécuté littéralement par un humain sans jugement, comme un automate.\nRappel : les mathématiques du collégial sont un préalable obligatoire à ce cours. Une aisance en algèbre, fonctions et arithmétique est nécessaire. Sans ces prérequis, réussir ce cours peut être difficile.\nRéponses uniques ? # Les exercices incluent une solution pour comparer votre approche à la nôtre. Il n’existe pas de solution unique ; votre solution peut être meilleure ou moins bonne que celle proposée.\nExercice 1 : La somme d’un tableau # Dans la plupart des langages informatiques, un tableau correspond à un vecteur en algèbre linéaire, soit une série de nombres, comme \\(\\langle 1,6,4,10 \\rangle\\). Dans cet exercice, vous devez proposer un algorithme pour calculer la somme des nombres entiers d’un tableau à une dimension de longueur quelconque (de 0 à plus d’un million de nombres). Utilisez une structure d’itération (boucle) pour parcourir chaque nombre du tableau.\nPour manipuler le tableau, vous pouvez écrire « Récupérer le nombre à l’index i » (où i est une variable contenant l’index) ou utiliser une syntaxe proche des langages de programmation, par exemple : Entier e = monTableau[i]. Pour obtenir la longueur du tableau, utilisez « la taille de monTableau ».\nTestez votre pseudo-code en l’appliquant ligne par ligne à un exemple, comme si vous étiez un robot. Prenez votre temps.\nSi vous introduisez d’autres conventions de notation, soyez précis. Spécifiez le type de toutes vos variables et donnez explicitement des valeurs initiales, sauf si elles sont reçues en paramètre.\nConcevez cet algorithme en pseudo-code, en utilisant des termes concis, explicatifs et cohérents.\nRéponse Entrée : Tableau d’entiers monTableau de taille N Variables : Entier somme = 0 // La somme du tableau Entier index = 0 // Index de l’élément du tableau Sortie : Entier somme Algorithme sommeTableau : TANT QUE index \u0026lt; taille de monTableau FAIRE somme = somme + monTableau[index] // Addition des nombres index = index + 1 // Incrémentation de l’index FIN TANT QUE retourne somme Exercice 2 : La recherche d’un entier # La recherche d’information dans une structure de données (tableau, graphe, arbre, etc.) est un domaine clé en informatique. Bien que les bases de données comme MySQL simplifient la recherche, il est souvent nécessaire de concevoir ses propres solutions. À partir de l’exercice 1, proposez un algorithme en pseudo-code pour vérifier si un entier (par exemple, un numéro de téléphone) est présent dans un tableau et retourner son index, ou -1 s’il est absent. Utilisez une structure itérative et une structure de contrôle (SI _ ALORS _ FIN SI).\nRéponse Entrée : Tableau d’entiers monTableau de taille N Entier nombreATrouver Variables : Entier index = 0 // Index de l’élément du tableau Sortie : Index de l’entier ou -1 si non trouvé Algorithme trouverEntier : TANT QUE index \u0026lt; taille de monTableau FAIRE SI nombreATrouver est égal à monTableau[index] ALORS retourner index // Fin de l’algorithme FIN SI index = index + 1 // Incrémentation de l’index FIN TANT QUE retourner -1 // Nombre non trouvé Exercice 3 : Somme des multiples de 3 ou 5 # Additionnez tous les nombres naturels inférieurs à \\(1000\\) qui sont multiples de \\(3\\) ou de \\(5\\).\nRéponse Voici un algorithme inefficace. Vous pouvez faire mieux :\nVariable entière i = 0 Variable entière somme = 0 TANT QUE i \u0026lt; 1000 SI le reste de la division par 3 de i est zéro OU le reste de la division par 5 de i est zéro ALORS somme = somme + i i = i + 1 FIN TANT QUE Retourne somme Exercice 4 : Plus grand diviseur premier # Trouvez le plus grand nombre premier qui divise \\(317584931803\\).\nRéponse Voici un algorithme inefficace (effectuant plus d’opérations que nécessaire). Vous pouvez faire mieux :\nVariable entière i = 1 Variable entière solution = 1 TANT QUE i \u0026lt; 317584931803 SI le reste de la division de 317584931803 par i est zéro ALORS Variable entière j = 3 Variable booléenne premier = vrai TANT QUE j \u0026lt; i SI le reste de la division de i par j est zéro ALORS premier = faux j = j + 1 FIN TANT QUE SI premier ALORS solution = i i = i + 1 FIN TANT QUE Retourne solution Pour les curieux, voici une solution exécutable en Python (voir ici) :\ni = 1 solution = 1 while i \u0026lt; 317584931803: if 317584931803 % i == 0: j = 3 premier = True while j \u0026lt; i: if i % j == 0: premier = False j = j + 1 if premier: print(i, \u0026#34; est premier\u0026#34;) solution = i i = i + 1 print(solution) Vous pouvez supprimer la ligne print(i, \u0026quot; est premier\u0026quot;) pour n’obtenir que la réponse finale. Notez que j commence à 3, car tout diviseur premier (sauf 2) est impair d’après le théorème fondamental de l’arithmétique.\nExercice 5 : Chiffre des dizaines # Pour un entier positif \\(x\\), trouvez le chiffre occupant la position des dizaines.\nRéponse Variable entière x Divise x par 10, stocke le quotient dans la variable y Divise y par 10, retourne le reste de la division Exemple : si x est 531, le quotient de 531 divisé par 10 est 53, reste 1. Le quotient de 53 divisé par 10 est 5, reste 3.\nExercice 6 : Erreur dans un pseudo-code # Trouvez l’erreur dans le pseudo-code suivant :\nEntrées : Tableau R de longueur N Valeur X Sortie : Est-ce que la valeur X se trouve dans le tableau R ? Variables : Itérateur i = 0 Tant que i \u0026lt;= N Si R[i] = X Alors retourne Vrai i = i + 1 retourne Faux Réponse L’itérateur i prend les valeurs de 0 à N, accédant ainsi à N+1 éléments du tableau R, ce qui provoque une erreur d’accès hors limites.\nExercice 7 : Racines d’un polynôme du second degré # Soit \\(P(x) = ax^2 + bx + c\\) un polynôme du second degré à coefficients réels. Les racines se calculent via le discriminant \\(A = b^2 - 4ac\\).\nSi \\(A \u003c 0\\), il n’y a pas de racine. Si \\(A \u003e 0\\), il existe deux racines : \\(X_1 = \\frac{-b - \\sqrt{A}}{2a}\\) et \\(X_2 = \\frac{-b + \\sqrt{A}}{2a}\\). Si \\(A = 0\\), il existe une racine double : \\(X_1 = X_2 = \\frac{-b}{2a}\\). Écrivez un algorithme qui, pour un polynôme donné par ses coefficients, calcule le discriminant, affiche « ce polynôme n’a pas de racine dans R » si A \u0026lt; 0, et calcule les racines sinon.\nRéponse Algo pol Entrée : Nombres réels a, b, c // Coefficients du polynôme Variables : Nombres réels X1, X2, A // Racines et discriminant Début A = b² - 4ac Si A \u0026lt; 0 Alors Afficher « ce polynôme n’a pas de racine dans R » Sinon Si A égale 0 X1 = X2 = -b/(2a) Sinon // A \u0026gt; 0 X1 = (-b - √A)/(2a) X2 = (-b + √A)/(2a) Fin Si Fin Si Fin Exercice 8 : Exécution de l’algorithme des racines # Exécutez l\u0026rsquo;algorithme de l\u0026rsquo;exercice 7 pour \\(P(x) = x^2 - 5x + 6\\), en présentant les résultats dans un tableau.\nRéponse Initialisation Étape 1 Étape 2 Étape 3 Fin Entrée a 1 1 1 1 1 b -5 -5 -5 -5 -5 c 6 6 6 6 6 Variables X1 2 2 2 X2 3 3 A 1 1 1 1 Sorties écran Exercice 9 : Conversion de base # Pour un entier \\(B \u003e 1\\) et un nombre \\(M\\), la représentation en base \\(B\\) de \\(M\\) s’obtient par division successive : \\(M = B \\times Q_1 + R_1\\), puis \\(Q_1 = B \\times Q_2 + R_2\\), jusqu’à un quotient inférieur à \\(B\\). La représentation est \\(Q_{n-1}R_n\\ldots R_1\\). Si \\(B \u003e 10\\), les chiffres de \\(10\\) à \\(B-1\\) sont notés \\(A, B, C, \\ldots\\) (par exemple, pour \\(B = 16\\), \\(10 = A\\), \\(11 = B\\), etc.).\nÉcrivez un algorithme pour convertir un nombre \\(M\\) dans une base \\(B ≥ 2\\) (\\(B \u003c 17\\)). Affichez un message d’erreur si \\(B \u003c 2\\).\nRéponse Algo base Entrée : Nombre entier positif B // Base Nombre entier positif M // Nombre à convertir Variables : Nombre entier q, r Suite de caractères alphanumériques S Début S = chaîne vide Si B \u0026lt; 2 Alors Afficher « entrez un entier supérieur ou égal à 2 » Sinon q = M Tant que q \u0026gt; 0 r = q - (q ÷ B) × B au cas où r égal à 10 : ajouter A au début de S égal à 11 : ajouter B au début de S égal à 12 : ajouter C au début de S égal à 13 : ajouter D au début de S égal à 14 : ajouter E au début de S égal à 15 : ajouter F au début de S dans tous les autres cas : ajouter r au début de S q = q ÷ B Fin Tant que Fin Si Fin Voici l’équivalent en Python (voir ici) :\ndef f(M, B): s = \u0026#34;\u0026#34; if B \u0026lt; 2: print(\u0026#34;entrez un entier supérieur ou égal à 2\u0026#34;) return q = M while q \u0026gt; 0: r = q - (q // B) * B if r == 10: s = \u0026#34;A\u0026#34; + s elif r == 11: s = \u0026#34;B\u0026#34; + s elif r == 12: s = \u0026#34;C\u0026#34; + s elif r == 13: s = \u0026#34;D\u0026#34; + s elif r == 14: s = \u0026#34;E\u0026#34; + s elif r == 15: s = \u0026#34;F\u0026#34; + s else: s = str(r) + s q = q // B return s Exercice 10 : Tester la parité en base 2 # En utilisant l’algorithme Algo_base, qui retourne la représentation en base \\(B\\) d’un nombre \\(M\\) (\\(S = \\text{Algo\\_base}(B, M)\\)), écrivez un algorithme qui teste la parité d’un nombre \\(M\\) et affiche « pair » ou « impair ».\nRéponse Algo parité Entrée : Nombre entier positif M // Nombre à tester Variables : Suite de caractères alphanumériques S Début S = Algo_base(2, M) Si dernier caractère de S est égal au chiffre 0 Alors Afficher « pair » Sinon Afficher « impair » Fin Si Fin Exercice 11 : Calcul de la factorielle # Écrivez un algorithme qui calcule la factorielle d’un entier positif \\(n\\) (\\(n!\\)).\nSolution Entrée : Entier positif n Variable : Entier fact = 1 Entier i = 1 TANT QUE i \\leq n FAIRE fact = fact \\times i i = i + 1 FIN TANT QUE Retourner fact Exercice 12 : Inverser un tableau # Proposez un algorithme pour inverser un tableau d’entiers de taille quelconque.\nSolution Entrée : Tableau d’entiers T de taille N Variables : Entier i = 0 Entier j = N - 1 TANT QUE i \u0026lt; j FAIRE échanger T[i] et T[j] i = i + 1 j = j - 1 FIN TANT QUE Retourner T Exercice 13 : Compter les voyelles # Écrivez un algorithme qui compte le nombre de voyelles dans une chaîne de caractères donnée.\nSolution Entrée : Chaîne de caractères S Variable : Entier compteur = 0 Entier i = 0 TANT QUE i \u0026lt; longueur de S FAIRE SI S[i] est une voyelle ALORS compteur = compteur + 1 FIN SI i = i + 1 FIN TANT QUE Retourner compteur Exercice 14 : Tester si un entier est un palindrome # Donnez un algorithme pour déterminer si un nombre entier est un palindrome (se lit de la même façon de gauche à droite et de droite à gauche).\nSolution Entrée : Entier positif n Variables : Entier original = n Entier renverse = 0 TANT QUE n \u0026gt; 0 FAIRE renverse = renverse \\times 10 + (n \\bmod 10) n = n // 10 FIN TANT QUE SI original = renverse ALORS Retourner Vrai SINON Retourner Faux FIN SI Exercice 15 : Minimum et maximum d’un tableau # Écrivez un algorithme qui trouve le minimum et le maximum dans un tableau d’entiers.\nSolution Entrée : Tableau d’entiers T de taille N Variables : Entier min = T[0] Entier max = T[0] Entier i = 1 TANT QUE i \u0026lt; N FAIRE SI T[i] \u0026lt; min ALORS min = T[i] FIN SI SI T[i] \u0026gt; max ALORS max = T[i] FIN SI i = i + 1 FIN TANT QUE Retourner min, max Exercice 16 # Expliquez la différence entre la complexité en temps et la complexité en espace d’un algorithme.\nSolution La complexité en temps mesure la quantité d’opérations ou le temps d’exécution d’un algorithme en fonction de la taille des données d’entrée. La complexité en espace mesure la quantité de mémoire supplémentaire nécessaire à l’algorithme pour fonctionner. Un algorithme peut être rapide (faible complexité en temps) mais utiliser beaucoup de mémoire (complexité en espace élevée), ou l’inverse.\nExercice 17 # Quel est le nombre maximal de comparaisons nécessaires pour rechercher un élément dans un tableau non trié de taille \\( n \\) ? Justifiez votre réponse.\nSolution Dans un tableau non trié de taille \\( n \\), il faut au pire comparer l’élément recherché à chaque élément du tableau, soit \\( n \\) comparaisons. Cela correspond à une recherche linéaire, de complexité \\( O(n) \\).\nExercice 18 # Pourquoi la recherche binaire n’est-elle applicable qu’aux tableaux triés ? Quelle est sa complexité en temps ?\nSolution La recherche binaire n’est applicable qu’aux tableaux triés, car elle repose sur le fait que l’on peut éliminer la moitié des éléments à chaque étape en comparant la valeur recherchée à l’élément du milieu. Si le tableau n’est pas trié, on ne peut pas savoir dans quelle moitié chercher. Sa complexité en temps est \\( O(\\log n) \\).\nExercice 19 # Donnez un exemple d’algorithme ayant une complexité en \\( O(n^2) \\) et expliquez pourquoi.\nSolution Un exemple classique est le tri à bulles (bubble sort). Pour chaque élément, on compare avec tous les autres, ce qui fait environ \\( n^2 \\) comparaisons pour un tableau de taille \\( n \\). C’est pourquoi sa complexité est \\( O(n^2) \\).\nExercice 20 # Un algorithme de tri efficace comme le tri fusion (merge sort) a une complexité en \\( O(n \\log n) \\). Expliquez ce que cela signifie et pourquoi c’est plus rapide qu’un tri naïf pour de grands tableaux.\nSolution Une complexité en \\( O(n \\log n) \\) signifie que le nombre d’opérations croît plus vite que linéairement, mais beaucoup moins vite que quadratiquement. Par exemple, le tri fusion (merge sort) divise le tableau en deux à chaque étape (logarithmique) et traite chaque élément à chaque niveau de division (linéaire), d’où le \\( n \\log n \\). Pour de grands tableaux, c’est beaucoup plus rapide qu’un tri naïf en \\( O(n^2) \\).\nExercice 21 # Alan Kay est considéré comme l’un des pères de la programmation orientée objet. Quelles étaient ses motivations principales lorsqu’il a conçu ce paradigme ? En quoi sa vision différait-elle de l’utilisation courante de la programmation orientée objet aujourd’hui ? Résumez brièvement ses objectifs et l’esprit original de la programmation orientée objet selon Kay.\nRéponse Alan Kay a conçu la programmation orientée objet pour faciliter la création de systèmes logiciels modulaires, flexibles et évolutifs, inspirés par la biologie et la communication entre objets autonomes. Son objectif principal était de permettre à chaque « objet » d’être responsable de son propre état et de communiquer avec d’autres objets uniquement via des messages, favorisant ainsi l’encapsulation et l’indépendance des composants.\nPour Kay, la programmation orientée objet devait avant tout encourager l’émergence de systèmes dynamiques, adaptatifs et faciles à modifier, plutôt que de se limiter à la simple hiérarchie de classes et à l’héritage. Il insistait sur l’importance de la communication par messages et sur la capacité à faire évoluer les programmes sans tout réécrire.\nDe nos jours, la programmation orientée objet est souvent réduite à l’organisation du code et des données, alors que la vision originale de Kay mettait l’accent sur la modularité, la flexibilité et l’autonomie des objets. Sa conception visait à rendre la programmation plus naturelle, intuitive et proche du fonctionnement des systèmes vivants.\nExercice 22 # Ole-Johan Dahl et Kristen Nygaard sont les créateurs du premier langage orienté objet, Simula. Quelles étaient leurs motivations principales lors de la création de ce langage ? Expliquez en quoi leur approche a influencé la programmation moderne.\nRéponse Dahl et Nygaard ont conçu Simula pour faciliter la modélisation et la simulation de systèmes complexes, comme des réseaux, des usines ou des processus sociaux. Leur motivation était de représenter chaque entité du système par un « objet » autonome, regroupant données et comportements, afin de refléter la réalité de manière plus naturelle et modulaire.\nIls voulaient permettre l’encapsulation, la réutilisation du code grâce à l’héritage, et la création de structures hiérarchiques. Cette approche a posé les bases de la programmation orientée objet moderne, en rendant la conception de logiciels plus flexible, évolutive et adaptée à la complexité des systèmes réels.\nExercice 23 # Qui est James Gosling et quel a été son rôle dans la création du langage Java ? Quelles étaient les motivations principales derrière la conception de Java ?\nRéponse James Gosling est un informaticien canadien considéré comme le principal créateur du langage Java, développé chez Sun Microsystems dans les années 1990. Son objectif était de concevoir un langage portable, sécurisé, simple et adapté aux systèmes embarqués et aux réseaux. Java devait permettre d’écrire un programme une seule fois et de l’exécuter partout (« Write Once, Run Anywhere »), grâce à la machine virtuelle Java (JVM).\nExercice 24 # Citez trois domaines ou secteurs industriels où Java est largement utilisé aujourd’hui. Expliquez brièvement pourquoi Java est apprécié dans ces contextes.\nRéponse Java est largement utilisé dans :\nLe développement d’applications d’entreprise (banques, assurances, télécommunications), grâce à sa robustesse, sa sécurité et la richesse de ses bibliothèques. Le développement d’applications mobiles (notamment Android), car Java est le langage principal pour Android et bénéficie d’un vaste écosystème. Les systèmes embarqués et l’Internet des objets (IoT), où la portabilité et la fiabilité de Java sont des atouts majeurs. Exercice 25 # Qu’est-ce que la notation de Backus-Naur (BNF) ? À quoi sert-elle en informatique ? Donnez un exemple simple de BNF décrivant la syntaxe d’une expression arithmétique composée de chiffres et de l’opérateur +.\nRéponse La notation de Backus-Naur (BNF) est une méthode formelle pour décrire la syntaxe des langages de programmation et des langages formels. Elle permet de spécifier les règles de formation des expressions valides dans un langage, en utilisant des symboles non terminaux, des symboles terminaux et des règles de production.\nLa BNF est largement utilisée pour définir la grammaire des langages de programmation, des protocoles ou des formats de données.\nExemple de BNF pour une expression arithmétique simple :\n\u0026lt;expression\u0026gt; ::= \u0026lt;chiffre\u0026gt; | \u0026lt;expression\u0026gt; \"+\" \u0026lt;chiffre\u0026gt; \u0026lt;chiffre\u0026gt; ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" Cela décrit une expression composée d’un ou plusieurs chiffres séparés par des +.\nExercice 26 # Mon ordinateur roule à une fréquence de 3 GHz. À tous les cycles, il exécute ses opérations. Quelle distance est-ce que la vitesse de la lumière traverse pendant un cycle ?\nRéponse À 3 GHz, un cycle d’horloge dure :\n1 / 3 000 000 000 = 0,333... nanoseconde (ns) par cycle.\nLa lumière parcourt environ 30 cm (0,3 mètre) en 1 ns. Donc, en 0,333 ns, elle parcourt :\n30 cm × 0,333... ≈ 10 cm.\nRéponse : Pendant un cycle d’horloge à 3 GHz, la lumière parcourt environ 10 centimètres dans le vide.\nExercice 27 # Quelle est la différence entre un kibioctet et un kilo-octet ?\nRéponse Un kilo-octet (ko) correspond à 1 000 octets (selon le système décimal, préfixe SI), tandis qu’un kibioctet (Kio) correspond à 1 024 octets (selon le système binaire, préfixe IEC). Le préfixe « kilo » (k) est utilisé pour les puissances de 10, alors que « kibi » (Ki) est utilisé pour les puissances de 2. Ainsi, 1 Kio = 1 024 octets, 1 ko = 1 000 octets.\nVidéos # Des vidéos sur l’algorithmique et le pseudo-code sont disponibles, comme celles de Loïc \u0026amp; Julien.\nLogiciels # Certains étudiants utilisent des logiciels comme AlgoBox. Cela n’est pas nécessaire, car le pseudo-code doit être écrit dans vos propres mots. Si un logiciel vous aide, utilisez-le, mais vous devriez pouvoir écrire du pseudo-code manuellement, sans outils. C’est l’essence du pseudo-code : il est indépendant des syntaxes et des outils.\n"},{"id":57,"href":"/inf1220-hugo/docs/extra/math/","title":"Rappel mathématique","section":"Autres ressources","content":" Rappel mathématique # Avant de commencer, il est conseillé, pour se familiariser avec certaines notations, de jeter un coup d\u0026rsquo;œil sur le tableau des symboles et abréviations usuels.\n1. Les propositions, les ensembles, les relations et les nombres # Pour aborder les concepts mathématiques fondamentaux, il est essentiel de comprendre les notions de base qui sous-tendent la logique et la théorie des ensembles. Cette section introduit les propositions, les ensembles, les relations et les nombres, en posant les fondations nécessaires à une étude rigoureuse.\n1.1. Les propositions # Une proposition mathématique est un énoncé dont on peut dire sans ambiguïté si elle est vraie ou fausse. Le processus qui consiste à déterminer si une proposition mathématique est vraie ou fausse est l’objet du calcul propositionnel ou calcul des propositions et fait partie de la logique mathématique. Le résultat d’un calcul propositionnel est donc l’attribution d’une valeur de vérité à une proposition.\nAinsi, l\u0026rsquo;énoncé « Le cours INF1220 figure parmi les cours dispensés à la TELUQ au trimestre d’hiver 2021 » est une proposition mathématique et sa valeur de vérité est « vrai ». La proposition « Le cours INF1220 est mon meilleur cours » n\u0026rsquo;est pas une proposition mathématique. Dans notre contexte, quand nous parlons de proposition, nous parlons de proposition mathématique.\n1.1.1. Table des valeurs de vérités des propositions # Tableau 1 : Table de vérités et connecteurs logiques\n\\( p \\) \\( q \\) \\( \\neg p \\) \\( p \\vee q \\) \\( p \\oplus q \\) \\( p \\wedge q \\) \\( p \\Rightarrow q \\) \\( p \\Leftrightarrow q \\) V V F V F V V V V F F V V F F F F V V V V F V F F F V F F F V V 1.2. Les ensembles # Un ensemble est une collection d’objets. Si on appelle \\( E \\) cette collection, alors pour chacun de ces objets, on peut affirmer qu’il appartient à \\( E \\). On peut déterminer \\( E \\) en énumérant ses éléments, par exemple \\( E = \\{ o_1, o_2, \\dots \\} \\), où \\( o_i \\) est un des objets de la collection (et où on admet que pour tout objet de la collection, il y a un \\( o_i \\) qui lui soit identique). On dit alors qu’on a défini \\( E \\) en extension. Un objet \\( o_i \\) est appelé un élément de \\( E \\). On note \\( o_i \\in E \\).\nÉtant donné un objet arbitraire, c’est-à-dire une chose quelconque, on est capable de dire si oui ou non cette chose appartient à \\( E \\). Si nous notons la chose en question \\( o \\) et qu’elle n’appartient pas à \\( E \\), nous traduisons cela par \\( o \\notin E \\).\nUne autre façon de déterminer un ensemble est de donner une propriété qui caractérise ses éléments. Par exemple, la collection de toutes les personnes qui sont inscrites à la TELUQ pour suivre le cours INF1220 pour le trimestre d’hiver 2021 à la date du 1er mars 2021 est un ensemble. Nous pouvons le noter \\( T \\). On convient dans ce cas d’écrire \\( T = \\{ o \\mid o \\text{~est~inscrit} \\} \\). Le symbole \\( \\mid \\) se lit « tel que ». « Être inscrit à la TELUQ pour suivre le cours INF1220 pour le trimestre d’hiver 2021 à la date du 1er mars 2021 » est la propriété caractéristique de l’ensemble \\( T \\) (ou des éléments de cet ensemble).\nLes nombres entiers positifs forment un ensemble ; c’est l’ensemble des entiers naturels. On le note \\( \\mathbb{N} \\). \\( \\mathbb{N} = \\{ 0, 1, \\dots \\} \\).\nUn ensemble peut être fini, comme l’ensemble \\( T \\). Un ensemble peut être infini, comme l’ensemble \\( \\mathbb{N} \\). On admet qu’il existe un ensemble qui ne contient aucun élément. On appelle cet ensemble, ensemble vide. On le note couramment \\( \\{ \\} \\) ou \\( \\emptyset \\). Un singleton est un ensemble qui a un seul élément. On admet aussi que si l’on ajoute un élément d’un ensemble \\( E \\) à ce même ensemble \\( E \\), on ne change pas l’ensemble \\( E \\). On considère de ce fait, qu’un ensemble est donné par une collection distincte des objets qui le constituent, c’est-à-dire que ses éléments sont distincts. Le nombre des éléments d’un ensemble est appelé le cardinal de cet ensemble. Le cardinal de l’ensemble vide est par définition 0.\nDeux ensembles sont égaux s’ils ont exactement les mêmes éléments ou si on peut prouver qu’ils ont exactement les mêmes éléments. Par exemple, \\( V = \\{ o \\mid o \\text{~est~inscrit} \\} \\) est un ensemble vide. En effet, il n’y a aucune inscription pour le cours INF1220 à la TELUQ à cette date. Cependant, dire que cet ensemble est vide ne signifie pas qu’il n’existe pas. Il existe, mais il n’a aucun élément. \\( V = \\{ \\} \\).\n1.2.1. Opération sur les ensembles # Soient deux ensembles \\( A \\) et \\( B \\). L’intersection de \\( A \\) et \\( B \\) est un ensemble formé par les éléments qui appartiennent à la fois à \\( A \\) et à \\( B \\). On le note \\( A \\cap B \\). L\u0026rsquo;union de \\( A \\) et de \\( B \\) est un ensemble formé par les éléments qui appartiennent à \\( A \\) ou qui appartiennent à \\( B \\). On le note \\( A \\cup B \\). La différence symétrique est un ensemble formé par les éléments de \\( A \\) qui n’appartiennent pas à \\( B \\). On le note \\( A \\setminus B \\). Le produit cartésien de \\( A \\) et de \\( B \\) est un ensemble formé de couples \\( (a, b) \\) tels que \\( a \\in A \\) et \\( b \\in B \\). On le note \\( A \\times B \\).\n1.3. Relation binaire # Une relation binaire \\( R \\) est un ensemble défini par la donnée de deux ensembles \\( A \\) et \\( B \\) et d’une règle qui permet d’associer certains éléments de \\( A \\) à certains éléments de \\( B \\). \\( R \\) est un sous-ensemble du produit cartésien \\( A \\times B \\) de \\( A \\) et de \\( B \\). La règle associée à une relation est aussi appelée lien verbal. Le lien verbal est une proposition. On peut définir une relation en compréhension par \\( R = \\{ (a, b) \\in A \\times B \\mid \\text{le lien verbal soit vérifié pour } a \\text{ et } b \\} \\). Au lieu de noter \\( (a, b) \\in R \\), on note simplement \\( a R b \\) et on lit \\( a \\) en relation avec \\( b \\). \\( b \\) est l’image de \\( a \\) par la relation \\( R \\) et \\( a \\) est l’antécédent de \\( b \\) pour la relation \\( R \\).\n1.3.1. Propriété d’une relation binaire # Soit \\( R \\) une relation binaire. Lorsque les ensembles de départ et d’arrivée sont identiques, c’est-à-dire tous égaux à \\( A \\), on dit simplement que \\( R \\) est une relation définie sur \\( A \\).\nSoit \\( A \\) un ensemble et \\( R \\) une relation binaire définie sur \\( A \\). \\( R \\) peut avoir les propriétés suivantes :\n1.3.1.1. Réflexivité # \\( R \\) est réflexive si \\( \\forall a \\in A, a R a \\).\nExemple : la relation de divisibilité \\( R \\) dans \\( \\mathbb{N} \\) (\\( a R b \\) ssi \\( a \\) divise \\( b \\)) est réflexive.\nQuestion : donnez un autre exemple de relation réflexive.\nRéponse La relation d'ordre naturel \\( R \\) sur \\( \\mathbb{N} \\) définie par \\( a R b \\) ssi \\( a \\leq b \\) est réflexive. 1.3.1.2. Symétrie # \\( R \\) est symétrique ssi \\( \\forall a \\in A, \\forall b \\in B, a R b \\Rightarrow b R a \\).\nExemple : soit \\( m \\in \\mathbb{N}^* \\). La relation \\( R \\) définie sur \\( \\mathbb{N} \\) par \\( a R b \\) ssi \\( a \\) et \\( b \\) ont le même reste dans la division euclidienne par \\( m \\) est symétrique.\n1.3.1.3. Transitivité # \\( R \\) est transitive ssi pour \\( a, b, c \\in A \\), \\( a R b \\) et \\( b R c \\Rightarrow a R c \\). La relation d’ordre naturel sur \\( \\mathbb{N} \\) est transitive.\nQuestion : donner un autre exemple de relation transitive.\nRéponse La relation de divisibilité \\( R \\) dans \\( \\mathbb{N} \\) définie par \\( a R b \\) ssi \\( a \\) divise \\( b \\) est transitive. 1.3.1.4. Antisymétrie # \\( R \\) est antisymétrique ssi pour \\( a, b \\in A \\), \\( a R b \\) et \\( b R a \\Rightarrow a = b \\). Par exemple, soit \\( E \\) un ensemble, et \\( P(E) \\) l’ensemble des parties de \\( E \\). La relation \\( \\subseteq \\) sur \\( P(E) \\) (définie par \\( A \\) en relation avec \\( B \\) ssi \\( A \\subseteq B \\)) est une relation antisymétrique.\nQuestion : donnez un autre exemple de relation antisymétrique.\nRéponse La relation \\( R \\) de divisibilité dans \\( \\mathbb{N} \\) définie par \\( a R b \\) ssi \\( a \\) divise \\( b \\) est antisymétrique. 1.3.2. Relation d’équivalence # Soit \\( R \\) une relation définie sur un ensemble \\( A \\). \\( R \\) est une relation d’équivalence si \\( R \\) est à la fois réflexive, symétrique et transitive. Soit \\( m \\in \\mathbb{N}^* \\). La relation \\( R \\) définie sur \\( \\mathbb{Z} \\) par \\( a R b \\) ssi \\( a \\) et \\( b \\) ont le même reste dans la division euclidienne par \\( m \\) est une relation d’équivalence.\n1.3.3. Relation d’ordre # Soit \\( R \\) une relation définie sur un ensemble \\( A \\). \\( R \\) est une relation d’ordre ssi elle est à la fois réflexive, transitive et antisymétrique.\nPar exemple, soit \\( E \\) un ensemble, et \\( P(E) \\) l’ensemble des parties de \\( E \\). La relation \\( \\subseteq \\) sur \\( P(E) \\) est une relation d\u0026rsquo;ordre.\nSoit \\( R \\) une relation d’ordre sur \\( A \\), \\( a \\) et \\( b \\) sont comparables ssi \\( a R b \\) ou \\( b R a \\). Si \\( \\forall a, b \\in A \\), \\( a \\) et \\( b \\) sont toujours comparables, on dit que \\( R \\) est une relation d’ordre total. S’il existe \\( a, b \\) tels que \\( a \\) et \\( b \\) ne sont pas comparables, \\( R \\) est une relation d’ordre partiel. Exemple, la relation définie sur \\( \\mathbb{Z} \\) par \\( a R b \\) si \\( a \\) divise \\( b \\) (division euclidienne) est une relation d’ordre partiel car on ne peut pas comparer 2 et 5.\nQuestion : donner un autre exemple de relation d’ordre partiel.\nRéponse Si \\( E \\) est un ensemble ayant au moins deux éléments \\( a \\) et \\( b \\), la relation \\( \\subseteq \\) sur \\( P(E) \\) (définie par \\( A \\) en relation avec \\( B \\) ssi \\( A \\subseteq B \\)) est une relation d'ordre partiel car \\( \\{a\\} \\) et \\( \\{b\\} \\) sont deux éléments de \\( P(E) \\) qui ne sont pas comparables par \\( \\subseteq \\). La relation d’ordre définie sur \\( \\mathbb{Z} \\) par \\( a R b \\) si \\( a \\leq b \\) est une relation d’ordre total.\nUne fonction est une relation où chaque élément de l’ensemble de départ a au plus une image dans l’ensemble d’arrivée. Dans ce cas, si \\( A \\) est l’ensemble de départ, \\( B \\) l’ensemble d’arrivée, et si on note \\( f \\) la relation, on appelle domaine de \\( f \\) (noté \\( \\text{Dom}(f) \\) ou simplement \\( D_f \\)) l’ensemble des éléments de \\( A \\) ayant une image par \\( f \\). De même, on appelle image de \\( f \\) et on note \\( \\text{Im}(f) \\) l’ensemble des éléments de \\( B \\) ayant au moins un antécédent dans \\( A \\).\n1.3.3.1. Ordre lexicographique # Soit \\( V \\) un ensemble de symboles et \\( L \\) un ensemble défini par :\nsi \\( v \\in V \\), alors \\( v \\in L \\); si \\( l \\in L \\) et \\( e \\in L \\), alors \\( el \\) et \\( le \\) appartiennent à \\( L \\). \\( V \\) est appelé vocabulaire et \\( L \\) est l’ensemble des mots construits sur ce vocabulaire. Un mot \\( l \\) de \\( L \\) s’écrit \\( v_n, \\dots, v_0 \\), où \\( v_i \\in V \\). On peut remarquer que si \\( V \\) est l’ensemble des 26 lettres de l’alphabet français, alors \\( L \\) est l’ensemble des mots possibles de la langue française (si on assimile toutes les voyelles accentuées à leur équivalent non accentué, c’est-à-dire qu’on laisse tomber les accents) ; en fait, \\( L \\) contient tous les mots de la langue française, mais aussi des choses comme \\( rrrrrrrrr \\) sont des mots de \\( L \\).\nQuestion : que vaut \\( L \\) si \\( V \\) est l’ensemble des chiffres de 0 à 9 ?\nRéponse Voir plus bas. On suppose que \\( V \\) est muni d’une relation d’ordre total notée \\( \\leq \\) (avec l\u0026rsquo;ordre strict noté \\( \u003c \\)). Soit \\( a \\) et \\( b \\) deux éléments de \\( L \\) tels que \\( a = a_m, \\dots, a_0 \\) et \\( b = b_n, \\dots, b_0 \\). \\( \\forall i \\in \\mathbb{N} \\), \\( a_i, b_i \\in V \\). On pose \\( p = \\min(m, n) \\) le plus petit des deux entiers \\( m \\) et \\( n \\). On définit sur \\( L \\) la relation \\( R \\) par \\( a R b \\) ssi\n\\[ (a_m \u003c b_n) \\text{ ou } (a_m = b_n \\text{ et } a_{m-1} \u003c b_{n-1}) \\text{ ou } (a_m = b_n \\text{ et } a_{m-1} = b_{n-1} \\text{ et } a_{m-2} \u003c b_{n-2}) \\text{ ou } \\dots \\]\\( R \\) est une relation d’ordre totale sur \\( L \\). \\( R \\), qui est aussi notée \\( \\leq \\) et prolonge la relation \\( \\leq \\) de \\( V \\), est appelée l’ordre lexicographique sur \\( L \\). Si \\( V \\) est l\u0026rsquo;ensemble des chiffres de 0 à 9, l\u0026rsquo;ensemble \\( L \\) contient l\u0026rsquo;ensemble des entiers naturels \\( \\mathbb{N} \\). Il faut remarquer que sur cet ensemble \\( L \\) ordonné par \\( \\leq \\), 0 est différent par exemple de 00, ce qui n\u0026rsquo;est pas le cas dans l\u0026rsquo;ensemble \\( \\mathbb{N} \\) muni de la relation d\u0026rsquo;ordre \u0026ldquo;naturelle\u0026rdquo; (la relation inférieure ou égale).\n1.4. L’ensemble des entiers naturels \\( \\mathbb{N} \\) et les autres ensembles de nombres # Il faut noter que les entiers naturels forment un ensemble particulier. Pour illustrer le lien étroit qu’il y a entre la théorie des ensembles et les entiers naturels, il faut savoir qu’on peut construire l\u0026rsquo;ensemble des entiers naturels en procédant comme suit : \\( 0 = \\emptyset \\), \\( 1 = \\text{successeur de } 0 \\), c\u0026rsquo;est-à-dire \\( 1 = \\{0\\} \\), \\( 2 = \\text{successeur de } 1 \\), c\u0026rsquo;est-à-dire \\( 2 = \\{0, 1\\} \\), etc.\nCommençons par voir de façon générale les lois de composition sur un ensemble.\n1.4.1. Lois de composition dans un ensemble # Soit \\( E \\) et \\( G \\) deux ensembles. Une loi de composition \\( T \\) dans l’ensemble \\( E \\) est une fonction de \\( E \\times E \\) vers \\( G \\) qui à tout couple \\( (a, b) \\) d\u0026rsquo;éléments de \\( E \\) associe un unique élément \\( c \\) de \\( G \\) tel que \\( c = a T b \\).\nSoit \\( E \\) un ensemble muni d\u0026rsquo;une loi \\( T \\).\n1.4.1.1. Ensemble stable par une loi # Si \\( \\forall a, b \\in E \\), \\( a T b \\in E \\), alors la loi \\( T \\) est interne sur \\( E \\). On dit aussi que \\( E \\) est stable par la loi \\( T \\). On note \\( (E, T) \\) pour signifier que \\( E \\) est muni de la loi interne \\( T \\).\nPar exemple, l’addition est interne à l’ensemble des entiers naturels \\( \\mathbb{N} \\).\n1.4.1.2. Élément neutre pour une loi # Un élément \\( e \\) de \\( E \\) est un élément neutre pour \\( T \\) ssi pour tout élément \\( a \\) de \\( E \\), \\( a T e = e T a = a \\).\nExemple : 0 est l\u0026rsquo;élément neutre pour l\u0026rsquo;addition \\( + \\) sur l\u0026rsquo;ensemble \\( \\mathbb{N} \\) des entiers naturels : pour tout entier naturel \\( n \\), on a \\( n + 0 = 0 + n = n \\).\nIl en est de même pour 1 qui est l\u0026rsquo;élément neutre pour la multiplication \\( \\times \\) sur l\u0026rsquo;ensemble \\( \\mathbb{N} \\) des entiers naturels : pour tout entier naturel \\( n \\), on a \\( n \\times 1 = 1 \\times n = n \\).\nQuestion : existe-t-il un élément neutre pour la division \\( \\div \\) sur l\u0026rsquo;ensemble \\( \\mathbb{N} \\) des entiers naturels ?\nRéponse Non, car malgré que pour tout \\( n \\) élément de \\( \\mathbb{N} \\) on ait \\( n \\div 1 = n \\), on n'a \\( 1 \\div n = n \\) que si \\( n \\) vaut 1. Soit \\( (E, T) \\) un ensemble \\( E \\) muni d’une loi interne \\( T \\).\nOn a les propriétés suivantes :\n1.4.1.3. Associativité # La loi \\( T \\) est associative si pour tous éléments \\( a, b \\) et \\( c \\) de \\( E \\), \\( (a T b) T c = a T (b T c) = a T b T c \\).\nExemple : l\u0026rsquo;addition \\( + \\) est associative sur \\( \\mathbb{N} \\).\n1.4.1.4. Commutativité # La loi \\( T \\) est commutative si pour tous éléments \\( a \\) et \\( b \\) de \\( E \\), \\( a T b = b T a \\).\nExemple : l\u0026rsquo;addition \\( + \\) est commutative sur \\( \\mathbb{N} \\).\n1.4.1.5. Symétrie # Deux éléments \\( a \\) et \\( b \\) sont symétriques pour \\( T \\) si \\( a T b = b T a = e \\) (\\( e \\) étant l\u0026rsquo;élément neutre de \\( E \\) pour la loi \\( T \\)). Si tout élément de \\( E \\) admet un symétrique pour la loi \\( T \\), on dit que la loi \\( T \\) est symétrisable.\n1.4.1.6. Distributivité # \\( T \\) est distributive à gauche par rapport à une autre loi \\( \\perp \\) si pour tous éléments \\( a, b, c \\) de \\( E \\),\n\\[ a T (b \\perp c) = (a T b) \\perp (a T c) \\]\\( T \\) est distributive à droite par rapport à une autre loi \\( \\perp \\) si pour tous éléments \\( a, b, c \\) de \\( E \\),\n\\[ (b \\perp c) T a = (b T a) \\perp (c T a) \\]\\( T \\) est distributive pour \\( \\perp \\) si et seulement si elle est distributive à gauche et à droite par rapport à \\( \\perp \\).\nLa multiplication \\( \\times \\) dans \\( \\mathbb{N} \\) est distributive par rapport à l\u0026rsquo;addition \\( + \\) dans \\( \\mathbb{N} \\).\nDans la suite, on appellera opération les lois de composition dans l’ensemble \\( \\mathbb{N} \\) des entiers naturels. On note \\( \\mathbb{N}^* \\) l’ensemble \\( \\mathbb{N} \\) privée du singleton \\( \\{0\\} \\). \\( \\mathbb{N}^* = \\mathbb{N} \\setminus \\{0\\} \\).\nL’addition \\( + \\) et la multiplication \\( \\times \\) usuelles sont des opérations internes sur \\( \\mathbb{N} \\). C’est-à-dire que \\( \\mathbb{N} \\) est stable par chacune de ces opérations.\nLa soustraction \\( - \\) et la division \\( \\div \\) usuelles ne sont pas des opérations internes dans \\( \\mathbb{N} \\). C’est le besoin d’avoir des ensembles stables pour ces opérations qui ont guidé le développement de nouveaux ensembles de nombres. Ainsi, l’ensemble des entiers rationnels (termes que nous privilégions à entiers relatifs) \\( \\mathbb{Z} \\) est construit par symétrisation de \\( \\mathbb{N} \\); c’est-à-dire que \\( \\mathbb{Z} \\) est construit de telle sorte que le symétrique par \\( + \\) d’un entier naturel \\( n \\) soit dans \\( \\mathbb{Z} \\). \\( \\mathbb{Q} \\), l’ensemble des nombres rationnels, est construit sur la base d’une relation d’équivalence définie sur \\( \\mathbb{Z} \\) par \\( (a, b) R (c, d) \\) ssi \\( a \\times d = b \\times c \\); on note \\( a / b = c / d \\). De façon générale, si \\( x \\) et \\( y \\) sont deux entiers rationnels, \\( x / y \\) définit un nombre rationnel si \\( y \\neq 0 \\); \\( x \\) est le numérateur et \\( y \\) est le dénominateur.\nSoit \\( x / y \\) un nombre rationnel. Si \\( x / y \\) peut s’écrire sous la forme \\( a / b \\) où \\( a \\) est un entier rationnel et \\( b \\) une puissance de 10 (\\( \\exists k \\in \\mathbb{N} \\) tel que \\( b = 10^k \\)), alors \\( x / y \\) est un nombre décimal. On note \\( \\mathbb{D} \\) l\u0026rsquo;ensemble des nombres décimaux.\nDisposant de \\( \\mathbb{Q} \\), on peut construire l’ensemble des nombres réels en utilisant les coupures de \\( \\mathbb{Q} \\), notion due à Cantor et Dedekind. Par exemple, soit \\( C_1 = \\mathbb{Q}^- \\cup \\{ a \\in \\mathbb{Q}^+ \\mid a^2 \u003c 2 \\} \\) et \\( C_2 = \\{ a \\in \\mathbb{Q}^+ \\mid a^2 \u003e 2 \\} \\). \\( C_1 \\) et \\( C_2 \\) sont deux coupures de \\( \\mathbb{Q} \\) qui définissent le nombre \\( \\sqrt{2} \\).\n\\[ \\sqrt{2} \\notin \\mathbb{Q} \\text{ et } \\sqrt{2} \\in \\mathbb{R}. \\]On peut, avec cette méthode de coupure, définir n\u0026rsquo;importe quel nombre réel. On pose souvent \\( \\mathbb{I} = \\mathbb{R} \\setminus \\mathbb{Q} \\). On a les inclusions suivantes :\n\\[ \\mathbb{N} \\subset \\mathbb{Z} \\subset \\mathbb{D} \\subset \\mathbb{Q} \\subset \\mathbb{R}. \\]Soit \\( a \\in \\mathbb{Z} \\) et \\( b \\in \\mathbb{Z}^* \\). Il existe un unique couple d’entiers rationnels \\( (q, r) \\in \\mathbb{Z} \\times \\mathbb{N} \\) tel que \\( a = b \\times q + r \\) avec \\( 0 \\leq r \u003c |b| \\). On dit dans ces conditions que \\( q \\) est le quotient et \\( r \\) est le reste de la division euclidienne de \\( a \\) par \\( b \\); \\( a \\) est le dividende et \\( b \\) est le diviseur. On peut restreindre cette définition à \\( \\mathbb{N} \\) en remplaçant \\( \\mathbb{Z} \\) par \\( \\mathbb{N} \\). On parle alors de division euclidienne dans \\( \\mathbb{N} \\). On dit que \\( b \\) divise \\( a \\) ou que \\( b \\) est un diviseur de \\( a \\) lorsque \\( r \\) vaut 0.\n1.4.1.6. Nombre pair / impair # Soit \\( n \\in \\mathbb{Z} \\). \\( n \\) est un nombre pair ssi \\( n \\) est divisible par 2. 0 est un nombre pair. Un nombre qui n\u0026rsquo;est pas pair est impair. On note parfois \\( 2\\mathbb{Z} \\) (respectivement \\( 2\\mathbb{Z} + 1 \\)) l\u0026rsquo;ensemble des nombres entiers rationnels pairs (respectivement impairs).\nRemarques : si on remplace dans cette définition \\( \\mathbb{Z} \\) par \\( \\mathbb{N} \\), alors on obtient qu’un entier naturel \\( n \\in \\mathbb{N} \\) est pair ssi \\( n \\) est divisible par 2. Les entiers naturels pairs sont ceux dont le chiffre des unités est pair. Les entiers naturels impairs sont ceux dont le chiffre des unités est impair.\n1.4.1.7. Nombre premier # Soit \\( n \\in \\mathbb{Z} \\). \\( n \\) est un nombre premier ssi \\( n \\) a exactement quatre diviseurs : \\( -1, 1, -n \\) et \\( n \\). 0 et 1 ne sont pas des nombres premiers. 2 est un nombre premier.\nRemarque : si on remplace dans cette définition \\( \\mathbb{Z} \\) par \\( \\mathbb{N} \\), alors on obtient qu’un entier naturel \\( n \\in \\mathbb{N} \\) est premier ssi \\( n \\) a exactement deux diviseurs : 1 et \\( n \\).\n1.4.1.8. Grammaire du nombre # Soit \\( V_N = \\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\} \\). On peut générer les entiers naturels selon la règle suivante :\nTout élément de \\( V_N \\) est un nombre entier naturel. Si \\( a \\) et \\( b \\) sont des nombres entiers naturels, alors \\( ab \\) est un nombre entier naturel si \\( a \\neq 0 \\). Les éléments de \\( V_N \\) sont aussi appelés les chiffres.\n\\[ V_Z = V_N \\cup \\{-, +\\} \\] Tout entier naturel est un entier rationnel. Si \\( a \\) est un entier naturel, \\( -a \\) et \\( +a \\) sont des entiers rationnels. \\[ V_Q = V_Z \\cup \\{/, ,\\} \\] Tout entier rationnel est un nombre rationnel. Si \\( a \\) et \\( b \\) sont des entiers rationnels, \\( a, b \\) est un nombre rationnel ; de plus, si \\( b \\neq 0 \\), \\( \\frac{a}{b} \\) est un nombre rationnel. Si \\( a \\) et \\( b \\) sont des nombres rationnels, \\( \\frac{a}{b} \\) est aussi un nombre rationnel si \\( b \\neq 0 \\). Les opérations \\( + \\) et \\( \\times \\) sont associatives et commutatives. Les opérations \\( \\times \\) et \\( \\div \\) sont distributives par rapport aux opérations \\( - \\) et \\( + \\).\nLors de la simplification des expressions algébriques, il faut aller de la gauche vers la droite, et en calculant d’abord toutes les expressions entre parenthèses \\( () \\) ou tout autre signe qui tient lieu de parenthèses (ça peut être des crochets \\( [] \\) ou plus rarement des accolades \\( \\{\\} \\)). Les parenthèses ont donc toujours la plus grande priorité.\nLe tableau ci-dessous donne les règles de priorité.\nRègles de priorité Opérations Abréviations 1. L’intérieur des parenthèses doit être calculé. Lorsqu’il y a parenthèses, crochets et accolades, il faut simplifier prioritairement l’opération en débutant par les parenthèses intérieures : solutionner de l’intérieur vers l’extérieur. Parenthèses (ou assimilées) P 2. Les nombres affectés d’exposants doivent être évalués. Exponentiation E 3. Les divisions et les multiplications doivent être calculées. Ces deux opérations ont la même priorité. Elles sont évaluées dans l’ordre où elles apparaissent dans l’expression numérique établie, en se référant à la convention d’écriture indiquée plus loin. Divisions\nMultiplications D\nM 4. Finalement, les additions et les soustractions doivent être calculées. Ces deux opérations ont la même priorité. Elles sont évaluées à partir de la gauche de l’expression numérique en allant vers la droite (convention d’écriture). Additions\nSoustractions A\nS On peut se rappeler cet ordre de priorité avec l\u0026rsquo;acronyme mnémonique PEDMAS.\nDans l\u0026rsquo;ensemble \\( \\mathbb{R} \\) des nombres réels, deux éléments de \\( \\mathbb{R} \\) symétriques pour l\u0026rsquo;addition sont plus communément appelés opposés. Pour la multiplication, on parle d\u0026rsquo;inverses.\n2. Notion de variables et fonctions élémentaires sur les nombres # Pour aborder la notion de variable et les fonctions élémentaires sur les nombres, il est essentiel de comprendre le cadre des fonctions mathématiques. Une fonction est une relation qui associe à chaque élément d’un ensemble de départ, appelé domaine, un unique élément d’un ensemble d’arrivée, appelé codomaine. Les nombres, qu’ils soient entiers, rationnels ou réels, forment souvent ces ensembles. Les fonctions élémentaires, comme les fonctions linéaires, polynomiales ou trigonométriques, sont construites à partir d’opérations simples (addition, multiplication, etc.) et jouent un rôle fondamental en mathématiques. L’introduction de la notion de variable permet de généraliser et de formaliser la description de ces fonctions, en représentant de manière abstraite les éléments du domaine. Ce formalisme est au cœur de l’étude des fonctions et de leurs propriétés.\n2.1. La notion de variable # Soit \\( E \\) et \\( F \\) deux ensembles, \\( f \\) une fonction de \\( E \\) vers \\( F \\). En général, \\( f \\) est donnée par une expression qui permet de déterminer l’image d’un élément \\( e \\) quelconque de \\( E \\). Cela se fait en remplaçant dans l’expression de \\( f \\) certains symboles par l’élément \\( e \\) en question. Supposons par exemple \\( E = F = \\mathbb{R} \\) et \\( f \\) la fonction qui à un nombre réel associe son produit par une constante \\( a \\) et ajoute à ce produit une constante \\( b \\). On a par exemple \\( f(2) = a \\times 2 + b \\). Ce qui change dans le calcul de l’image d’un élément quelconque, ce ne sont pas les constantes \\( a \\) et \\( b \\) qui sont fixées une fois pour toutes pour la fonction \\( f \\), mais la valeur de l’élément. Il est commode de représenter cet état de chose par un symbole auquel on substitue l’élément quand celui-ci devient connu. Ce symbole est donc la variable associée à la fonction. Dans le cas de la fonction \\( f \\) ci-dessus, on écrira \\( f(t) = a \\times t + b \\). Et \\( t \\) est la variable dans cette expression. Cette variable représente les éléments de l’ensemble de départ. C’est elle qui varie quand on passe d’un élément à un autre, on dit qu’elle parcourt l’ensemble de départ, ou plus exactement le domaine de définition de la fonction. Il est à noter que ce formalisme permet de décrire \\( f \\) et de connaître ses propriétés mathématiques sans avoir besoin de calculer l’image de chaque élément de \\( E \\).\nCette notion de variable en mathématique est assez proche de la notion de variable en informatique, tout comme l’est aussi la notion de fonction. Ainsi, on peut remarquer que donner une valeur à une variable (en mathématique) est similaire à affecter une valeur à une variable (en informatique).\nIl convient aussi de bien remarquer que, même sans explicitement donner des valeurs à \\( a \\) et \\( b \\) dans la fonction \\( f \\) ci-dessus, nous savons que ces symboles représentent des constantes. Mais pour calculer la valeur (réelle) de l’image par \\( f \\) d’un nombre réel, nous avons nécessairement besoin, à ce moment-là, de connaître les valeurs de ces symboles qui sont constantes et ne changeront donc plus une fois fixées. Là encore, on peut remarquer que cette notion de constante en mathématique est assez proche de la notion de constante en informatique.\n2.2. Fonctions numériques élémentaires usuelles # Tableau 3 : Fonctions numériques élémentaires usuelles\nNom Expression Principales propriétés Exemples d\u0026rsquo;expressions Fonction puissance \\( f_a(x) = x^a \\) Partout où \\( f_a \\) et \\( f_b \\) ont à la fois un sens et sont à la fois définies, on a \\( f_{a+b} = f_a \\times f_b \\).\nSi \\( a \\in \\mathbb{N} \\), \\( f_a \\) est définie sur \\( \\mathbb{R} \\).\nSi \\( a \\in \\mathbb{Z} \\), et \\( a \u003c 0 \\), \\( f_a \\) est définie sur \\( \\mathbb{R}^* \\).\nSi \\( a \\in \\mathbb{Q} \\), il faut distinguer deux cas :\n- Si \\( a = p/q \\) avec \\( q \\) pair, alors \\( f_a \\) est définie sur \\( \\mathbb{R}^+ \\) si \\( a \\geq 0 \\) et sur \\( \\mathbb{R}^{*+} \\) si \\( a \u003c 0 \\).\n- Si \\( a = p/q \\) avec \\( q \\) impair, alors \\( f_a \\) est définie sur \\( \\mathbb{R} \\) si \\( a \\geq 0 \\) et sur \\( \\mathbb{R}^* \\) si \\( a \u003c 0 \\).\nPour tout autre cas, \\( f_a \\) n’a de sens que si \\( a \\geq 0 \\) et n’est définie que sur \\( \\mathbb{R}^{*+} \\); on a alors \\( f(x) = e^{a \\ln x} \\). \\( f(x) = x^4 \\)\n\\( f(x) = x^{1/3} \\)\n\\( f(x) = x^{1/2} \\). Fonction exponentielle \\( f(x) = e^x \\) \\( f(x) \\times f(y) = f(x + y) \\). \\( f \\) est définie sur \\( \\mathbb{R} \\). Fonction exponentielle de base \\( a \\) \\( f_a(x) = a^x \\) \\( f_a \\) n’a de sens que si \\( a \u003e 0 \\). On a alors \\( f_a(x) \\times f_a(y) = f_a(x + y) \\) et \\( f_a \\) est définie sur \\( \\mathbb{R} \\). \\( f(x) = 4^x \\) Fonction logarithme \\( f(x) = \\ln(x) \\) \\( f(x \\times y) = f(x) + f(y) \\). \\( f \\) est définie sur \\( \\mathbb{R}^{*+} \\). Fonction logarithme de base \\( a \\) \\( f_a(x) = \\frac{\\ln(x)}{\\ln(a)} \\) \\( f_a \\) a un sens ssi \\( a \u003e 1 \\). Si \\( a = 10 \\), \\( f_a \\) est le logarithme décimal, et noté simplement \\( \\log \\). \\( f_a \\) est définie sur \\( \\mathbb{R}^{*+} \\) là où elle a un sens (\\( a \u003e 1 \\)). On a \\( f_a(x \\times y) = f_a(x) + f_a(y) \\). 2.3. Suites et séries numériques réelles # Une suite numérique réelle est une application \\( u : \\mathbb{N} \\to \\mathbb{R} \\), \\( n \\mapsto u(n) \\). On note souvent \\( u(n) \\), l\u0026rsquo;image par \\( n \\) de \\( u \\), plus simplement \\( u_n \\). La suite \\( u \\) est souvent notée \\( (u_n)_{n \\in \\mathbb{N}} \\).\nLe terme \\( u_n \\) s\u0026rsquo;appelle le terme général de la suite. Il arrive quelquefois qu\u0026rsquo;une suite soit définie seulement sur une partie de \\( \\mathbb{N} \\). Dans ce cas, on considère qu\u0026rsquo;elle est définie partout sur \\( \\mathbb{N} \\) et qu\u0026rsquo;elle est nulle pour les termes pour lesquels elle n\u0026rsquo;est pas explicitement définie. Par exemple, si on considère la suite \\( u \\) définie par \\( u_n = 1/n \\) pour \\( n \u003e 0 \\) sans d\u0026rsquo;autres précisions, on peut toujours supposer que \\( u_0 = 0 \\). Une suite n\u0026rsquo;est intéressante que s\u0026rsquo;il y a une façon de déterminer, pour un entier \\( n \\) quelconque, le terme \\( u_n \\) de la suite; on parle alors de suite logique. Une suite logique peut être donnée par une expression de \\( u_n \\) en fonction de \\( n \\); \\( u_n = f(n) \\) où \\( f \\) est une fonction avec \\( D_f = \\mathbb{N} \\). Une suite logique peut être donnée par une relation entre les termes de la suite. Par exemple, \\( u_n \\) peut être une fonction de \\( u_{n-1} \\); \\( u_n = f(u_{n-1}) \\) où \\( f \\) est une fonction et il y a au moins un terme de la suite connu (il existe \\( n_0 \\) tel que \\( u_{n_0} \\) soit connu); dans ce cas, on parle de suite récurrente.\nUn exemple de suite est (suite de Fibonacci) \\( u_0 = 0 \\), \\( u_1 = 1 \\) et \\( u_n = u_{n-1} + u_{n-2} \\) pour \\( n \\geq 2 \\).\nSoit \\( (u_n)_{n \\in \\mathbb{N}} \\) une suite. On appelle série numérique réelle de terme général \\( u_n \\), que l\u0026rsquo;on note \\( \\sum u_n \\), la suite des sommes partielles \\( (S_n)_{n \\in \\mathbb{N}} \\), où pour tout \\( n \\in \\mathbb{N} \\),\n\\[ S_n = \\sum_{k=0}^n u_k. \\]Par exemple, la série de terme général \\( u_n = 1/n \\) si \\( n \\geq 1 \\) est définie par\n\\[ S_n = \\sum_{k=1}^n \\frac{1}{k}. \\] 2.4. Matrices réelles # Soient \\( I \\) et \\( J \\) deux ensembles. On appelle matrice à coefficients réels ou encore matrice réelle toute application \\( f : I \\times J \\to \\mathbb{R} \\). Si l’on confond \\( f \\) à son image, alors on peut légitimement représenter une matrice \\( f \\) de type \\( I \\times J \\) par une famille \\( (f(i, j))_{(i, j) \\in I \\times J} \\). On pose plus simplement \\( f(i, j) = f_{ij} \\) et les \\( f_{ij} \\) sont appelés coefficients de la matrice. Un cas particulier important, lorsque \\( I = \\{1, 2, \\dots, m\\} \\) et \\( J = \\{1, 2, \\dots, n\\} \\), on dit que \\( f \\) est une matrice de type \\( (m, n) \\). Il est alors commode de représenter \\( f \\) par un tableau rectangulaire du type\n\\[ f = \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 \\dots \u0026 a_{1n} \\\\ a_{21} \u0026 a_{22} \u0026 \\dots \u0026 a_{2n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ a_{m1} \u0026 a_{m2} \u0026 \\dots \u0026 a_{mn} \\end{pmatrix} \\]où \\( f_{ij} = a_{ij} \\).\nLorsque \\( m = n \\), la matrice \\( f \\) est dite carrée. Les termes \\( a_{11}, a_{22}, \\dots, a_{nn} \\) sont appelés les termes diagonaux. Une matrice carrée est dite triangulaire supérieure (respectivement inférieure) si les termes situés en dessous (respectivement au-dessus) de la diagonale sont tous nuls. On a respectivement \\( A = (a_{ij}) \\) avec \\( 1 \\leq i \\leq n \\), \\( 1 \\leq j \\leq n \\) et \\( a_{ij} = 0 \\) si \\( i \u003e j \\) (respectivement \\( i \u003c j \\)).\nExemple : \\( A = \\begin{pmatrix} 1 \u0026 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 2 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\end{pmatrix} \\), \\( B = \\begin{pmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 2 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\end{pmatrix} \\), alors \\( A \\) est triangulaire supérieure et \\( B \\) est triangulaire inférieure.\nUne matrice carrée est diagonale si elle est à la fois triangulaire supérieure et triangulaire inférieure. \\( A = (a_{ij}) \\) avec \\( 1 \\leq i \\leq n \\), \\( 1 \\leq j \\leq n \\) et \\( a_{ij} = 0 \\) si \\( i \\neq j \\).\nDans la suite, on désigne par \\( M_{m,n}(\\mathbb{R}) \\) l’ensemble des matrices à \\( m \\) lignes et \\( n \\) colonnes à coefficients réels.\n2.4.1. Addition de deux matrices # Soit \\( A = (a_{ij}) \\) avec \\( 1 \\leq i \\leq m \\), \\( 1 \\leq j \\leq n \\) et \\( B = (b_{ij}) \\) avec \\( 1 \\leq i \\leq m \\), \\( 1 \\leq j \\leq n \\) deux éléments de \\( M_{m,n}(\\mathbb{R}) \\). On définit la somme \\( C \\) de \\( A \\) et de \\( B \\) par :\n\\[ C = A + B \\text{ et } C = (c_{ij}) \\text{ avec } 1 \\leq i \\leq m, 1 \\leq j \\leq n \\text{ tels que } c_{ij} = a_{ij} + b_{ij}. \\]\\( C \\in M_{m,n}(\\mathbb{R}) \\).\n2.4.2. Produit de deux matrices # Soient \\( A \\in M_{m,n}(\\mathbb{R}) \\) avec \\( 1 \\leq i \\leq m \\), \\( 1 \\leq j \\leq n \\) et \\( B \\in M_{n,p}(\\mathbb{R}) \\) avec \\( 1 \\leq i \\leq n \\), \\( 1 \\leq j \\leq p \\).\nLe produit \\( C = (c_{ij}) \\) avec \\( 1 \\leq i \\leq m \\), \\( 1 \\leq j \\leq p \\) de \\( A \\) et de \\( B \\) est la matrice définie par\n\\[ c_{ij} = \\sum_{k=1}^n a_{ik} b_{kj} \\] Exemple : \\( A = \\begin{pmatrix} 1 \u0026 2 \u0026 3 \\end{pmatrix} \\) et \\( B = \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix} \\), \\( A \\times B = 14 \\) et \\( B \\times A = \\begin{pmatrix} 1 \u0026 2 \u0026 3 \\\\ 2 \u0026 4 \u0026 6 \\\\ 3 \u0026 6 \u0026 9 \\end{pmatrix} \\).\n2.4.3. Transposition # Soit \\( A \\in M_{m,n}(\\mathbb{R}) \\). \\( A = (a_{ij}) \\) avec \\( 1 \\leq i \\leq m \\), \\( 1 \\leq j \\leq n \\). On appelle transposée de \\( A \\) la matrice \\( A^\\top \\in M_{n,m}(\\mathbb{R}) \\) définie par \\( A^\\top = (b_{ij}) \\) où \\( b_{ij} = a_{ji} \\).\nExemple : \\( A = \\begin{pmatrix} 1 \u0026 2 \u0026 3 \\end{pmatrix} \\) et \\( B = \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\end{pmatrix} \\), alors \\( A^\\top = B \\) et \\( B^\\top = A \\).\nRemarque : la transposée de la transposée d\u0026rsquo;une matrice est égale à cette matrice.\n3. Variable aléatoire et fonction de variable aléatoire # Dans l’étude des probabilités, les phénomènes aléatoires occupent une place centrale, et leur analyse repose sur des outils mathématiques spécifiques. Un phénomène aléatoire est un événement dont l’issue n’est pas déterminée à l’avance, mais qui peut être décrite par un ensemble de résultats possibles, appelé univers ou espace des événements. Pour quantifier et modéliser ces résultats, on introduit la notion de variable aléatoire, qui permet d’associer des valeurs numériques aux issues d’un phénomène aléatoire. Cette approche facilite l’étude des propriétés statistiques et des comportements probables d’un système. Les variables aléatoires, qu’elles soient discrètes ou continues, sont au cœur des calculs probabilistes et servent de base à la définition de concepts plus avancés, comme les fonctions de variables aléatoires.\n3.1. Variable aléatoire # Toute mesure d’une grandeur \\( X \\) dans un univers \\( \\Omega \\) dont les valeurs dépendent du hasard est dite variable aléatoire. On distingue en général deux types de variable aléatoire : le type discret et le type continu.\n3.1.1. Variable aléatoire discrète # Une variable aléatoire \\( X \\) est dite discrète lorsque son ensemble de définition, c’est-à-dire l’ensemble de ses valeurs possibles noté \\( X(\\Omega) \\), est un ensemble fini. Un élément de \\( X(\\Omega) \\) est appelé un évènement élémentaire. Pour une variable aléatoire discrète \\( X \\), on définit les notions suivantes :\n3.1.1.1. Loi de probabilité # On appelle loi de probabilité ou encore loi de distribution de la variable aléatoire \\( X \\) la fonction définie par \\( p : X(\\Omega) \\to [0, 1] \\), \\( x_i \\mapsto p(X = x_i) = p_i \\) où \\( x_i \\in X(\\Omega) \\). On rappelle que\n\\( \\forall i, p_i \\geq 0 \\); \\( \\sum_{x_i \\in X(\\Omega)} p_i = 1 \\). Exemple : Une plante peut avoir de 0 à 4 fleurs avec les probabilités suivantes :\nTableau 4 : Exemple de distribution de probabilité\nNombre de fleurs \\( x_i \\) 0 1 2 3 4 Probabilité \\( p_i \\) 2k 1/8 1/8 3/8 k Question : calculer \\( k \\) pour que ce tableau corresponde à une distribution de probabilité.\nRéponse \\( k = 1/8 \\) car la somme des probabilités doit donner 1. 3.1.1.2. Fonction de répartition # On appelle fonction de répartition ou fonction cumulative de la variable aléatoire \\( X \\) la fonction \\( F \\) définie par \\( F : X(\\Omega) \\to [0, 1] \\), \\( x_i \\mapsto F(x_i) = p(X \u003c x_i) = \\sum_{x_j \u003c x_i} p(X = x_j) \\).\nRemarque : certains ouvrages définissent \\( F \\) par \\( F(x_i) = p(X \\leq x_i) \\).\nParmi les lois de probabilités discrètes, on peut citer : la loi uniforme sur \\( [1, n] \\). Elle est donnée par \\( p(X = x) = 1/n \\) avec \\( x \\in \\{1, \\dots, n\\} \\), la loi de Bernoulli de paramètre \\( p \\). Elle est donnée par \\( p(X = x) = p^x q^{1-x} \\) avec \\( p + q = 1 \\) et \\( x \\in \\{0, 1\\} \\). Elle correspond au schéma succès/échec avec une probabilité de succès \\( p \\).\nÉtant données deux variables aléatoires \\( X \\) et \\( Y \\), on peut définir une variable aléatoire \\( Z = (X, Y) \\). \\( Z \\) est appelé variable aléatoire à deux dimensions ou couple de variables aléatoires.\nÉtant donnée une variable aléatoire \\( X \\) et une fonction \\( g \\) quelconque, on peut définir une autre variable aléatoire \\( Y \\) par \\( Y = g(X) \\). La détermination de la loi de \\( Y \\) se fait alors en prenant en considération la loi de \\( X \\) et le comportement de la fonction \\( g \\).\nOn peut utiliser une loi de probabilité connue pour, par exemple, générer des nombres aléatoires. Toutefois, il convient de noter qu\u0026rsquo;en raison du caractère déterministe des algorithmes informatiques, les nombres générés par les programmes informatiques sont pseudo-aléatoires.\nAnnexe # Tableau 5 : Quelques abréviations et symboles usuels, ainsi que leur signification\nSymbole Description Exemple ssi Si et seulement si. Placé après une expression propositionnelle, exprime une condition nécessaire et suffisante pour que cette expression propositionnelle soit vraie. Un nombre entier est pair ssi son dernier chiffre est pair. \\( \\sum_{i=p}^n \\) Sommation de \\( n - p + 1 \\) termes indexés par \\( i \\), et \\( i \\) variant de \\( p \\) à \\( n \\). \\( \\sum_{i=1}^n i \\) désigne la somme des \\( n \\) premiers entiers naturels. Il convient alors de remarquer que le résultat de cette somme est identique à \\( \\sum_{i=0}^n i \\) mais la sommation est différente puisque les deux sommations ont un nombre de termes différents. On peut avoir une double, une triple,\u0026hellip; sommation avec deux, trois\u0026hellip; indices \\( ij \\), \\( ijk \\),\u0026hellip; chacun des indices variant à son tour. \\( \\leq \\) Placé entre des termes, ce symbole signifie que le membre de gauche est plus petit ou égal au membre de droite (usage restreint). Mais plus généralement, il signifie que le membre de gauche est en relation avec le membre de droite ou lui est égal (usage élargi). Pour l\u0026rsquo;ordre naturel sur l\u0026rsquo;ensemble des entiers naturels \\( \\mathbb{N} \\), \\( 1 \\leq 2 \\) et \\( 2 \\leq 2 \\). Pour la relation de divisibilité dans \\( \\mathbb{N} \\), c\u0026rsquo;est-à-dire \\( a \\) en relation avec \\( b \\) ssi \\( a \\) divise \\( b \\); \\( 2 \\leq 4 \\) et \\( 2 \\leq 2 \\), mais on ne peut pas comparer 2 et 5. \\( \\geq \\) Placé entre des termes, ce symbole signifie que le membre de gauche est plus grand ou égal au membre de droite (usage restreint). Mais plus généralement, il signifie que le membre de gauche est en relation avec le membre de droite ou lui est égal (usage élargi). Pour l\u0026rsquo;ordre naturel sur l\u0026rsquo;ensemble des entiers naturels \\( \\mathbb{N} \\), \\( 2 \\geq 1 \\) et \\( 2 \\geq 2 \\). Pour la relation de divisibilité dans \\( \\mathbb{N} \\), c\u0026rsquo;est-à-dire \\( a \\) en relation avec \\( b \\) ssi \\( a \\) divise \\( b \\); \\( 4 \\geq 2 \\) et \\( 2 \\geq 2 \\), mais on ne peut pas comparer 5 et 2. \\( \u003c \\) Placé entre des termes, ce symbole signifie que le membre de gauche est strictement plus petit que le membre de droite (usage restreint). Mais plus généralement, il signifie que le membre de gauche est en relation avec le membre de droite et lui est différent (usage élargi). Pour l\u0026rsquo;ordre naturel sur l\u0026rsquo;ensemble des entiers naturels \\( \\mathbb{N} \\), \\( 1 \u003c 2 \\). Pour la relation de divisibilité dans \\( \\mathbb{N} \\), c\u0026rsquo;est-à-dire \\( a \\) en relation avec \\( b \\) ssi \\( a \\) divise \\( b \\); \\( 2 \u003c 4 \\), mais on ne peut pas comparer 2 et 5. \\( \u003e \\) Placé entre des termes, ce symbole signifie que le membre de gauche est strictement plus grand que le membre de droite (usage restreint). Mais plus généralement, il signifie que le membre de gauche est en relation avec le membre de droite et lui est différent (usage élargi). Pour l\u0026rsquo;ordre naturel sur l\u0026rsquo;ensemble des entiers naturels \\( \\mathbb{N} \\), \\( 2 \u003e 1 \\). Pour la relation de divisibilité dans \\( \\mathbb{N} \\), c\u0026rsquo;est-à-dire \\( a \\) en relation avec \\( b \\) ssi \\( a \\) divise \\( b \\); \\( 4 \u003e 2 \\), mais on ne peut pas comparer 5 et 2. \\( \\forall \\) Quantificateur universel. \\( \\forall a \\) se lit pour tout \\( a \\)\u0026hellip; \\( \\forall a \\in \\mathbb{N}, a \\geq 0 \\) pour tout élément \\( a \\) de l\u0026rsquo;ensemble \\( \\mathbb{N} \\), \\( a \\) est supérieur ou égal à 0. \\( \\exists \\) Quantificateur existentiel. \\( \\exists a \\) se lit il existe au moins un \\( a \\)\u0026hellip; \\( \\exists a \\in \\mathbb{N} \\) tel que \\( a \\neq 0 \\), il existe au moins un élément \\( a \\) de l\u0026rsquo;ensemble \\( \\mathbb{N} \\) qui est différent de 0. \\( \\in \\) C\u0026rsquo;est le symbole d\u0026rsquo;appartenance. \\( a \\in A \\) signifie que \\( a \\) est un élément de l\u0026rsquo;ensemble \\( A \\). Utilisé après un quantificateur, et une suite de symboles, il signifie que ces symboles sont éléments de l\u0026rsquo;ensemble qui suit. Par exemple : \\( \\forall a, b, c \\in \\mathbb{N} \\) signifie pour tous éléments \\( a, b \\) et \\( c \\) de \\( \\mathbb{N} \\). \\( \\notin \\) C\u0026rsquo;est le symbole de non-appartenance. \\( a \\notin A \\) signifie que \\( a \\) n\u0026rsquo;est pas un élément de l\u0026rsquo;ensemble \\( A \\). \\( -1 \\notin \\mathbb{N} \\). \\( \\subseteq \\) Placé entre deux ensembles, signifie que l\u0026rsquo;ensemble de gauche est inclus dans l\u0026rsquo;ensemble de droite ou lui est égal. Si \\( A \\) et \\( B \\) sont deux ensembles, \\( A \\subseteq A \\cup B \\). \\( \\subset \\) Placé entre deux ensembles, signifie que l\u0026rsquo;ensemble de gauche est strictement inclus dans l\u0026rsquo;ensemble de droite (et donc en est différent). \\( \\mathbb{N} \\subset \\mathbb{Z} \\). \\( \\Rightarrow \\) Implication logique. Placé entre deux propositions, ce symbole indique que la proposition de gauche implique celle de droite. \\( p \\Rightarrow q \\) est faux ssi \\( p \\) est vrai et \\( q \\) faux. \\( \\| \\cdot \\| \\) Valeur absolue. Si \\( a \\) est placé entre les deux barres, le résultat est le nombre positif \\( a \\) si \\( a \\) est positif et \\( -a \\) si \\( a \\) est négatif. ( a "},{"id":58,"href":"/inf1220-hugo/docs/modules/module3/travail-note-3/","title":"Travail noté 3","section":"Module 3: Les structures de données, de contrôle et d'itération en Java","content":" Travail noté 3 - Les structures de données, de contrôle et d\u0026rsquo;itération # Les travaux notés du cours INF1220 évaluent la capacité à comprendre des énoncés logiques et à les transcrire en code Java de manière autonome, une compétence essentielle testée également à l’examen final. Les étudiants doivent effectuer des recherches sur le web, une pratique courante en programmation, et soumettre leurs travaux sous forme de fichier PDF via l’outil de dépôt de la TÉLUQ, avant la date de fin de cours indiquée dans le portail étudiant. Les soumissions par courriel ne sont pas acceptées et entraînent une note de zéro, tout comme les documents manuscrits, les saisies d’écran ou ceux ne permettant pas le copier-coller du code. Les travaux, d’un niveau comparable à ceux d’autres universités québécoises, doivent inclure des explications claires et personnelles, l’utilisation du robot conversationnel du cours étant autorisée à condition de produire ses propres analyses.\nLa date de fin de cours, fixée par l’Université, est non négociable par les enseignants, et tout travail remis après cette date risque une note de zéro ou un « incomplet », même si l’examen a lieu plus tard. En cas de difficultés personnelles (maladie, deuil, etc.), les étudiants doivent s’adresser à l’Université pour demander un report. Si un problème technique survient avec l’outil de dépôt, l’Université doit être contactée pour assistance. Les travaux sont strictement individuels, et tout échange, notamment sur les réseaux sociaux, constitue une faute académique pouvant mener à une note de zéro ou à une exclusion du programme.\nEn cas d’incapacité à résoudre complètement un problème, les étudiants sont encouragés à expliquer leur démarche et leurs difficultés, mais aucune solution ne sera fournie après la correction. Aucun indice supplémentaire ne sera donné au-delà de l’énoncé pour garantir l’équité. La planification rigoureuse du temps est cruciale, car le dépôt dans les délais est de la responsabilité de l’étudiant. Les consignes insistent sur la nécessité de relire attentivement son travail avant soumission, car aucune modification n’est possible une fois le fichier déposé.\nQuestion #1 # Écrivez un programme Java qui calcule la somme des nombres de 1 jusqu'à 10,000 (incluant 1 et 10,000) mais en omettant les nombres qui sont divisibles par trois et en omettant aussi les nombres dont le chiffre de la centaine est 2 ou 3 (par exemple 1201 ou 3313). Expliquez votre solution. Un travail remis sans explications suffisantes peut se voir attribué la note de zéro, sans droit de reprise. Vous devez justifier tous les qualifiants utilisés (private, public, protected, static): vous ne pouvez pas utiliser le mot-clé « static » sans le justifier.\nVous devez tester votre solution. Vous devez inclure la sortie (affichage) du code dans votre solution. Si remettez du code non-fonctionnel, vous pourrez recevoir la note de zéro!\nAttention: vous devez remettre votre travail sous la forme d'un seul fichier PDF (et non pas sous la forme de fichiers Java). Cette question exige une maîtrise de l'arithmétique de base. Étant donné, par exemple, le nombre 1234, vous devriez pouvoir construire une expression mathématique élémentaire qui permet de trouver les centaines ('2'), les dizaines ('3') ou les milliers ('1'). Vous pouvez consulter le site d'aide aux devoirs alloprof à ce sujet: Les positions et les valeurs des nombres.\nLes opérateurs / et % sont utiles pour ce problème. À ce point dans le cours, vous devriez être pleinement familier avec les opérateurs arithmétiques en Java. Est-ce que la somme peut être représentée par une variable de type int? Assurez-vous de discuter ce point dans votre solution. Pour faciliter la correction, assurez-vous qu'on puisse copier-coller votre code à partir du document PDF. N'utilisez pas des saisies d'écran.Si le code de votre solution n'est pas du Java valable, s'il ne compile pas, une note de zéro pourra être attribuée. Pour réussir ce cours, vous devez être capable d'écrire du code Java fonctionnel et correct.\nQuestion #2 # Écrivez un programme Java qui affiche à l'écran toutes les chaînes de 4 caractères en ordre lexicographique (aussi appelé l'ordre du dictionnaire). Il doit afficher une chaîne de 4 caractères par ligne. Seuls les caractères a, b, c, d sont permis au sein des chaînes de caractères, mais vous pouvez réutiliser plus d'une fois un même caractère au sein d'une même chaîne. Au sein d'une même chaîne, le caractère 'b' doit toujours être immédiatement suivi du caractère 'a'. Une même chaîne ne peut comporter à la fois le caractère 'd' et le caractère 'a'. Votre programme doit se terminer en affichant à l'écran le nombre de chaînes de caractères affichées. Votre programme ne reçoit rien en entrée. Le code de votre programme ne doit pas comprendre les chaînes de caractères pré-calculées: il doit les générer lors de l'exécution. Votre programme ne devrait pas contenir plus de 200 courtes lignes de code.\nExpliquez votre solution. Un travail remis sans explications suffisantes peut se voir attribué la note de zéro, sans droit de reprise. Vous devez justifier tous les qualifiants utilisés (private, public, protected, static): vous ne pouvez pas utiliser le mot-clé « static » sans le justifier.\nVous devez tester votre solution et inclure la sortie (affichage) du code dans votre solution. Vous devriez avoir vérifié que votre programme fonctionne. Si remettez du code non-fonctionnel, vous pourrez recevoir la note de zéro! Si le code de votre solution n'est pas du Java valable, s'il ne compile pas, une note de zéro pourra être attribuée. Pour réussir ce cours, vous devez être capable d'écrire du code Java fonctionnel et correct.\nIl y a plusieurs façons de résoudre ce problème. Il n'y a pas de solution unique. Par contre, à partir de l'énoncé, vous devez être capable de calculer dans votre esprit la solution (celle-ci est unique) et vous devez donc être capable de vérifier que votre programme donne la solution correcte.\nNous ne donnons pas la sortie attendue délibérément : vous devez montrer que vous êtes capable d'interpréter des consignes formelles. La compréhension des contraintes logiques et de leurs conséquences fait partie de la question. Vous devez être capable, à titre de programmeur, de bien interpréter des contraintes logiques. Vous ne devez donc pas nous demander d'interpréter la question pour vous. Le résultat de votre programme doit être le même à chaque exécution. Un caractère en Java a le type char. Une chaîne de caractères en Java a le type String. Ce type est immutable: les objets, une fois créés, ne peuvent pas être modifiés. Étant donné une chaîne de caractères s, on peut avoir accès au 3e caractère avec la syntaxe s.charAt(2). On peut créer une chaîne de caractères à partir de deux caractères c1 et c2 avec la syntaxe Character.toString(c1) + Character.toString(c2). Attention: c1 + c2 ne donne pas une nouvelle chaîne de caractères quand c1 et c2 sont des char. Le nombre total de chaînes affichées est une valeur déterminée mathématiquement, il sera le même pour toutes les solutions correctes de ce problème. La consigne « le caractère 'b' doit toujours être immédiatement suivi du caractère 'a' » vous indique si une chaîne de caractères peut se terminer par le caractère 'b'. Vous devez être capable de comprendre cet énoncé logique. Certains étudiants ne distinguent pas « l'ordre alphabétique » de « l'ordre lexicographique ». L'ordre alphabétique est donné par a, b, c, d, etc. alors que l'ordre lexicographique est celui des mots dans le dictionnaire. Attention : Il n'y aura pas d'indices ou d'exemples personnalisés fournis à quiconque concernant cette question ou toute autre question notée. Question-boni # Un point supplémentaire est octroyé aux étudiants qui réussissent cette question. Notez qu'il n'est pas possible d'avoir plus que 100% sur le travail noté. Elle est principalement destinée aux étudiants qui cherchent à relever un défi.\nÉcrivez une classe Java qui génère aléatoirement un tableau de Sudoku. Vous pouvez utiliser la méthode Random.nextInt et votre tableau doit avoir le type int[][]. Votre tableau doit compter 9 rangées et 9 colonnes. Dans chaque colonne, chacun des chiffres de 1 à 9 doit apparaître (une seule fois). Dans chaque rangée, chacun des chiffres de 1 à 9 doit apparaître une seule fois. Expliquez votre solution. Pour les fins de ce travail, nous n’exigeons pas que chaque sous-grille de 3×3 contienne tous les chiffres de 1 à 9.\nIl n'est pas requis que votre code soit rapide, mais votre programme doit compléter son travail dans un temps raisonnable (par exemple, moins de deux minutes).\nEn terminant Dans plusieurs cas, vos travaux sont corrigés par un « correcteur ». Il est possible que vous puissiez identifier cette personne en examinant le document de rétroaction que vous recevez au sein du portail étudiant. Vous ne devriez jamais joindre cette personne. Cette personne n'a pas comme mandat de répondre à vos questions suite à la correction. Vos courriels seront ignorés. Il faut plutôt joindre la personne qui vous encadre au sein du cours.\n"},{"id":59,"href":"/inf1220-hugo/docs/extra/ia/","title":"Intelligence artificielle","section":"Autres ressources","content":"Dans le cadre de ce cours, l’utilisation d’outils d’intelligence artificielle (tels que Claude, ChatGPT, Copilot, Grok, ou autres) est autorisée, mais demeure facultative. Ces outils peuvent servir de soutien pour approfondir votre compréhension, structurer vos idées ou générer des contenus préliminaires. Toutefois, leur usage doit être responsable, transparent et rigoureusement documenté. L’objectif est de garantir que votre travail reflète vos compétences et votre compréhension personnelle, tout en tirant parti des possibilités offertes par ces technologies. Une utilisation non déclarée ou inappropriée de l’IA peut être considérée comme une faute académique, tandis qu’une déclaration claire de son usage renforce la crédibilité de votre démarche.\nPour utiliser l’IA de manière conforme, vous devez décrire précisément comment vous l’avez employée. Par exemple, indiquez si l’IA a été utilisée pour générer des idées, rédiger un brouillon, résoudre un problème ou vérifier des informations. Incluez, dans la mesure du possible, des extraits ou des copies des résultats obtenus à partir de vos interactions avec l’outil d’IA, et expliquez en vos propres mots comment vous avez intégré ces résultats dans votre travail. Cette transparence permet non seulement de démontrer votre engagement éthique, mais aussi de protéger l’intégrité de votre contribution. Assurez-vous d’expliquer vos démarches et vos conclusions de manière claire et personnelle, en mettant en évidence votre réflexion critique et votre appropriation des concepts étudiés.\n"},{"id":60,"href":"/inf1220-hugo/docs/modules/module1/travail-note-1/","title":"Travail noté 1","section":"Module 1: Algorithme et pseudocode","content":" Travail noté 1 - Les algorithmes # Ce cours d’introduction à la programmation exige une gestion rigoureuse du temps et une préparation approfondie. Les étudiants doivent soumettre leurs travaux notés avant la date de fin de cours, indiquée dans le portail étudiant, sans possibilité de report sauf en cas de circonstances exceptionnelles validées par l’Université. La charge de travail est estimée à neuf heures par semaine sur quinze semaines, et les travaux, d’un niveau comparable à ceux d’autres universités, nécessitent plusieurs heures par activité. Les consignes soulignent l’importance de lire attentivement les énoncés, de tester rigoureusement ses solutions et de consacrer plus de temps à la vérification qu’à la production initiale. L’utilisation du robot conversationnel du cours est autorisée, mais les réponses doivent être personnelles.\nLes travaux doivent être soumis en format PDF via l’outil de dépôt officiel de la TÉLUQ, sans envoi par courriel, sous peine de note zéro. Les consignes de présentation insistent sur la clarté, la lisibilité et l’usage d’un français correct, avec des explications détaillées en prose. Les corrections, disponibles sous cinq à dix jours ouvrables, sont accessibles uniquement via le portail étudiant, où les étudiants trouveront leur note et une rétroaction. Aucune solution n’est fournie, et les travaux sont strictement individuels, tout échange sur les réseaux sociaux pouvant entraîner des sanctions graves, y compris l’exclusion.\nPour réussir, les étudiants doivent présenter des solutions claires, précises et testées, accompagnées d’explications factuelles. La rigueur dans l’analyse et la vérification est cruciale, tout comme la réalisation préalable des exercices préparatoires. Les travaux notés évaluent la capacité à comprendre des énoncés logiques et à raisonner abstraitement, sans points attribués pour l’effort seul. Les étudiants sont encouragés à poser des questions sur la matière, à tester leurs solutions avec diverses données et à relire leur travail avant soumission, en évitant de commencer sans une maîtrise solide des concepts\nPremier problème # Nous souhaitons un algorithme qui détermine si la somme des éléments d'un tableau de nombres positifs excède 100. Par ailleurs, nous souhaitons un algorithme efficace: l'algorithme doit accéder à aussi peu d'éléments du tableau que possible. Produisez un pseudo-code précis et expliquez votre solution. Vous pouvez expliquer le code sous la forme que vous souhaitez, tant que vos explications sont claires. Exécutez votre pseudo-code sur au moins 5 cas, incluant les deux cas suivants: le tableau [55,55,55,55] et le tableau [1,2,3,5,6].\nVous devez exécuter votre pseudo-code ligne-par-ligne en indiquant à chaque ligne quelle est la valeur de toutes les variables. Votre exécution doit être rigoureuse. Si l'algorithme effectue 50 opérations, votre exécution devrait comprendre 50 lignes. Vous devez produire du pseudo-code: du code informatique (par ex. Java ou Python) n'est pas accepté. Votre pseudo-code doit être précis et lisible.\nSi vous produisez un algorithme logiquement incorrect, vous pourrez obtenir la note de zéro pour cette question. Si vous omettez d'inclure un compte-rendu détaillé de l'exécution, vous pouvez obtenir la note de zéro.\nIndices concernant le premier problème # Voici quelques indices concernant l\u0026rsquo;énoncé que vous pouvez prendre en compte pour vous aider. Un indice n\u0026rsquo;est jamais une question supplémentaire, un ajout à la question, ou une seconde partie. Un indice ne sert qu\u0026rsquo;à vous inspirer ou à vous aider. Vous pouvez complètement ignorer les indices. Les indices ne visent qu\u0026rsquo;à vous aider si vous le souhaitez.\nIndice 1. Rendez-vous sur la page du robot conversationnel du cours et saisissez l'énoncé dans la boîte de saisie: « Nous souhaitons un algorithme qui détermine si la somme des éléments d’un tableau de nombres positifs excède 100. Par ailleurs, nous souhaitons un algorithme efficace: l’algorithme doit accéder à aussi peu d’éléments du tableau que possible. Produisez un pseudo-code précis et expliquez votre solution. Vous pouvez expliquer le code sous la forme que vous souhaitez, tant que vos explications sont claires. Exécutez votre pseudo-code sur au moins 5 cas, incluant les deux cas suivants: le tableau [55,55,55,55] et le tableau [1,2,3,5,6]. ». Indice 2. Votre algorithme doit retourner soit vrai, soit faux. Indice 3. Votre algorithme doit fonctionner même si le tableau a une longueur de zéro. Indice 4. Votre algorithme doit fonctionner même si le tableau contient mille milliards d'éléments. Indice 5. Imaginez qu'on vous donne ce problème. On vous donne un tableau de grande taille (contenant, disons, un million d'éléments) contenant des valeurs positives et on vous demande de déterminer, le plus rapidement possible, si la somme des valeurs du tableau excède 100. Que feriez-vous? Expliquez de façon précise ce que vous feriez dans cette situation. (Il s'agit d'un indice pour vous aider à répondre à l'énoncé, pas une nouvelle question. Le tableau qu'on vous invite à imaginer n'est pas un second tableau ou un tableau supplémentaire par rapport à l'énoncé.) Indice 6. Commencez par le pseudo-code suivant qui calcule la somme des éléments d'un tableau. Entrées : Tableau de nombres positifs : tableau Variables : Nombre entier : iterateur = 0; Sorties : Nombre : somme = 0; TANT QUE iterateur \u0026lt; la longueur de tableau FAIRE somme = somme + tableau[iterateur]; iterateur = iterateur + 1; FIN TANT QUE (Vous n\u0026rsquo;êtes pas obligé de partir de ce pseudo-code. Il s\u0026rsquo;agit d\u0026rsquo;un indice, d\u0026rsquo;une suggestion. Ce bout de pseudo-code n\u0026rsquo;introduit pas une question supplémentaire. Le tableau qu\u0026rsquo;on y trouve n\u0026rsquo;est pas un second tableau en plus de celui de l\u0026rsquo;énoncé.)\nIndice 7. Ce n'est pas un problème de programmation Java, C#, C++ ou Python. Vous devez produire du pseudo-code qui est destiné à être lu et compris par un être humain. Il n'est pas nécessaire d'utiliser les constructions et types propres Java, C#, C++ ou Python. Indice 8. Beaucoup trop d'étudiants essaient de faire ce travail sans avoir fait tous les exercices sérieusement. Si vous avez analysé et compris les exercices préparatoires pour ce problème, vous ne devriez avoir aucune difficulté. Il est pratiquement impossible de ne pas arriver à faire ce problème en ayant fait tous les exercices solutionnés et en ayant bien compris toutes les solutions. Il est de votre responsabilité de faire tous les exercices. Second problème # Nous souhaitons afficher les nombres entiers de 0 jusqu\u0026rsquo;à 100 à l\u0026rsquo;écran (incluant 0 mais excluant 100), en affichant \u0026ldquo;Fizz\u0026rdquo; quand le nombre est divisible par 3 et \u0026ldquo;Buzz\u0026rdquo; quand le nombre est divisible par 5.\n... 2 3 Fizz 4 5 Buzz 6 Fizz ... Un étudiant nous a offert la solution suivante. Elle est incorrecte. Pour les fins de ce travail, vous pouvez ignorer la mise en page de la sortie (polices de caractères, espaces, etc.). L\u0026rsquo;erreur de l\u0026rsquo;étudiant est logique et non pas cosmétique.\nExpliquez l\u0026rsquo;erreur et offrez une version corrigée. Exécutez votre pseudo-code corrigé, ainsi que le pseudo-code original. Expliquez les différences. Vous devez exécuter votre pseudo-code. Puisqu\u0026rsquo;il y a peut-être des dizaines d\u0026rsquo;itérations à calculer, vous pouvez résumer l\u0026rsquo;exécution sans aller dans chaque détail de chaque itération.\nVotre explication de l\u0026rsquo;erreur doit être claire et limpide. Si vous ne montrez pas que vous avez bien compris l\u0026rsquo;erreur et que vous êtes capable de l\u0026rsquo;expliquez clairement, vous pourrez recevoir une note de zéro pour cette question.\nEntrées : Valeur maximale : 100; Variables : Nombre entier : iterateur = 0; Sorties : à l\u0026#39;écran TANT QUE iterateur \u0026lt; 100 FAIRE affiche la valeur de iterateur à l\u0026#39;écran SI iterateur est divisible par 3 ALORS affiche \u0026#34; Fizz\u0026#34; à l\u0026#39;écran SINON SI iterateur est divisible par 5 ALORS affiche \u0026#34; Buzz\u0026#34; à l\u0026#39;écran FIN SI change de ligne à l\u0026#39;écran iterateur = iterateur + 1 FIN TANT QUE Indice. Rendez-vous sur la page du robot conversationnel du cours et saisissez l'énoncé dans la boîte de saisie: « Nous souhaitons afficher les nombres entiers de 0 jusqu'à 100 à l'écran (incluant 0 mais excluant 100), en affichant \"Fizz\" quand le nombre est divisible par 3 et \"Buzz\" quand le nombre est divisible par 5. Expliquez l'erreur dans ce pseudocode: TANT QUE iterateur \u003c 100 FAIRE affiche la valeur de iterateur à l'écran SI iterateur est divisible par 3 ALORS affiche \" Fizz\" à l'écran SINON SI iterateur est divisible par 5 ALORS affiche \" Buzz\" à l'écran FIN SI change de ligne à l'écran iterateur = iterateur + 1 FIN TANT QUE ».\nNotez: le cours comprend plusieurs liens vers des vidéos et autres ressources externes. Ces ressources sont toujours optionnelles.\nEn terminant # Dans plusieurs cas, vos travaux sont corrigés par un « correcteur ». Il est possible que vous puissiez identifier cette personne en examinant le document de rétroaction que vous recevez au sein du portail étudiant. Vous ne devriez jamais joindre cette personne. Cette personne n'a pas comme mandat de répondre à vos questions suite à la correction. Vos courriels seront ignorés. Il faut plutôt joindre la personne qui vous encadre au sein du cours.\nIl est inutile de nous écrire pour obtenir des indices, des exemples de solutions, des pistes de départ, etc. Dans ce cours, nous n'offrons aucun indice par courriel.\nIl s'agit d'un travail noté individuel.\n"},{"id":61,"href":"/inf1220-hugo/docs/extra/courriel/","title":"Petit guide d’usage du courriel efficace","section":"Autres ressources","content":"Lors de l\u0026rsquo;écriture d\u0026rsquo;un courriel, être bref est important. Omettez les formules de salutation, les signatures surfaites, etc.\nAttention aux émotions : Il est facile quand on reçoit ou transmet un courriel de s\u0026rsquo;emporter ou de lire dans les messages reçus des sentiments. Dans un contexte professionnel, évitez d\u0026rsquo;écrire un courriel alors que vous êtes énervé.\nChoisissez les destinataires de votre courriel avec soin. Il est pratiquement toujours mal avisé de transmettre un courriel à un grand groupe, à moins que le courriel soit une communication formelle. Dans le doute, écrivez un courriel à un seul destinataire.\nAvant de répondre à un courriel, prenez le temps de bien le lire. Si on vous demande de fournir des informations ou détails additionnels, prenez le temps de le faire, ou expliquez clairement pourquoi cela n\u0026rsquo;est pas possible ou souhaitable.\nL\u0026rsquo;objet d\u0026rsquo;un courriel doit en refléter le contenu. Il faut éviter les objets génériques (par ex., « une question »). Il faut éviter à tout prix les objets qui ne réflètent pas le contenu (par ex. intitulé un cours « travail 2 » alors que celui-ci porte en fait sur l\u0026rsquo;examen. Si vous utilisez un objet de courriel vague ou absent, il faut vous attendre à ce que votre courriel puisse ne pas être traité correctement.\nSi vous avez plusieurs sujets distincts, il est souvent préférable d\u0026rsquo;écrire plusieurs courriels distincts, chacun ayant un objet distinct.\nDans un contexte professionnel, il est nettement préférable d\u0026rsquo;envoyer un courriel identifié à votre nom. Il n\u0026rsquo;est pas pratique d\u0026rsquo;envoyer des courriels vous identifiant sous le nom de votre conjoint, par exemple. Il peut être amusant de se donner des pseudonymes (« la chouette », « le montréalais ») entre amis, mais ce n\u0026rsquo;est pas souhaitable dans un contexte professionnel.\nUn courriel destiné à un humain doit obligatoirement avoir un corps de texte. Un courriel doit être clair et fournir tous les détails nécessaires. Par exemple, si vous écrivez à quelqu\u0026rsquo;un pour lui faire part d\u0026rsquo;un problème ou d\u0026rsquo;une incompréhension, il faut fournir tous les détails, incluant les démarches que vous avez déjà entreprises. On peut être précis sans nécessairement utiliser beaucoup de mots. Préparer un courriel précis peut exiger plus d\u0026rsquo;effort et de temps, mais c\u0026rsquo;est un signe de respect envers le récipiendaire.\nSi vous écrivez un courriel pour faire rapport de problèmes techniques, soyez aussi précis que possible. Joignez des saisies d\u0026rsquo;écran au besoin.\nLorsque possible, on évite les pièces jointes. Lorsque celles-ci sont nécessaires, on s\u0026rsquo;assure que le récipiendaire pourra aisément en prendre connaissance. ll faut donc éviter les formats de fichier qui ne correspondent pas à un usage courant. Les formats propriétaires qui ne sont pas courants et qui nécessitent l\u0026rsquo;installation de logiciel particulier sont à éviter.\nLes fichiers de bureautique (par ex., Word, PDF) sont déjà compressés. Transmettre les fichiers en question dans une archive compressée ajoute des manipulations inutiles.\nÀ moins de transmettre des fichiers très volumineux, la compression des fichiers attachés est inutile étant donné la généreuse bande passante dont nous bénéficions. Si on doit utiliser un format d\u0026rsquo;archive compressé, il faut utiliser un format qui est largement supporté par les divers systèmes d\u0026rsquo;exploitation (comme le format zip basique).\nCertains logiciels de courriel (Outlook) ne permettent pas la transmission de fichiers avec certaines extensions. Dans de tels cas, il est acceptable de renommer l\u0026rsquo;extension du fichier et d\u0026rsquo;inclure dans le corps du message une explication. Par exemple, tous les fichiers au format texte (.xml, .html), peuvent être transmis avec l\u0026rsquo;extension « .txt ».\nLes courriels automatisés non sollicités sont du pourriel. Ainsi, il ne faut pas transmettre des réponses automatisées (par ex., des accusés de réception) à des destinateurs non avisés.\nLes protocoles Internet utilisés pour transmettre nos courriels nous assurent déjà de la bonne réception des courriels avec une grande probabilité et un courriel automatisé de réponse ne nous assure pas que le récipiendaire a effectivement pris en compte le courriel. Il est légitime de relancer un destinataire après un délai raisonable pour s\u0026rsquo;assurer que notre envoi a été bien reçu et traité. Par contre, il est normalement considéré impoli et abusif d\u0026rsquo;exiger des accusés de réception.\nLe courriel n\u0026rsquo;est pas toujours le meilleur outil pour obtenir de l\u0026rsquo;information. Il est souvent souhaitable de faire au préalable vos propres recherches. Dans tous les cas, montrez au destinataire que vous avez fait un effort avant d\u0026rsquo;écrire votre courriel.\nLe courriel n\u0026rsquo;est pas, en général, un moyen d\u0026rsquo;échange préservant la confidentialité. Ne transmettez pas vos mots de passe ou toute autre information confidentielle par courriel.\nSi vous écrivez au professeur responsable du cours ou à la personne qui vous encadre, n\u0026rsquo;oubliez d\u0026rsquo;inclure le sigle du cours dans votre courriel ([inf1220]).\n"},{"id":62,"href":"/inf1220-hugo/docs/modules/","title":"Modules","section":"Docs","content":" Modules # Sélectionnez un module dans le menu pour accéder à son contenu:\nModule 1. Algorithme et pseudocode. Dans ce module, vous verrez comment concevoir des algorithmes simples et comment les présenter de manière précise en français. Module 2. Introduction au langage Java. Le concept de programme. Les types, les fonctions, les méthodes, les variables. Les variables de classe et les variables locales. Module 3. Les structures de données, de contrôle et d'itération en Java. Manipulation de chaînes de caractères. Mise en oeuvre d'algorithmes avec des boucles. Module 4. Les entrées et sorties. Module 5. La programmation orientée objet: héritage et le polymorphisme. "}]