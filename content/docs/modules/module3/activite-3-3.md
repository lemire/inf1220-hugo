---
title: "Les structures de donnÃ©es de base"
weight: 4
---

# Les structures de donnÃ©es de base

Le langage Java possÃ¨de toutes les stuctures de donnÃ©es nÃ©cessaires.
Faisons-en rapidement le tour.


### Allocation de mÃ©moire et ramasse-miettes

Lorsque vous crÃ©ez un objet  en Java, la mÃ©moire nÃ©cessaire est automatiquement allouÃ©e dans une zone appelÃ©e le Â«Â tasÂ Â» (heap). Contrairement Ã  certains langages comme C ou C++, il nâ€™est pas nÃ©cessaire de libÃ©rer explicitement la mÃ©moire des objets qui ne sont plus utilisÃ©s. Java intÃ¨gre un mÃ©canisme appelÃ© ramasse-miettes (ou garbage collector) qui se charge de dÃ©tecter et de libÃ©rer automatiquement la mÃ©moire occupÃ©e par les objets devenus inaccessibles. Il partage
cette caractÃ©ristique avec d'autres langages comme C#, JavaScript et Python.

Le ramasse-miettes fonctionne en arriÃ¨re-planÂ : il identifie les objets qui ne sont plus rÃ©fÃ©rencÃ©s par aucune variable ou structure de donnÃ©es, puis rÃ©cupÃ¨re la mÃ©moire correspondante pour la rendre disponible Ã  de nouveaux objets. Cela simplifie la gestion de la mÃ©moire et rÃ©duit les risques de fuites de mÃ©moire (memory leaks) ou dâ€™erreurs de libÃ©ration (comme les double free en C).

Cependant, il est important de comprendre que la libÃ©ration de la mÃ©moire nâ€™est pas instantanÃ©eÂ : le ramasse-miettes intervient Ã  des moments choisis par la machine virtuelle Java (JVM), ce qui peut parfois entraÃ®ner de lÃ©gÃ¨res pauses dans lâ€™exÃ©cution du programme. Pour la plupart des applications, ce fonctionnement automatique est un avantage, car il permet de se concentrer sur la logique du programme sans se soucier de la gestion manuelle de la mÃ©moire.

Lâ€™allocation de mÃ©moire en Java est automatique et la libÃ©ration est assurÃ©e par le ramasse-miettes, ce qui contribue Ã  la robustesse et Ã  la sÃ©curitÃ© des programmes Java.

Par contre, le ramasse-miettes a des inconvÃ©nients : il peut provoquer des pauses imprÃ©visibles dans lâ€™exÃ©cution du programme, appelÃ©es Â« pauses de collecte Â», lorsque la JVM dÃ©cide de libÃ©rer la mÃ©moire. Ces pauses sont gÃ©nÃ©ralement courtes, mais peuvent devenir perceptibles dans des applications nÃ©cessitant une grande rÃ©activitÃ© (jeux, systÃ¨mes temps rÃ©el, etc.). De plus, le dÃ©veloppeur a moins de contrÃ´le sur le moment prÃ©cis oÃ¹ la mÃ©moire est libÃ©rÃ©e, ce qui peut compliquer lâ€™optimisation des performances dans certains cas particuliers. Enfin, le ramasse-miettes consomme lui-mÃªme des ressources processeur, ce qui peut avoir un effet sur lâ€™efficacitÃ© globale du programme.

MalgrÃ© l'existence du ramasse-miettes, il faut donc tenter de minimiser l'allocation de mÃ©moire.
Il faut Ã©viter de crÃ©er des objets temporaires quand on peut rÃ©utiliser un objet dÃ©jÃ  allouÃ©.

## String

En Java, le type <code>String</code> reprÃ©sente une sÃ©quence de caractÃ¨res. Il est trÃ¨s utilisÃ© pour manipuler du texteâ€¯: noms, messages, fichiers, etc. Une particularitÃ© essentielle Ã  comprendre est que les objets de type <code>String</code> sont <strong>immuables</strong>â€¯: une fois crÃ©Ã©s, ils ne peuvent pas Ãªtre modifiÃ©s. Toute opÃ©ration qui semble modifier une chaÃ®ne (comme la concatÃ©nation, le remplacement ou la suppression de caractÃ¨res) crÃ©e en rÃ©alitÃ© un nouvel objet <code>String</code> en mÃ©moire, sans changer lâ€™original.

Par exempleâ€¯:

```java  {style=github}
String s = "Bonjour";
s = s + " le monde"; // CrÃ©e un nouvel objet String
```

Ici, la chaÃ®ne "Bonjour" nâ€™est pas modifiÃ©eâ€¯: une nouvelle chaÃ®ne "Bonjour le monde" est crÃ©Ã©e et la variable <code>s</code> pointe vers ce nouvel objet. Lâ€™ancienne chaÃ®ne reste inchangÃ©e (et sera Ã©ventuellement libÃ©rÃ©e par le ramasse-miettes).

Cette immuabilitÃ© rend les <code>String</code> sÃ»res et efficaces pour le partage, mais peut entraÃ®ner des problÃ¨mes de performance si on fait beaucoup de modificationsâ€¯: dans ce cas, il vaut mieux utiliser <code>StringBuilder</code>.


En Java, les chaÃ®nes de caractÃ¨res (<code>String</code>) sont reprÃ©sentÃ©es en mÃ©moire selon lâ€™encodage UTF-16. Cela signifie que chaque Ã©lÃ©ment du tableau interne dâ€™une chaÃ®ne est un Â«Â code unitÂ Â» de 16 bits (un <code>char</code> Java), mais tous les caractÃ¨res Unicode ne tiennent pas forcÃ©ment dans un seul <code>char</code>.

Lâ€™UTF-16 est un encodage qui permet de reprÃ©senter tous les caractÃ¨res Unicode. La plupart des caractÃ¨res courants (latin, accentuÃ©s, etc.) sont codÃ©s sur un seul <code>char</code> (16 bits), mais certains caractÃ¨res spÃ©ciaux ou emojis, appelÃ©s Â«Â supplÃ©mentairesÂ Â», nÃ©cessitent deux <code>char</code> consÃ©cutifs (appelÃ©s une paire de substitution ou surrogate pair).

La mÃ©thode <code>charAt(int index)</code> retourne le <code>char</code> Ã  la position donnÃ©e dans la chaÃ®ne, mais ce <code>char</code> ne correspond pas toujours Ã  un caractÃ¨re complet pour lâ€™utilisateur. Si la chaÃ®ne contient un caractÃ¨re supplÃ©mentaire (hors du plan multilingue de base), <code>charAt</code> peut retourner seulement une partie de ce caractÃ¨re (un des deux Ã©lÃ©ments de la paire de substitution).

Pour manipuler correctement les caractÃ¨res Unicode, il faut utiliser les mÃ©thodes <code>codePointAt</code>, <code>codePoints()</code> ou les classes de lâ€™API <code>Character</code>, qui tiennent compte des paires de substitution et permettent de traiter chaque caractÃ¨re Unicode comme une entitÃ© logique.

```java  {style=github}
String s = "AğŸ˜ŠB";
System.out.println(s.length());      // Affiche 4 (car ğŸ˜Š occupe deux char)
System.out.println(s.charAt(1));     // Affiche un char de la paire surrogate, pas le smiley complet
System.out.println(s.codePointAt(1));// Affiche le code Unicode complet du smiley
```

Ainsi, il faut Ãªtre vigilant lors du traitement de chaÃ®nes contenant des emojis ou des caractÃ¨res spÃ©ciaux, car la longueur dâ€™une chaÃ®ne (length) et lâ€™accÃ¨s par <code>charAt</code> ne correspondent pas toujours au nombre rÃ©el de caractÃ¨res.


## StringBuilder

Le type <code>StringBuilder</code> en Java permet de construire et de modifier efficacement des chaÃ®nes de caractÃ¨res. Contrairement Ã  la classe <code>String</code>, qui est immuable (chaque modification crÃ©e un nouvel objet), <code>StringBuilder</code> permet dâ€™ajouter, de modifier ou de supprimer des caractÃ¨res sans crÃ©er de nouveaux objets Ã  chaque opÃ©ration. Cela le rend particuliÃ¨rement utile lorsquâ€™on doit faire de nombreuses modifications ou concatÃ©nations de chaÃ®nes, par exemple lors de la lecture dâ€™un fichier ou la construction dynamique dâ€™un texte.

Lâ€™utilisation de <code>StringBuilder</code> amÃ©liore considÃ©rablement les performances, surtout dans les bouclesâ€¯: concatÃ©ner des chaÃ®nes avec <code>+</code> dans une boucle crÃ©e Ã  chaque fois une nouvelle chaÃ®ne, ce qui consomme beaucoup de mÃ©moire et ralentit le programme. <code>StringBuilder</code> Ã©vite ce problÃ¨me en travaillant sur une seule zone mÃ©moire.

Exempleâ€¯:

```java  {style=github}
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 5; i++) {
    sb.append("Ligne ").append(i).append("\n");
}
String resultat = sb.toString();
System.out.println(resultat);
```

Dans cet exemple, toutes les lignes sont ajoutÃ©es efficacement Ã  la mÃªme chaÃ®ne. Pour des opÃ©rations rÃ©pÃ©tÃ©es ou sur de gros volumes de texte, <code>StringBuilder</code> est donc le choix recommandÃ© pour de bonnes performances.


## CharSequence et subSequence()

Lâ€™interface <code>CharSequence</code> reprÃ©sente une sÃ©quence de caractÃ¨res lisibleâ€¯: elle est implÃ©mentÃ©e par plusieurs classes Java comme <code>String</code>, <code>StringBuilder</code> et <code>StringBuffer</code>. Cela permet dâ€™Ã©crire des mÃ©thodes qui acceptent nâ€™importe quel type de sÃ©quence de caractÃ¨res, et pas seulement des chaÃ®nes immuables.

La mÃ©thode <code>subSequence(int start, int end)</code> permet dâ€™obtenir une portion (sous-sÃ©quence) de la sÃ©quence de caractÃ¨res, allant de lâ€™indice <code>start</code> (inclus) Ã  <code>end</code> (exclu). Câ€™est utile pour extraire une partie dâ€™un texte sans crÃ©er une nouvelle chaÃ®ne si ce nâ€™est pas nÃ©cessaire.

Exemple avec Stringâ€¯:

```java  {style=github}
String texte = "Bonjour le monde";
CharSequence sousTexte = texte.subSequence(8, 14); // "le mon"
System.out.println(sousTexte);
```

Exemple avec StringBuilderâ€¯:

```java  {style=github}
StringBuilder sb = new StringBuilder("abcdefg");
CharSequence sousSeq = sb.subSequence(2, 5); // "cde"
System.out.println(sousSeq);
```

Utiliser <code>CharSequence</code> rend le code plus flexibleâ€¯: on peut manipuler des chaÃ®nes, des buffers ou des builders de la mÃªme faÃ§on, et extraire facilement des sous-parties avec <code>subSequence()</code>. La mÃ©thode `subSequence` Ã©vite de faire une copie inutile.

## Les tableaux et matrices

<p>Jusqu'Ã  prÃ©sent, lorsque nous avons crÃ©Ã© une variable, elle ne contenait qu'une seule donnÃ©e qui pouvait Ãªtre une donnÃ©e primitive ou une rÃ©fÃ©rence vers un objet. En effet, dans la programmation orientÃ©e objet, certaines structures ont un nombre fixe d'objets : il s'agit des tableaux. Il en existe deux types : les tableaux Ã  une dimension et les matrices Ã  deux ou trois dimensions.</p>
<p>Les tableaux (array en anglais) sont trÃ¨s courants en programmation, car ils permettent d'organiser les donnÃ©es. Ã€ partir du moment oÃ¹ nous devons concevoir un programme devant manipuler un grand nombre de donnÃ©es, il devient intÃ©ressant pour nous de les rassembler dans des tableaux. Par exemple, pour un programme chargÃ© d'organiser les nom et prÃ©nom des Ã©tudiants d'un cours, il ne serait pas efficace de dÃ©clarer une variable de type String pour chaque Ã©tudiant, car cela serait trop long. Par contre, les tableaux pourront nous aider Ã  accÃ©lÃ©rer ce travail.</p>

### Indices

<p>Un tableau est donc une liste de valeurs. Chacune d'entre elles est stockÃ©e dans le tableau Ã  une position bien prÃ©cise, appelÃ©e indice. Le tableau ci-dessous, nommÃ© salaires, contient des nombres entiers. En Java, la premiÃ¨re position dans le tableau est celle de l'indice 0. Le tableau des salaires possÃ¨de 11 valeurs dont les indices vont de 0 Ã  10.</p>

| 12 | 74 | 88 | 22 | 8 | 78 | 28 | 44 | 47 | 78 | 81 |   | Valeurs |
|----|----|----|----|---|----|----|----|----|----|----|---|---------|
| 0  | 1  | 2  | 3  | 4 | 5  | 6  | 7  | 8  | 9  | 10 |   | Indices |

<p>Pour accÃ©der Ã  une valeur du tableau, nous utilisons le nom du tableau suivi de l'indice entre crochets. Par exemple, pour accÃ©der au cinquiÃ¨me salaire du tableau, il suffit d'Ã©crire : salaire [4]. La valeur sera donc 8. L'expression salaire [4] a donc comme valeur 8. L'indice d'un tableau est un simple entier, il est donc possible d'utiliser des variables ou constantes entre crochets comme dans l'exemple ci-dessous :</p>

```java  {style=github}
// Tableau avec une prÃ©-dÃ©claration
int[] salaire = {12, 74, 88, 22, 8, 78, 28, 44, 47, 78, 81};

System.out.println(salaire[4]);
```


### DÃ©clarer et utiliser les tableaux

<p>En Java, les tableaux sont des objets; donc, pour crÃ©er un nouveau tableau, il faudra utiliser l'opÃ©rateur new. La ligne de code suivante permet de crÃ©er un tableau de salaire horaire des 10 employÃ©s d'une entreprise.</p>

```java  {style=github}
int[] salaire = new int[10];
```

<p>Cela signifie simplement que nous dÃ©clarons une variable dont le nom est salaire, dont le type est int[] (tableau d'entiers de type primitif int). Dans le cas de tableaux contenant des nombres en utilisant des types de base (int, float, etc.), le contenu du tableau est initialisÃ© avec des valeurs Ã©quivalent au zÃ©ro. Nous assignons ensuite un nouvel objet Ã  cette variable. L'objet est un tableau de 10 entiers (int [10]). 
Il est donc Ã  remarquer qu'un tableau contient plusieurs valeurs qui doivent toutes avoir le mÃªme type. Nous ne pourrions pas crÃ©er un tableau qui contiendrait des int et des double par exemple. De plus, la taille du tableau Ã©tant dÃ©cidÃ© et fixÃ©e lors de la dÃ©claration, elle ne pourra pas changer. Nous avons par consÃ©quent un tableau statique (rien Ã  voir avec les classes statiques ou le mot rÃ©servÃ© static).</p>

{{<inlineJava path="Main.java" lang="java">}}
public class Main {

    public static void main(String[] args) {

        final int MAX = 10;

        int[] list = new int[MAX];

        // Remplit le tableau
        for (int i = 0; i < MAX; i++) {
            list[i] = i * 20;
        }

        // On change la quatriÃ¨me valeur
        list[3] = 777;

        // On affiche le contenu du tableau
        for (int i = 0; i < MAX; i++) {
            System.out.print(list[i] + " ");
        }
    }

}
{{</inlineJava>}}



<p>Le rÃ©sultat de l'exÃ©cution donnera ceci :</p> 
<pre><strong>0 20 40 777 80 100 120 140 160 180 </strong></pre>

<p>Cet exemple montre Ã©galement une bonne utilisation des constantes. En effet, si nous voulons un tableau de taille 15, il n'y a qu'une ligne de code Ã  changer, Ã  savoir la valeur de la constante MAX. Les crochets utilisÃ©s pour accÃ©der Ã  un Ã©lÃ©ment d'un tableau sont un opÃ©rateur Java comme + ou =. Cet opÃ©rateur a la plus haute prioritÃ© et sera donc exÃ©cutÃ© en premier. 
L'opÃ©rateur d'indexation de tableau ([]) vÃ©rifie automatiquement si l'indice est correct, c'est-Ã -dire s'il est positif et est plus petit que la taille du tableau - 1. Si tel n'est pas le cas, il se produira une erreur d'exÃ©cution.</p>

```java  {style=github}
int[] tableau = new int[2];
tableau [0] = 0;
tableau [1] = 1;
System.out.println (tableau [1]);
//Appel dans un index hors du tableau
System.out.println (tableau [2]);
```

<p>Erreur d'indice <br />L'exÃ©cution de ce code produira la sortie suivante Ã  la console :</p> 
<p><em>java.lang.ArrayIndexOutOfBoundsException: 2 at Test.main(Test.java:18)</em> <br /><em>Exception in thread "main"</em></p> 
<p><br />Ã‰tant donnÃ© que le premier indice est de 0, il arrive souvent des erreurs d'indice trop Ã©levÃ© d'une position. Le programmeur doit donc Ãªtre vigilant et s'assurer que les indices restent dans les limites du tableau. <br />La taille d'un tableau est rÃ©gie par une variable d'instance de l'objet tableau appelÃ©e <em>length</em>. Donc, pour connaÃ®tre la taille d'un tableau, il suffit de consulter le contenu de cette variable Ã  l'aide de l'opÃ©rateur d'accÃ¨s point.</p> 

```java  {style=github}
int[] tableau = new int[5];
System.out.println (tableau.length); // Affiche 5 Ã  la console
```

## Instanciation d'un tableau

<p>Nous pouvons instancier autrement un tableau. Il suffit de donner directement les valeurs qu'il contient. Nous affecterons une <em>liste d'initialisation</em> ou <em>initialisateur</em> au tableau. Les Ã©lÃ©ments du tableau sont repris entre des accolades et sÃ©parÃ©s par des virgules. Par exemple, pour crÃ©er le tableau ci-dessous, nous pourrions Ã©crire :</p> 

```java  {style=github}
int[] tableau = {20, 17, 21, 19, 18, 20};
```

### Initialisateur


Nous ne pouvons utiliser une liste d'initialisation que pour la premiÃ¨re dÃ©claration. De plus, il faut impÃ©rativement la combiner avec la dÃ©claration de la variable. Il est impossible de le faire en deux Ã©tapes. Par exemple, le code ci-dessous produit une erreur de compilation.</p> 

```java  {style=github}
int[] tab = new int[3];
tab = {1, 2, 3};
```

<p>Initialisateur : erreur de compilation </p> 
<pre>java.lang.Error: Unresolved compilation problem: </pre> 
<pre>        Array constants can only be used in initializers 
</pre> 

### Passer des tableaux en paramÃ¨tre

<p>Nous pouvons passer un tableau complet en paramÃ¨tre Ã  une mÃ©thode, car les tableaux ne sont rien d'autre que des objets. Il ne faut donc pas oublier que ce qui sera donnÃ© Ã  la mÃ©thode n'est pas le tableau, ni une copie de celui-ci mais bien une copie de la rÃ©fÃ©rence vers le tableau. 
Nous pouvons bien entendu passer en paramÃ¨tre un seul Ã©lÃ©ment d'un tableau. S'il s'agit d'une donnÃ©e primitive, une copie de celle-ci sera passÃ©e en paramÃ¨tre. S'il s'agit d'un objet, une copie de la rÃ©fÃ©rence sera passÃ©e en paramÃ¨tre. 
La mÃ©thode ci-dessous dÃ©place tous les Ã©lÃ©ments du tableau d'une position vers la droite.</p>

```java  {style=github}
public class AfficheDeplacer {
    public static void main(String[] args) {
        int[] tableau = {11, 22, 33, 44};

        print(tableau);
        deplacerADroite(tableau);
        print(tableau);
    }

    private static void deplacerADroite(int[] tableau) {
        int last = tableau[tableau.length - 1];

        for (int i = tableau.length - 1; i > 0; i--) {
            tableau[i] = tableau[i - 1];
        }

        tableau[0] = last;
    }

    private static void print(int[] tableau) {

        for (int i = 0; i < tableau.length; i++) {
            System.out.print(tableau[i] + " ");
        }

        System.out.println();
    }

}
```

### Tableaux d'objets

<p>Dans tous les exemples que nous avons vus jusqu'Ã  prÃ©sent, les tableaux contenaient uniquement des types primitifs. Dans la derniÃ¨re partie de la section prÃ©cÃ©dente, nous avons vu des tableaux qui pouvaient contenir des objets, ou plus prÃ©cisÃ©ment des rÃ©fÃ©rences vers des objets. 
Il est possible de stocker des objets dans un tableau. La ligne de code suivant crÃ©e un tableau de 20 objets de type String.</p>

```java  {style=github}
String[] phrases = new String[20];
```

### Quelques techniques utiles

<p>Nous sommes maintenant davantage en mesure de comprendre la signature de la mÃ©thode main. Nous voyons en paramÃ¨tre un tableau de String. En rÃ©alitÃ©, lorsque nous lanÃ§ons un programme Java, nous savons dÃ©jÃ  que la mÃ©thode main sera automatiquement appelÃ©e, mais qu'il est possible de lui passer des paramÃ¨tres. En fait, nous pouvons lui passer un tableau de String.

Nous donnons en fait Ã  la mÃ©thode main une chaÃ®ne de caractÃ¨res qui sera dÃ©coupÃ©e en morceaux dÃ©limitÃ©s par des espaces. Il est ensuite possible d'utiliser ces paramÃ¨tres dans la mÃ©thode, comme l'illustre le programme suivant :</p>

```java  {style=github}
public static void main(String[] args) {
        if (args.length != 0) {
            System.out.println(args[0]);
        } else {
            System.out.println();
            System.out.println("Aucun argument sur la ligne de commande");
        }
}
```

### Trier un ensemble de donnÃ©es

<p>L'atout principal de l'ordinateur est sa capacitÃ© de traiter trÃ¨s rapidement une immense quantitÃ© de donnÃ©es (par exemple, la recherche d'Ã©lÃ©ments dans un ensemble selon des contraintes choisies par l'utilisateur ou encore le tri d'Ã©lÃ©ments en fonction d'un critÃ¨re dÃ©terminÃ©). 
Le tri d'informations fait partie des nombreuses applications en informatique. Il y a n! (factoriel n) faÃ§ons d'ordonner une collection de n Ã©lÃ©ments. Les donnÃ©es triÃ©es permettent une recherche d'informations plus efficace. Le choix d'un algorithme de tri est par consÃ©quent un critÃ¨re plus pertinent que la vitesse intrinsÃ¨que de l'ordinateur.</p>

<p>Un tri simple de donnÃ©es consiste Ã  rechercher la valeur minimale d'un tableau ou sa valeur maximale. GrÃ¢ce Ã  un algorithme de recherche, nous assignons la valeur minimale Ã  la premiÃ¨re valeur, puis parcourons l'ensemble des valeurs pour tester si l'une d'entre elles est plus petite que la valeur minimale. Si tel est le cas, la valeur minimale est assignÃ©e Ã  cette valeur, sinon, le tri se poursuit. </p>

<p>RÃ©alisation de l'algorithme Â« recherche du minimum Â» en Java :</p>

```java  {style=github}
public static int minimum(int a[]) {
        int min = a[0];
        for (int i = 1; i < a.length; i++) {
            if (a[i] < min) {
                min = a[i];
            }
        }
        return min;
}
```


<p>La recherche de la valeur maximale est trÃ¨s similaire : il suffit de changer le critÃ¨re de comparaison.
La rÃ©alisation sous la forme d'une mÃ©thode Java est, par consÃ©quent, aussi similaire :</p>

```java  {style=github}
public static int maximum(int a[]) {
        int max = a[0];
        for (int i = 1; i < a.length; i++) {
            if (a[i] > max)
                max = a[i];
        }
        return max;
}
```




En Java, le tri est une opÃ©ration courante pour ordonner des collections dâ€™objets, comme des listes ou des tableaux. La bibliothÃ¨que standard propose plusieurs mÃ©thodes de tri, notamment via la classe Collections (pour les collections) et la classe Arrays (pour les tableaux). Ces mÃ©thodes sâ€™appuient souvent sur lâ€™interface Comparator pour dÃ©finir un ordre personnalisÃ©, surtout lorsque les objets ne suivent pas un ordre naturel (comme les chaÃ®nes ou les nombres) ou lorsque lâ€™ordre par dÃ©faut ne convient pas.

Lâ€™interface Comparator dÃ©finit une mÃ©thode abstraite, compare(T o1, T o2), qui retourne :

- Une valeur nÃ©gative si o1 doit prÃ©cÃ©der o2.
- ZÃ©ro si o1 et o2 sont Ã©quivalents dans lâ€™ordre.
- Une valeur positive si o1 doit suivre o2.


Ce cas montre comment trier une liste de chaÃ®nes en utilisant un comparator pour inverser lâ€™ordre alphabÃ©tique naturel.

{{<inlineJava path="TriInverse.java" lang="java">}}
import java.util.Arrays;
import java.util.Comparator;

public class TriInverse {
    public static void main(String[] args) {
        String[] mots = {"banane", "pomme", "ananas", "cerise"};
        Arrays.sort(mots, Comparator.reverseOrder());
        System.out.println("Mots triÃ©s en ordre alphabÃ©tique inverse : " + Arrays.toString(mots));
    }
}
{{</inlineJava>}}



Le prochain code Java illustre une maniÃ¨re simple et claire de trier une liste de mots en fonction de leur longueur, de la plus courte Ã  la plus longue. Le programme commence par importer des outils Java essentiels : Arrays pour crÃ©er des listes, List pour gÃ©rer une collection de donnÃ©es, et Comparator pour dÃ©finir une rÃ¨gle de tri personnalisÃ©e. Une classe spÃ©ciale, LongueurComparator, est crÃ©Ã©e pour comparer deux mots en soustrayant la longueur du premier mot de celle du second, ce qui permet de les classer par ordre de taille. Dans la mÃ©thode principale (main), une liste de mots ("chat", "Ã©lÃ©phant", "chien", "girafe") est initialisÃ©e, puis triÃ©e Ã  lâ€™aide de cette rÃ¨gle de comparaison. Enfin, le programme affiche la liste triÃ©e, montrant les mots dans lâ€™ordre suivant : "chat", "chien", "girafe", "Ã©lÃ©phant".

{{<inlineJava path="ExempleLongueur.java" lang="java">}}
import java.util.Arrays;
import java.util.Comparator;

public class ExempleLongueur {
    // Nouvelle classe Comparator
    static class LongueurComparator implements Comparator<String> {
        @Override
        public int compare(String a, String b) {
            return a.length() - b.length();
        }
    }

    public static void main(String[] args) {
        String[] mots = {"chat", "Ã©lÃ©phant", "chien", "girafe"};
        Arrays.sort(mots, new LongueurComparator());
        System.out.println("Mots triÃ©s par longueur : " + Arrays.toString(mots));
    }
}
{{</inlineJava>}}


Cet exemple illustre la notion de classe statique. Une classe statique en Java est une classe imbriquÃ©e (dÃ©finie Ã  l'intÃ©rieur d'une autre classe) dÃ©clarÃ©e avec le mot-clÃ© static. Elle est associÃ©e Ã  la classe englobante plutÃ´t qu'Ã  une instance spÃ©cifique de cette classe. Cela signifie qu'elle peut Ãªtre utilisÃ©e sans instancier la classe englobante, et elle ne peut accÃ©der qu'aux membres statiques (variables ou mÃ©thodes) de la classe englobante.

{{<inlineJava path="Voiture.java" lang="java">}}
public class Voiture {
    private static String marque = "Toyota";
    
    // Classe statique imbriquÃ©e
    public static class Moteur {
        private int puissance;
        
        public Moteur(int puissance) {
            this.puissance = puissance;
        }
        
        public void afficherDetails() {
            System.out.println("Marque de la voiture : " + marque);
            System.out.println("Puissance du moteur : " + puissance + " chevaux");
        }
    }
    
    public static void main(String[] args) {
        // CrÃ©ation d'une instance de la classe statique sans instancier Voiture
        Voiture.Moteur moteur = new Voiture.Moteur(150);
        moteur.afficherDetails();
    }
}
{{</inlineJava>}}

On peut aussi rÃ©gler ce problÃ¨me avec une classe anonyme. Une classe anonyme en Java est une classe sans nom, dÃ©finie et instanciÃ©e en une seule expression. Elle est gÃ©nÃ©ralement utilisÃ©e pour fournir une implÃ©mentation ponctuelle d'une interface ou pour Ã©tendre une classe, souvent dans des situations oÃ¹ une implÃ©mentation unique et temporaire est nÃ©cessaire. Les classes anonymes sont couramment utilisÃ©es avec des interfaces comme Comparator, Runnable, ou des Ã©couteurs d'Ã©vÃ©nements. En voici un exemple&nbsp;:

{{<inlineJava path="ExempleLongueur.java" lang="java">}}
import java.util.Arrays;
import java.util.Comparator;

public class ExempleLongueur {
    public static void main(String[] args) {
        String[] mots = {"chat", "Ã©lÃ©phant", "chien", "girafe"};
        
        // Utilisation d'une classe anonyme pour implÃ©menter Comparator
        Arrays.sort(mots, new Comparator<String>() {
            @Override
            public int compare(String a, String b) {
                return a.length() - b.length();
            }
        });
        
        System.out.println("Mots triÃ©s par longueur : " + Arrays.toString(mots));
    }
}
{{</inlineJava>}}



## Les tableaux Ã  plusieurs dimensions (Matrices)

<p>Les tableaux que nous avons utilisÃ©s jusqu'Ã  prÃ©sent sont des tableaux Ã  une seule dimension. Il suffit d'un seul indice pour identifier un Ã©lÃ©ment de ces types de tableaux. Ce sont donc de simples listes de valeurs.</p> 

### Tableau Ã  deux dimensions

<p>Un tableau Ã  deux dimensions est un tableau avec des lignes et des colonnes. Contrairement Ã  un tableau Ã  une dimension, il faut utiliser deux indices pour accÃ©der aux Ã©lÃ©ments des tableaux Ã  deux dimensions. Le premier indice reprÃ©sente la ligne et le second, la colonne. La figure ci-dessous, nommÃ©e Tableau Ã  deux dimensions, reprÃ©sente un tableau Ã  deux dimensions.</p>
<p style="text-align: left;"> Tableau 1. Tableau Ã  deux dimensions</p>

|        | Colonne 0 | Colonne 1 | Colonne 2 | Colonne 3 |
|--------|-----------|-----------|-----------|-----------|
| Ligne 0| 11        | 12        | 12        | 4         |
| Ligne 1| 87        | 45        | 32        | 6         |
| Ligne 2| 64        | 56        | 22        | 55        |
| Ligne 3| 37        | 32        | 91        | 33        |
| Ligne 4| 93        | 35        | 54        | 43        |

<p>Pour avoir accÃ¨s Ã  un Ã©lÃ©ment du tableau 1, il faut Ã©crire tableau_1[Ligne][Colonne]. Ainsi :</p> 
<p>tableau_1[Ligne 0][Colonne 0] = 11</p> 
<p>tableau_1[Ligne 4][Colonne 2] = 54</p> 
<p>tableau_1[Ligne 2][Colonne 1] = 56</p> 
<p>....</p> 

### CrÃ©ation de tableaux Ã  deux dimensions

<p>La premiÃ¨re dimension spÃ©cifie que le tableau contient cinq Ã©lÃ©ments et reprÃ©sente les cinq lignes achats.  La seconde dimension spÃ©cifie que chacun de ces cinq Ã©lÃ©ments est formÃ© d'un tableau de type double de quatre Ã©lÃ©ments qui reprÃ©sente les colonnes d'achats.</p>

|       | semaine 1 | semaine 2 | semaine 3 | semaine 4 |
|-------|-----------|-----------|-----------|-----------|
| 2010  | 11        | 123       | 455       | 4         |
| 2009  | 87        | 45        | 32        | 6         |
| 2008  | 64        | 56        | 22        | 55        |
| 2007  | 37        | 32        | 91        | 33        |
| 2006  | 93        | 35        | 54        | 43        |

<p>Pour dÃ©clarer un tableau Ã  deux dimensions, il faut simplement Ã©crire :</p> 
<p><em>typededonnÃ©es NonDuTableau [nombreDeLignes][nombreDeColonne]</em></p> 
<p>Plus concrÃ¨tement, nous pouvons dÃ©clarer un tableau Ã  deux dimensions pour inscrire des achats du mois en faisant :</p> 

```java  {style=github}
double achats [][]; //achats est ici un tableau Ã  deux dimensions de type double des achats.
```

<p>Une fois que le tableau est dÃ©clarÃ©, il faut le crÃ©er en utilisant le mot clÃ© <em>new.</em></p> 
<p>Ainsi, pour crÃ©er les achats des quatre semaines du mois de juillet des cinq derniÃ¨res annÃ©es, nous allons faire :</p> 

```java  {style=github}
achats = new double [5][4];
```

<p>La premiÃ¨re dimension spÃ©cifie que le tableau contient cinq Ã©lÃ©ments et reprÃ©sente les cinq lignes achats.  La seconde dimension spÃ©cifie que chacun de ces cinq Ã©lÃ©ments est formÃ© d'un tableau de type double de quatre Ã©lÃ©ments qui reprÃ©sente les colonnes d'achats.</p> 
<p> </p> 



|       | Semaine 1 | Semaine 2 | Semaine 3 | Semaine 4 |
|-------|-----------|-----------|-----------|-----------|
| 2010  | 11        | 123       | 455       | 4         |
| 2009  | 87        | 45        | 32        | 6         |
| 2008  | 64        | 56        | 22        | 55        |
| 2007  | 37        | 32        | 91        | 33        |
| 2006  | 93        | 35        | 54        | 43        |

<p> </p> 
<p><strong><u>Achats</u></strong></p> 
<p>Il faut noter ici que rien ne nous empÃªche de dÃ©clarer et de crÃ©er en mÃªme temps un tableau. Pour cela, il faut simplement faire :</p> 

```java  {style=github}
typeDeTableau [][] nomDuTableau = new typeDeTableau [nombreDeLigne][nombreDeColonne];
```

  <p>Ainsi dans le cas de Achats, nous pouvons Ã©crire :</p> 

```java  {style=github}
double[][] Achats = new double [5][4];
```

  <p>Ainsi <em>Achats</em> est dÃ©clarÃ© et crÃ©Ã© simultanÃ©ment.</p> 
 
### Manipulation d'un tableau Ã  2 dimensions

  <p>Pour accÃ©der Ã  un Ã©lÃ©ment du tableau <em>Achats</em>, il faut Ã©crire, par exemple :</p> 
  <p>Achats [0][0] = 11 pour l'Ã©lÃ©ment Ã  la ligne 0 colonne 0. Il est cependant important de noter que si nous avons des milliers d'Ã©lÃ©ments, cette faÃ§on de faire ne sera pas commode. Ainsi, avec deux boucles <em>for </em>imbriquÃ©es, nous pouvons accÃ©der plus facilement aux Ã©lÃ©ments de Achats. La portion de programme suivant le montre facilement :</p> 

```java  {style=github}
int annees = 2010; // initialisation de l'annÃ©e selon l'indice 0 du tableau Achats
      
for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 4; j++) {
        System.out.println("Achats [" + i + "][" + j + "] =" + achats[i][j]);
    }
}
```

  <p>Pour initialiser un tableau Ã  deux dimensions, nous pouvons simplement Ã©crire :</p> 

```java  {style=github}
typeDeTableau nomDuTableau [][] = { { }, {}, {}, etc...};
```

  <p>Ainsi, pour un tableau composÃ© des noms des Ã©tudiants et des cours qu'ils suivent peut Ãªtre dÃ©fini de la maniÃ¨re suivante :</p> 

```java  {style=github}
String etudiants[][] = { {"nom", "cours"}, {"nom", "cours"}, {"nom", "cours"}, {"nom", "cours"} etc...};
```


ConsidÃ©rons l'exemple suivant. Le code implÃ©mente un modÃ¨le de langue simple en Java qui calcule les probabilitÃ©s de transition entre caractÃ¨res ASCII dans une chaÃ®ne donnÃ©e, puis gÃ©nÃ¨re une sÃ©quence de 100 caractÃ¨res Ã  partir d'un caractÃ¨re initial. Il utilise un tableau Ã  deux dimensions double[][] transitions de taille 128x128 pour stocker les probabilitÃ©s quâ€™un caractÃ¨re ASCII (0-127) soit suivi dâ€™un autre. Dans calculerTransitions, le programme compte les occurrences des paires de caractÃ¨res consÃ©cutifs dans le texte dâ€™entrÃ©e et normalise ces comptes pour obtenir des probabilitÃ©s, stockÃ©es dans transitions[i][j], oÃ¹ i est le caractÃ¨re courant et j le suivant. Lors de la gÃ©nÃ©ration dans genererCaractereSuivant, ce tableau est utilisÃ© pour sÃ©lectionner alÃ©atoirement le caractÃ¨re suivant en fonction des probabilitÃ©s associÃ©es au caractÃ¨re courant. Cette application des tableaux Ã  deux dimensions permet de modÃ©liser efficacement les relations entre caractÃ¨res, chaque cellule reprÃ©sentant une probabilitÃ© de transition, et facilite la gÃ©nÃ©ration de texte en sâ€™appuyant sur une structure matricielle claire et organisÃ©e.

{{<inlineJava path="ModeleLangue.java" lang="java">}}

import java.util.Random;

public class ModeleLangue {
    private static final int ASCII_SIZE = 128; // Taille de la table ASCII (0-127)
    private double[][] transitions; // Matrice des probabilitÃ©s de transition
    private Random random;

    // Constructeur qui calcule les probabilitÃ©s de transition Ã  partir d'une chaÃ®ne
    public ModeleLangue(String texte) {
        transitions = new double[ASCII_SIZE][ASCII_SIZE];
        random = new Random();
        calculerTransitions(texte);
    }

    // Calcule les probabilitÃ©s de transition
    private void calculerTransitions(String texte) {
        // Compter les transitions
        int[][] compte = new int[ASCII_SIZE][ASCII_SIZE];
        int[] totalParCaractere = new int[ASCII_SIZE];

        // Parcourir la chaÃ®ne pour compter les transitions
        for (int i = 0; i < texte.length() - 1; i++) {
            char courant = texte.charAt(i);
            char suivant = texte.charAt(i + 1);
            // VÃ©rifier que les caractÃ¨res sont dans la plage ASCII
            if (courant < ASCII_SIZE && suivant < ASCII_SIZE) {
                compte[courant][suivant]++;
                totalParCaractere[courant]++;
            }
        }

        // Calculer les probabilitÃ©s
        for (int i = 0; i < ASCII_SIZE; i++) {
            if (totalParCaractere[i] > 0) {
                for (int j = 0; j < ASCII_SIZE; j++) {
                    transitions[i][j] = (double) compte[i][j] / totalParCaractere[i];
                }
            }
        }
    }

    // GÃ©nÃ¨re un caractÃ¨re suivant basÃ© sur les probabilitÃ©s
    private char genererCaractereSuivant(char courant) {
        if (courant >= ASCII_SIZE) {
            return (char) random.nextInt(ASCII_SIZE); // CaractÃ¨re hors plage
        }

        double somme = 0.0;
        for (double prob : transitions[courant]) {
            somme += prob;
        }

        // Si aucune transition n'existe, choisir un caractÃ¨re alÃ©atoire
        if (somme == 0.0) {
            return (char) random.nextInt(ASCII_SIZE);
        }

        // SÃ©lection alÃ©atoire basÃ©e sur les probabilitÃ©s
        double r = random.nextDouble();
        double cumul = 0.0;
        for (int i = 0; i < ASCII_SIZE; i++) {
            cumul += transitions[courant][i];
            if (r <= cumul) {
                return (char) i;
            }
        }
        // En cas d'erreur (arrondi), retourner le dernier caractÃ¨re possible
        return (char) (ASCII_SIZE - 1);
    }

    // GÃ©nÃ¨re une sÃ©quence de longueur donnÃ©e Ã  partir d'un caractÃ¨re initial
    public String genererSequence(char debut, int longueur) {
        StringBuilder sequence = new StringBuilder();
        sequence.append(debut);
        char courant = debut;

        for (int i = 0; i < longueur - 1; i++) {
            courant = genererCaractereSuivant(courant);
            sequence.append(courant);
        }

        return sequence.toString();
    }

    public static void main(String[] args) {
        // Exemple de texte d'entraÃ®nement
        String texte = "bonjour le monde c'est un test simple pour modeller une langue en java";
        ModeleLangue modele = new ModeleLangue(texte);
        
        // GÃ©nÃ©rer une sÃ©quence de 100 caractÃ¨res Ã  partir du caractÃ¨re 'b'
        String sequence = modele.genererSequence('b', 100);
        System.out.println("SÃ©quence gÃ©nÃ©rÃ©e : " + sequence);
    }
}
{{</inlineJava>}}


### Tableaux multidimensionnels

  <p>Java ne se limite pas seulement aux tableaux Ã  deux dimensions. Nous pouvons aussi dÃ©clarer des tableaux Ã  plus de deux dimensions. Pour dÃ©clarer un tableau Ã  trois dimensions, par exemple, il suffit de faire : </p> 

```java  {style=github}
typedetableau [][][] nomdutableau = new [taille][taille][taille];
```

  <p>Plus concrÃ¨tement, nous pouvons dÃ©clarer un tableau d'entiers comme :<br /></p> 

```java  {style=github}
int tableauEntier [][][] = new int [5][5][5];
```

  <p>Nous venons ainsi de crÃ©er un tableau d'entiers Ã  trois dimensions. Pour initialiser un tel tableau, nous pouvons utiliser trois boucles <em>for</em>. Ã€ titre d'exemples, initialisons tous les Ã©lÃ©ments du tableau <em>tableauentier Ã  1 :</em></p> 

```java  {style=github}
for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 5; j++) {
        for (int k = 0; k < 5; k++) {
            tableauEntier[i][j][k] = 1;
        }
    }
}
```

<p><a id="intro" name="section2"></a></p>

## Les ArrayLists

Une ArrayList est une structure de donnÃ©es de type "Collection", similaire Ã  un tableau, mais avec une taille indÃ©finie. Bref, comme une liste d'items, sa taille change au fur et Ã  mesure de l'ajout ou du retrait d'Ã©lÃ©ments et s'utilise Ã  la faÃ§on d'un tableau grÃ¢ce Ã  la mÃ©thode get(i), oÃ¹ i est l'index du tableau. L'objet ArrayList possÃ¨de un ensemble de mÃ©thodes permettant de manipuler les donnÃ©es (ex. get, remove, isEmpty, toArray). De plus, les ArrayList utilisent le systÃ¨me de template (Ã  voir en dÃ©tail un peu plus loin), qui permet de crÃ©er des ArrayList pour un type d'Objet en particulier, par exemple : "`ArrayList<String>`, `ArrayList<Double>`, `ArrayList<ArrayList<Integer>>`" (Oui c'est possible ... pour simuler une matrice par exemple),etc. Voici un exemple d'instanciation et d'utilisation d'une ArrayList.



{{<inlineJava path="Main.java" lang="java">}}
import java.util.*;

class Main {
  public static void main(String[] args) {
    	
    	
    	ArrayList<String> list = new ArrayList<String>();
        
    	//Permet d'ajout un Ã©lÃ©ment
    	list.add("Valeur1");

    	//Permet de modifier une valeur Ã  un index particulier
    	list.set(0, "Valeur2");
    	            
    	//Permet d'accÃ©der Ã  un Ã©lÃ©ment
    	System.out.println(list.get(0));
    	            
    	//Permet de vÃ©rifier si la structure est vide ou non
    	System.out.println(list.isEmpty());
    	            
    	//Permet de retirer un Ã©lÃ©ment
    	list.remove(0);
    	            
    	//Permet de retourner une version tableau de l'ArrayList. 
    	String[] tableau = new String[list.size()];
      for(int i = 0; i < list.size(); i++) {
        tableau[i] = (String)list.get(i);
      } 
      // Attention: list.toArray() retourne 
      // un object de type Object[]. The type
      // String[] n'est pas un sous-type du 
      // type Object[]. On ne peut donc pas faire:
      //
      // String[] tableau = list.toArray(); // Non!!!
  }
}
{{</inlineJava>}}

<p>Comme nous l'avions vu lors de la prÃ©sentation de la structure d'itÃ©ration while, il est possible d'itÃ©rer rapidement parmi les Ã©lÃ©ments d'une ArrayList. Pour ce faire, voici trois faÃ§ons d'itÃ©rer parmi les Ã©lÃ©ments : </p>

```java  {style=github}
ArrayList<String> list = new ArrayList<String>();                        
list.add("Valeur1");

//Avec le traditionnel for
for(int i = 0; i < list.size();i++){
    System.out.println(list.get(i));
}

//Avec le for est un raccourci du compilateur. La variable s sera chaque Ã©lÃ©ment de la liste
for(String s : list) {
    System.out.println(s);
}

//La mÃ©thode plus ancienne (Java 1.6) avec les itÃ©rateurs
Iterator<String> it = list.iterator();
while(it.hasNext()) {
    System.out.println(it.next());
}
```

<p>En conclusion, les ArrayList sont des structures de donnÃ©es utiles. Vous verrez dans la suite du cours plusieurs utilisations des ArrayList.</p>

<p><a id="intro" name="section3"></a></p>

## Autres structures de donnÃ©es

### Stack (Pile)

Une <strong>Stack</strong> (ou pile) est une structure de donnÃ©es fondamentale qui fonctionne selon le principe Â« dernier arrivÃ©, premier sorti Â» (LIFOâ€¯: Last In, First Out). Cela signifie que le dernier Ã©lÃ©ment ajoutÃ© Ã  la pile sera le premier Ã  en sortir. Les opÃ©rations principales sont <code>push</code> (empiler), <code>pop</code> (dÃ©piler) et <code>peek</code> (regarder le sommet sans retirer). Les piles sont utilisÃ©es dans de nombreux contextesâ€¯: gestion des appels de fonctions, annulation dâ€™actions, analyse dâ€™expressions, etc.

En Java, la classe <code>Stack</code> permet dâ€™utiliser facilement cette structureâ€¯: on peut y empiler des objets de tout type, puis les dÃ©piler dans lâ€™ordre inverse de leur ajout. Voici un exemple simpleâ€¯:

```java  {style=github}
import java.util.Stack;

public class ExempleStack {
    public static void main(String[] args) {
        Stack<Integer> pile = new Stack<>();
        pile.push(10);
        pile.push(20);
        pile.push(30);
        System.out.println(pile.pop()); // Affiche 30
        System.out.println(pile.peek()); // Affiche 20 (sans dÃ©piler)
    }
}
```

Dans cet exemple, on empile trois entiersâ€¯; le <code>pop()</code> retire et retourne le dernier ajoutÃ© (30), puis <code>peek()</code> permet de consulter le sommet (20) sans le retirer.

### HashMap (Table de hachage)

Une <strong>HashMap</strong> est une structure de donnÃ©es qui associe des clÃ©s Ã  des valeurs. Elle permet de retrouver trÃ¨s rapidement une valeur Ã  partir de sa clÃ©, grÃ¢ce Ã  une fonction de hachage qui transforme la clÃ© en un index. Les <code>HashMap</code> sont trÃ¨s utiles pour stocker des associations uniques, comme des noms dâ€™Ã©tudiants et leurs notes, ou des mots et leurs dÃ©finitions.

Une caractÃ©ristique importanteâ€¯: si on ajoute plusieurs fois la mÃªme clÃ©, la nouvelle valeur Ã©crase lâ€™ancienne. Par exemple, si on fait <code>map.put("clÃ©", 1)</code> puis <code>map.put("clÃ©", 2)</code>, la valeur associÃ©e Ã  "clÃ©" sera 2. Si on cherche une clÃ© qui nâ€™est pas prÃ©sente, <code>get</code> retourne <code>null</code> (ou lÃ¨ve une exception si on utilise <code>getOrDefault</code> ou <code>get</code> sur des types primitifs).

Voici un exemple dâ€™utilisationâ€¯:

```java  {style=github}
import java.util.HashMap;

public class ExempleHashMap {
    public static void main(String[] args) {
        HashMap<String, Integer> notes = new HashMap<>();
        notes.put("Alice", 85);
        notes.put("Bob", 92);
        notes.put("Alice", 90); // Remplace la note prÃ©cÃ©dente d'Alice
        System.out.println(notes.get("Alice")); // Affiche 90
        System.out.println(notes.get("Charlie")); // Affiche null (clÃ© absente)
    }
}
```

Dans cet exemple, la note dâ€™Alice est dâ€™abord 85, puis remplacÃ©e par 90. La recherche dâ€™une clÃ© absente ("Charlie") retourne <code>null</code>.

### PriorityQueue (File de prioritÃ©)

Une <strong>PriorityQueue</strong> (file de prioritÃ©) est une structure de donnÃ©es qui permet de toujours extraire lâ€™Ã©lÃ©ment ayant la plus haute prioritÃ© (par dÃ©faut, le plus petit selon lâ€™ordre naturel). Contrairement Ã  une file classique (FIFO), la PriorityQueue trie automatiquement ses Ã©lÃ©ments selon leur prioritÃ©. Elle est trÃ¨s utilisÃ©e pour la gestion de files dâ€™attente avec prioritÃ©s, les algorithmes de plus court chemin (Dijkstra), ou la planification de tÃ¢ches.

En Java, la classe <code>PriorityQueue</code> permet dâ€™ajouter des Ã©lÃ©ments avec <code>add</code> ou <code>offer</code>, et dâ€™extraire le plus prioritaire avec <code>poll</code> (qui le retire) ou <code>peek</code> (qui le consulte sans le retirer). Par dÃ©faut, les Ã©lÃ©ments sont triÃ©s dans lâ€™ordre croissant, mais on peut fournir un comparateur personnalisÃ©.

Voici un exemple simpleâ€¯:

```java  {style=github}
import java.util.PriorityQueue;

public class ExemplePriorityQueue {
    public static void main(String[] args) {
        PriorityQueue<Integer> file = new PriorityQueue<>();
        file.add(30);
        file.add(10);
        file.add(20);
        System.out.println(file.poll()); // Affiche 10 (le plus petit)
        System.out.println(file.peek()); // Affiche 20 (le prochain plus petit)
    }
}
```

Dans cet exemple, les entiers sont extraits dans lâ€™ordre croissant. On peut aussi utiliser des objets et dÃ©finir lâ€™ordre de prioritÃ© avec un comparateur.

## Lambdas

Une fonction lambda, ou expression lambda, est une fonction anonyme concise dÃ©finie sans nom, souvent utilisÃ©e pour des opÃ©rations simples et ponctuelles. Elle permet d'Ã©crire du code plus compact, notamment dans des contextes oÃ¹ une fonction est passÃ©e en argument, comme pour des opÃ©rations de filtrage ou de tri. En Java, par exemple, les lambdas s'appuient sur les interfaces fonctionnelles, qui possÃ¨dent une unique mÃ©thode abstraite. Leur syntaxe est de la forme (paramÃ¨tres) -> expression ou (paramÃ¨tres) -> { instructions; } pour des blocs plus complexes.

Voici un exemple de code Java avec une mÃ©thode main utilisant une lambda pour trier une liste de chaÃ®nes par longueur :

{{<inlineJava path="ExempleLambda.java" lang="java">}}
import java.util.Arrays;
import java.util.List;
import java.util.Comparator;

public class ExempleLambda {
    public static void main(String[] args) {
        List<String> mots = Arrays.asList("chat", "Ã©lÃ©phant", "chien", "girafe");
        mots.sort((a, b) -> a.length() - b.length());
        System.out.println("Mots triÃ©s par longueur : " + mots);
    }
}
{{</inlineJava>}}

Ce code dÃ©finit une liste de mots, utilise une lambda pour trier les Ã©lÃ©ments par longueur croissante, puis affiche le rÃ©sultat. La lambda (a, b) -> a.length() - b.length() remplace une implÃ©mentation complÃ¨te de Comparator.


Les lambdas sont utilisÃ©s Ã  de multiples fins en Java. Lâ€™API Stream en Java pour effectuer un filtrage fonctionnel sur une liste de nombres. ConsidÃ©rons le prochain exemple. Le premier concept clÃ© est la crÃ©ation dâ€™une liste immuable avec Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8). Cette mÃ©thode transforme un tableau de nombres en une List fixe, qui ne peut pas Ãªtre modifiÃ©e (par exemple, pas dâ€™ajout ou de suppression dâ€™Ã©lÃ©ments). Cette liste, nommÃ©e nombres, sert de point de dÃ©part pour le traitement. Ensuite, lâ€™opÃ©ration de filtrage repose sur lâ€™API Stream, introduite en Java 8, qui permet de manipuler des collections de maniÃ¨re dÃ©clarative, en exprimant ce quâ€™on veut obtenir (ici, les nombres pairs) plutÃ´t que comment le faire (comme avec une boucle traditionnelle). Ce paradigme fonctionnel rend le code plus concis et expressif.

{{<inlineJava path="ExempleLambdaFiltre.java" lang="java">}}
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class ExempleLambdaFiltre {
    public static void main(String[] args) {
        List<Integer> nombres = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);
        List<Integer> nombresPairs = nombres.stream()
                                           .filter(n -> n % 2 == 0)
                                           .collect(Collectors.toList());
        System.out.println("Nombres pairs : " + nombresPairs);
    }
}
{{</inlineJava>}}


La programmation fonctionnelle est un paradigme de programmation qui met l'accent sur l'utilisation de fonctions pures, l'immutabilitÃ© des donnÃ©es et l'Ã©vitement des effets secondaires. Une fonction pure produit toujours le mÃªme rÃ©sultat pour les mÃªmes entrÃ©es et n'altÃ¨re pas l'Ã©tat externe, ce qui facilite la prÃ©diction et le dÃ©bogage du code. En Java, bien que le langage soit principalement orientÃ© objet, l'introduction de l'API Stream et des expressions lambda en Java 8 a permis d'intÃ©grer des concepts fonctionnels. Ces outils permettent de manipuler des collections de donnÃ©es de maniÃ¨re dÃ©clarative, en exprimant ce que l'on veut accomplir (par exemple, filtrer ou transformer des donnÃ©es) plutÃ´t que comment le faire Ã©tape par Ã©tape, comme dans une approche impÃ©rative. Cette approche amÃ©liore la lisibilitÃ© et la modularitÃ© du code, tout en favorisant des opÃ©rations comme le parallÃ©lisme sans effort explicite.

Le rÃ´le des lambdas et de l'API Stream dans Java illustre bien l'influence de la programmation fonctionnelle. Les lambdas permettent de dÃ©finir des fonctions anonymes concises, souvent utilisÃ©es pour implÃ©menter des interfaces fonctionnelles (comme Predicate ou Function) dans des opÃ©rations comme le filtrage, le mappage ou le tri. Par exemple, dans une opÃ©ration comme list.stream().filter(x -> x > 0).map(x -> x * 2).collect(Collectors.toList()), chaque Ã©tape est une transformation fonctionnelle qui ne modifie pas la liste initiale, respectant ainsi le principe d'immutabilitÃ©. L'API Stream prend en charge ces transformations en traitant les donnÃ©es comme un flux, oÃ¹ les opÃ©rations sont enchaÃ®nÃ©es et Ã©valuÃ©es de maniÃ¨re paresseuse (lazy evaluation), ne s'exÃ©cutant qu'Ã  la demande d'un rÃ©sultat final. Cela rÃ©duit les calculs inutiles et permet une optimisation automatique, comme le traitement parallÃ¨le avec parallelStream().

Cependant, l'intÃ©gration de la programmation fonctionnelle en Java reste partielle, car le langage conserve une forte orientation objet. Les dÃ©veloppeurs doivent Ãªtre conscients des compromis : les lambdas et les streams rendent le code plus expressif, mais une utilisation excessive ou inappropriÃ©e peut nuire Ã  la performance ou Ã  la lisibilitÃ©, notamment dans des cas complexes. De plus, Java impose des contraintes, comme l'absence de fonctions de premiÃ¨re classe (les lambdas sont des implÃ©mentations d'interfaces) et une gestion explicite de l'immutabilitÃ©. MalgrÃ© ces limitations, la programmation fonctionnelle en Java, via les streams et les lambdas, a transformÃ© la maniÃ¨re dont les dÃ©veloppeurs manipulent les donnÃ©es, encourageant des pratiques plus modernes et alignÃ©es sur les paradigmes fonctionnels tout en restant ancrÃ©es dans l'Ã©cosystÃ¨me Java.


## ComplexitÃ© algorithmique 

La complexitÃ© algorithmique mesure le coÃ»t (en temps ou en espace) des opÃ©rations selon la taille des donnÃ©es manipulÃ©es. Voici un survol de la complexitÃ© des principales opÃ©rations sur les structures de donnÃ©es abordÃ©es dans ce moduleÂ :

### Tableaux (array)
- **AccÃ¨s Ã  un Ã©lÃ©ment**Â : \(O(1)\) (accÃ¨s direct par indice)
- **Modification dâ€™un Ã©lÃ©ment**Â : \(O(1)\)
- **Recherche dâ€™une valeur**Â : \(O(n)\) dans le pire cas (il faut parcourir tout le tableau)
- **Insertion/Suppression**Â : \(O(n)\) (il faut dÃ©placer les Ã©lÃ©ments suivants)

### ArrayList
- **AccÃ¨s Ã  un Ã©lÃ©ment**Â : \(O(1)\)
- **Ajout Ã  la fin**Â : \(O(1)\) en moyenne (amortie), mais \(O(n)\) lors dâ€™un redimensionnement
- **Insertion/Suppression Ã  une position donnÃ©e**Â : \(O(n)\) (dÃ©placement des Ã©lÃ©ments)
- **Recherche dâ€™une valeur**Â : \(O(n)\)

### Stack (Pile)
- **Ajout (push) ou retrait (pop) dâ€™un Ã©lÃ©ment**Â : \(O(1)\)
- **AccÃ¨s au sommet**Â : \(O(1)\)

### HashMap
- **Insertion, suppression, recherche par clÃ©**Â : \(O(1)\) en moyenne, \(O(n)\) dans le pire cas (rare)

### PriorityQueue
- **Ajout dâ€™un Ã©lÃ©ment**Â : \(O(\log n)\) (le nouvel Ã©lÃ©ment est placÃ© Ã  la fin puis remontÃ©)
- **Extraction du plus prioritaire (poll)**Â : \(O(\log n)\) (le dernier Ã©lÃ©ment est placÃ© en tÃªte puis redescendu)
- **Consultation du plus prioritaire (peek)**Â : \(O(1)\)

### OpÃ©rations sur les streams et lambdas
- **Filtrage, transformation (map, filter, etc.)**Â : \(O(n)\), car chaque Ã©lÃ©ment est traitÃ© une fois
- **Tri dâ€™une liste**Â : \(O(n \log n)\) (par exemple, avec `Collections.sort()` ou `List.sort()`)

### Remarques pÃ©dagogiques
- Les opÃ©rations en \(O(1)\) sont dites Â«Â en temps constantÂ Â»Â : leur durÃ©e ne dÃ©pend pas de la taille des donnÃ©es.
- Les opÃ©rations en \(O(n)\) sont Â«Â linÃ©airesÂ Â»Â : leur durÃ©e croÃ®t proportionnellement Ã  la taille des donnÃ©es.
- Les opÃ©rations en \(O(n \log n)\) sont typiques des algorithmes de tri efficaces.
- Les structures comme HashMap sont trÃ¨s performantes pour la recherche par clÃ©, mais moins adaptÃ©es pour le parcours ordonnÃ©.

En rÃ©sumÃ©, le choix de la structure de donnÃ©es influence fortement la performance des algorithmes. Il est essentiel de comprendre la complexitÃ© des opÃ©rations pour Ã©crire du code efficace, surtout lorsque les ensembles de donnÃ©es deviennent volumineux.


### Lecture optionnelle dans le livre de rÃ©fÃ©rence (Delannoy)

<p>Pour aller plus en profondeur sur les structures de donnÃ©es(optionnel), vous pouvez lire dans <em>Programmer en Java</em> de Claude Delannoy les chapitres 7 et 22.</p>

## VidÃ©os

{{< youtube id="VdvUYGs17Ek" >}}

{{< youtube id="wvQQ5263pvI" >}}

{{< youtube id="EphmNLfZ2hM" >}}

{{< youtube id="ov3d4s5w_m0" >}}

{{< youtube id="eXYLsxQvIF4" >}}

