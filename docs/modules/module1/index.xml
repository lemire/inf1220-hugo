<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Module 1: Algorithme et pseudocode on INF 1220 - Introduction à la programmation</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/</link><description>Recent content in Module 1: Algorithme et pseudocode on INF 1220 - Introduction à la programmation</description><generator>Hugo</generator><language>fr</language><atom:link href="https://lemire.github.io/inf1220-hugo/docs/modules/module1/index.xml" rel="self" type="application/rss+xml"/><item><title>Modèle du cours</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/teluq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/teluq/</guid><description>&lt;h1 id="le-modèle-pédagogique-du-cours">
 Le modèle pédagogique du cours
 &lt;a class="anchor" href="#le-mod%c3%a8le-p%c3%a9dagogique-du-cours">#&lt;/a>
&lt;/h1>
&lt;p>Le cours INF 1220 est autoportant. Cela signifie que vous êtes capable, de manière
autonome, de réaliser toutes les activités du cours. Il est important de bien
comprendre ce modèle avant de débuter si vous n&amp;rsquo;êtes pas familier avec les cours
en ligne de ce type.&lt;/p>
&lt;h2 id="le-modèle-de-luniversité-téluq">
 Le modèle de l’Université TÉLUQ
 &lt;a class="anchor" href="#le-mod%c3%a8le-de-luniversit%c3%a9-t%c3%a9luq">#&lt;/a>
&lt;/h2>
&lt;p>Plusieurs étudiants inscrits au cours INF 1220 en sont en leur premier cours à l’Université TÉLUQ. À l’Université TÉLUQ, nous offrons un enseignement personnalisé : vous débutez et terminez le cours à une date qui vous convient, vous faites les travaux au sein du cours à votre rythme. Le cours est conçu pour être autoportant : un travail pédagogique substantiel a été fait afin que l’étudiant autonome puisse compléter le cours par lui-même, sans aide. Un professeur ou une personne tutrice est là pour répondre à vos questions lorsque vous êtes devant une impasse après avoir fait les lectures et vos recherches, à tous les moments de votre parcours. Ce modèle diffère de celui des Universités traditionnelles où il y a de rencontres de groupes hebdomadaires et où tous les étudiants cheminent en même temps. Les deux modèles ont des forces et des faiblesses. L’Université TÉLUQ offre plus de flexibilité, mais son modèle exige plus d’autonomie intellectuelle de la part des étudiants.&lt;/p></description></item><item><title>Robot conversationnel et intelligence artificielle</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/robot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/robot/</guid><description>&lt;h1 id="robot-conversationnel-et-intelligence-artificielle">
 Robot conversationnel et intelligence artificielle
 &lt;a class="anchor" href="#robot-conversationnel-et-intelligence-artificielle">#&lt;/a>
&lt;/h1>
&lt;p>L&amp;rsquo;intelligence artificielle (IA) transforme profondément le domaine de la programmation, redéfinissant la manière dont les développeurs conçoivent, écrivent et maintiennent le code. Les outils basés sur l&amp;rsquo;IA, comme les assistants de codage (par exemple, GitHub Copilot), permettent d&amp;rsquo;automatiser des tâches répétitives, telles que la génération de code boilerplate ou la complétion automatique de fonctions. Ces outils s&amp;rsquo;appuient sur des modèles de langage avancés, entraînés sur d&amp;rsquo;immenses bases de données de code, pour proposer des suggestions contextuelles précises. Cette assistance accélère le processus de développement, permettant aux programmeurs de se concentrer sur des aspects plus créatifs et complexes de leurs projets, tout en réduisant les erreurs humaines.&lt;/p></description></item><item><title>Autoévaluation</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/autoevaluation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/autoevaluation/</guid><description>&lt;h1 id="autoévaluation">
 Autoévaluation
 &lt;a class="anchor" href="#auto%c3%a9valuation">#&lt;/a>
&lt;/h1>
&lt;p>Avant de débuter le cours, il est important de faire le point sur votre préparation.
Je vous invite donc à faire une autoévaluation.&lt;/p>
&lt;h2 id="connaissances-technologiques">
 Connaissances technologiques
 &lt;a class="anchor" href="#connaissances-technologiques">#&lt;/a>
&lt;/h2>
&lt;p>Le cours ne nécessite pas une connaissance approfondie du fonctionnement des ordinateurs, mais il est utile d&amp;rsquo;avoir
une certaine connaissance de base. Vous devriez savoir que les ordinateurs disposent d&amp;rsquo;un processeur, de mémoire, de
disques, etc. et qu&amp;rsquo;ils fonctionnent à l&amp;rsquo;aide d&amp;rsquo;un système d&amp;rsquo;exploitation. Si vous ne vous êtes jamais intéressés à
ces concepts de base, il peut être utile que vous preniez un peu de votre temps pour faire des recherches sur ces
questions. Il peut être difficile de suivre ce cours si vous ne savez vraiment pas ce qu&amp;rsquo;est un processeur ou de la
mémoire informatique.&lt;/p></description></item><item><title>Java pas à pas</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/pasapas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/pasapas/</guid><description>&lt;h1 id="java-pas-à-pas">
 Java pas à pas
 &lt;a class="anchor" href="#java-pas-%c3%a0-pas">#&lt;/a>
&lt;/h1>
&lt;p>Nous vous invitons maintenant à lire le chapitre suivants &lt;em>Concepts de base&lt;/em> (chapitre 1) du manuel Java pas à pas par Robert Godin et Daniel Lemire. Le chapitre comprend plusieurs exemples et exercices. Vous devez compléter les exercices du manuel.&lt;/p>
&lt;p>Après votre lecture du chapitre, répondez aux questions suivantes.&lt;/p>
&lt;ul>
&lt;li>Décrivez les principales composantes matérielles d’un ordinateur typique, telles que le processeur, la mémoire centrale et les unités périphériques. Expliquez brièvement le rôle du bus dans la communication entre ces composantes.&lt;/li>
&lt;li>Expliquez le fonctionnement de base du processeur central (CPU) dans l’exécution d’un programme. Décrivez le cycle de traitement (chercher et exécuter une instruction) et donnez un exemple simple d’instruction que le processeur pourrait exécuter.&lt;/li>
&lt;li>Quelles sont les caractéristiques principales de la mémoire centrale (RAM) en termes de rapidité et de volatilité ? Expliquez pourquoi un programme doit être chargé dans la mémoire centrale avant son exécution et ce qui se passe en cas d’interruption de courant.&lt;/li>
&lt;li>Distinguez les périphériques d’entrée, de sortie et d’entrée/sortie. À l’aide d’exemples concrets (comme le clavier, l’écran ou le disque dur), expliquez comment ces périphériques permettent l’échange d’informations entre l’ordinateur et le monde extérieur.&lt;/li>
&lt;li>Quelle est la différence entre le matériel (hardware) et le logiciel (software) ? Décrivez le rôle du système d’exploitation dans la gestion des ressources d’un ordinateur, en citant un exemple de système d’exploitation mentionné dans le chapitre.&lt;/li>
&lt;li>Expliquez ce qu’est le langage binaire et pourquoi il est utilisé dans les ordinateurs. À l’aide d’un exemple, montrez comment l’entier décimal 42 est représenté en binaire sur 8 bits, en détaillant le calcul.&lt;/li>
&lt;li>Décrivez le processus de compilation dans le contexte de la programmation Java. Expliquez pourquoi il est nécessaire de traduire un programme Java en langage machine avant son exécution par le processeur.&lt;/li>
&lt;li>Expliquez ce qu’est un système de gestion de fichiers et son rôle dans l’organisation des données en mémoire secondaire. À l’aide d’un exemple de chemin de fichier sous Windows (comme C:\Users\Robert\Documents\HelloWorld.java), décrivez comment un fichier est localisé.&lt;/li>
&lt;li>Qu’est-ce que le pseudo-parallélisme dans un système monoprocesseur ? Expliquez comment le système d’exploitation crée l’illusion d’une exécution simultanée de plusieurs programmes, et précisez en quoi cela diffère du parallélisme réel dans un système multi-cœur.&lt;/li>
&lt;/ul>
&lt;p>Plusieurs étudiants trouvent qu&amp;rsquo;il est plus aisé de faire les lectures dans le manuel Java pas à pas après avoir terminé la lecture du module sur notre site web. Vous pouvez choisir quand il vous convient le mieux d&amp;rsquo;utiliser le manuel Java pas à pas.&lt;/p></description></item><item><title>Les ordinateurs et leurs langages</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/ordinateurs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/ordinateurs/</guid><description>&lt;h1 id="court-historique-des-langages-de-programmation">
 Court historique des langages de programmation
 &lt;a class="anchor" href="#court-historique-des-langages-de-programmation">#&lt;/a>
&lt;/h1>
&lt;p>L’idée de programmer des machines remonte au 19e siècle, époque marquée par l’émergence des premières machines de calcul et d’automatisation. Dès 1801, les métiers à tisser Jacquard utilisaient des cartes perforées pour programmer des motifs textiles, préfigurant les concepts de codage. Cependant, c’est au milieu du 19e siècle qu’un jalon historique est posé avec les travaux d’Ada Lovelace (1815-1852) sur la machine analytique de Charles Babbage. Considérée comme la première programmeuse, elle rédigea des notes détaillées incluant un algorithme pour calculer les nombres de Bernoulli, démontrant qu’une machine pouvait exécuter des instructions complexes. Le langage Ada, créé dans les années 1980, rend hommage à cette contribution pionnière.&lt;/p></description></item><item><title>Les algorithmes</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/algorithmes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/algorithmes/</guid><description>&lt;h1 id="les-algorithmes">
 Les algorithmes
 &lt;a class="anchor" href="#les-algorithmes">#&lt;/a>
&lt;/h1>
&lt;blockquote>
&lt;p>&lt;em>The etymology of program is pro ‘before’ + graphein ‘write’. I think of programming as making a plan that will be executed in the future, something that every human does from time to time. The hard part is that a computer has to execute the plan, and computers are incredibly stupid. Dealing with such stupidity requires more patience and determination than many people have.&lt;/em> (Peter Turney)&lt;/p></description></item><item><title>Les algorithmes : conception et syntaxe</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/algorithmes2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/algorithmes2/</guid><description>&lt;h1 id="les-algorithmes--conception-et-syntaxe">
 Les algorithmes : conception et syntaxe
 &lt;a class="anchor" href="#les-algorithmes--conception-et-syntaxe">#&lt;/a>
&lt;/h1>
&lt;p>Un algorithme est une méthode structurée pour résoudre un problème de manière systématique et efficace. Comparable à une recette culinaire, il fournit des instructions précises, exécutables pas à pas, pour transformer des données d’entrée en résultats attendus. Comprendre la conception et la syntaxe des algorithmes est essentiel pour tout programmeur souhaitant traduire une solution abstraite en code fonctionnel, quel que soit le langage utilisé.&lt;/p></description></item><item><title>Les algorithmes: les structures de contrôle</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/algorithmes3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/algorithmes3/</guid><description>&lt;h1 id="les-structures-de-contrôle">
 Les structures de contrôle
 &lt;a class="anchor" href="#les-structures-de-contr%c3%b4le">#&lt;/a>
&lt;/h1>
&lt;p>Nous avons déjà présenté les notions d&amp;rsquo;embranchement et de boucle. C&amp;rsquo;est ce que nous appelons des structures de contrôle. Il est essentiel
d&amp;rsquo;en comprendre la fonction.&lt;/p>
&lt;p>On peut concevoir un algorithme qui ne comprend qu&amp;rsquo;une liste d&amp;rsquo;opérations simples (addition, soustraction, etc.). Cependant sans structures de contrôle, nous auront du mal à gérer les données dynamiques, par exemple un tableau qui peut contenir un nombre variable d&amp;rsquo;éléments, et on risque de devoir répéter beaucoup d&amp;rsquo;opérations.
Les structures de contrôle permettent à l&amp;rsquo;algorithme de faire des choix de traitement en fonction de conditions. Une structure de contrôle correspond à l&amp;rsquo;action de tester des variables de contrôle et selon les résultats d&amp;rsquo;effectuer des opérations ou non.&lt;/p></description></item><item><title>Les problèmes difficiles</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/difficile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/difficile/</guid><description>&lt;h1 id="les-problèmes-difficiles">
 Les problèmes difficiles
 &lt;a class="anchor" href="#les-probl%c3%a8mes-difficiles">#&lt;/a>
&lt;/h1>
&lt;blockquote class="book-hint info">
&lt;p>Dans ce cours, vous n&amp;rsquo;avez pas à maîtriser la notion de problème difficile, mais vous devriez être familier avec le concept.&lt;/p>
&lt;/blockquote>
&lt;p>Dans un cours d’introduction à la programmation, la plupart des exercices se concentrent sur des problèmes dont les algorithmes sont relativement simples à concevoir, surtout si vous maîtrisez les bases de la programmation et des mathématiques. Ces problèmes, comme calculer une moyenne ou trier une liste, demandent souvent une compréhension des structures de contrôle (conditions et boucles) et une application directe de concepts logiques. Cependant, dans des contextes plus avancés, certains problèmes se révèlent bien plus complexes, non pas à cause de la programmation elle-même, mais en raison de la difficulté à trouver un algorithme efficace. Ces défis, qualifiés de « problèmes difficiles », nécessitent des approches créatives et parfois des compromis, car leurs solutions idéales peuvent être hors de portée avec les ressources informatiques actuelles.&lt;/p></description></item><item><title>Complexité algorithmique</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/complex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/complex/</guid><description>&lt;h1 id="complexité-algorithmique">
 Complexité algorithmique
 &lt;a class="anchor" href="#complexit%c3%a9-algorithmique">#&lt;/a>
&lt;/h1>
&lt;p>La plupart des problèmes ne sont pas fondamentalement difficiles, mais toutes les solutions
ne sont pas également efficaces. La complexité algorithmique fournit une mesure de cette efficacité.&lt;/p>
&lt;p>La complexité algorithmique mesure le temps ou la mémoire qu’un algorithme nécessite en fonction de la taille de l’entrée (souvent notée \( n \)). Pour comparer les algorithmes, on utilise la notation grand-O (ou O-grande), qui donne un ordre de grandeur du nombre d’opérations à effectuer lorsque la taille des données augmente.&lt;/p></description></item><item><title>Les erreurs communes</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/erreurs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/erreurs/</guid><description>&lt;h1 id="erreurs-communes">
 Erreurs communes
 &lt;a class="anchor" href="#erreurs-communes">#&lt;/a>
&lt;/h1>
&lt;p>Rédiger du pseudo-code n&amp;rsquo;a rien de sorcier, mais plusieurs étudiants font des erreurs. Voici quelques erreurs communes.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Certains étudiants rédigent du pseudo-code qui a l&amp;rsquo;air formel et correct, mais qui est en fait ambigu et inutilisable. Prenons cet exemple: &lt;code> SI j'ai mal aux dos ALORS je prend des aspirines OU SI j'ai faim ALORS je mange&lt;/code>. Bien sûr, je n&amp;rsquo;ai utilisé que des expressions logiques. Des SI, des ALORS des OU. Mais qu&amp;rsquo;est-ce que ça signifie ? Par exemple, est-ce que je peux à la fois manger et prendre des aspirines dans ce scénario ? La réponse est subjective. Votre pseudo-code doit être exécutable sans interprétation. Un pseudo-code n&amp;rsquo;est pas un texte à interprétation subjective. Vous ne pouvez pas faire semblant d&amp;rsquo;écrire du pseudo-code en utilisant simplement les termes qu&amp;rsquo;on trouve fréquemment au sein des pseudo-codes. Ce n&amp;rsquo;est pas une question de syntaxe. On peut parfaitement écrire du pseudo-code sans jamais utiliser SI, TANT QUE, etc. Plusieurs étudiants obsèdent sur la syntaxe, croyant à tort que si on leur donne les bons termes, la bonne grammaire, ils trouveront comment comprendre ce qu&amp;rsquo;est un pseudo-code. Or, c&amp;rsquo;est justement le contraire de la leçon ici: nous voulons que vous compreniez que la syntaxe exacte est secondaire dans la pensée algorithmique. On peut être imprécis et incohérent en utilisant une syntaxe formelle, et on peut être précis et cohérent en utilisant du français usuel. Ce n&amp;rsquo;est pas parce que vous utilisez des expressions qui vous semblent précises que vous l&amp;rsquo;êtes. Vous devez avoir une idée précise en tête et vous devez l&amp;rsquo;exprimer avec précision.&lt;/p></description></item><item><title>Exercices sur les algorithmes</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/exercices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/exercices/</guid><description>&lt;h1 id="exercices-sur-les-algorithmes-et-problèmes">
 Exercices sur les algorithmes et problèmes
 &lt;a class="anchor" href="#exercices-sur-les-algorithmes-et-probl%c3%a8mes">#&lt;/a>
&lt;/h1>
&lt;p>La notion d&amp;rsquo;algorithme a été abordée implicitement dès les premiers cours de mathématiques, par exemple avec l&amp;rsquo;algorithme de la division longue. Ces exercices visent à vous faire décrire formellement un algorithme. La principale difficulté pour la plupart des étudiants réside dans la rigueur et la précision requises. Au-delà d’un certain point, il n’existe pas de lectures supplémentaires : la pratique est essentielle.&lt;/p></description></item><item><title>Travail noté 1</title><link>https://lemire.github.io/inf1220-hugo/docs/modules/module1/travail-note-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf1220-hugo/docs/modules/module1/travail-note-1/</guid><description>&lt;h1 id="travail-noté-1---les-algorithmes">
 Travail noté 1 - Les algorithmes
 &lt;a class="anchor" href="#travail-not%c3%a9-1---les-algorithmes">#&lt;/a>
&lt;/h1>
&lt;p>Ce cours d’introduction à la programmation exige une gestion rigoureuse du temps et une préparation approfondie. Les étudiants doivent soumettre leurs travaux notés avant la date de fin de cours, indiquée dans le portail étudiant, sans possibilité de report sauf en cas de circonstances exceptionnelles validées par l’Université. La charge de travail est estimée à neuf heures par semaine sur quinze semaines, et les travaux, d’un niveau comparable à ceux d’autres universités, nécessitent plusieurs heures par activité. Les consignes soulignent l’importance de lire attentivement les énoncés, de tester rigoureusement ses solutions et de consacrer plus de temps à la vérification qu’à la production initiale. L’utilisation du robot conversationnel du cours est autorisée, mais les réponses doivent être personnelles.&lt;/p></description></item></channel></rss>