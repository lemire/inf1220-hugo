<!doctype html><html lang=fr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Les structures de contrôle
  #

Nous avons déjà présenté les notions d&rsquo;embranchement et de boucle. C&rsquo;est ce que nous appelons des structures de contrôle. Il est essentiel
d&rsquo;en comprendre la fonction.
On peut concevoir un algorithme qui ne comprend qu&rsquo;une liste d&rsquo;opérations simples (addition, soustraction, etc.). Cependant sans structures de contrôle, nous auront du mal à gérer les données dynamiques, par exemple un tableau qui peut contenir un nombre variable d&rsquo;éléments, et on risque de devoir répéter beaucoup d&rsquo;opérations.
Les structures de contrôle permettent à l&rsquo;algorithme de faire des choix de traitement en fonction de conditions. Une structure de contrôle correspond à l&rsquo;action de tester des variables de contrôle et selon les résultats d&rsquo;effectuer des opérations ou non."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lemire.github.io/inf1220-hugo/docs/modules/module1/algorithmes3/"><meta property="og:site_name" content="INF 1220 - Introduction à la programmation"><meta property="og:title" content="Les algorithmes: les structures de contrôle"><meta property="og:description" content="Les structures de contrôle # Nous avons déjà présenté les notions d’embranchement et de boucle. C’est ce que nous appelons des structures de contrôle. Il est essentiel d’en comprendre la fonction.
On peut concevoir un algorithme qui ne comprend qu’une liste d’opérations simples (addition, soustraction, etc.). Cependant sans structures de contrôle, nous auront du mal à gérer les données dynamiques, par exemple un tableau qui peut contenir un nombre variable d’éléments, et on risque de devoir répéter beaucoup d’opérations. Les structures de contrôle permettent à l’algorithme de faire des choix de traitement en fonction de conditions. Une structure de contrôle correspond à l’action de tester des variables de contrôle et selon les résultats d’effectuer des opérations ou non."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Les algorithmes: les structures de contrôle | INF 1220 - Introduction à la programmation</title><link rel=icon href=/inf1220-hugo/favicon.png><link rel=manifest href=/inf1220-hugo/manifest.json><link rel=canonical href=https://lemire.github.io/inf1220-hugo/docs/modules/module1/algorithmes3/><link rel=stylesheet href=/inf1220-hugo/book.min.a006656c8516e75b9916bf87553cdae09b7d022a0ef8c51fcafcb935e4e3d410.css integrity="sha256-oAZlbIUW51uZFr+HVTza4Jt9AioO+MUfyvy5NeTj1BA=" crossorigin=anonymous><script defer src=/inf1220-hugo/fuse.min.js></script><script defer src=/inf1220-hugo/fr.search.min.01b60e77d474ebd7626e014f6aff7e8b705f8a7bfc09c7d51b5a8c9113846ff2.js integrity="sha256-AbYOd9R069dibgFPav9+i3Bfinv8CcfVG1qMkROEb/I=" crossorigin=anonymous></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/inf1220-hugo/><img src=/inf1220-hugo/livre.jpg alt=Logo class=book-icon><span>INF 1220 - Introduction à la programmation</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/inf1220-hugo/docs/environnement/>Programmation Java en ligne</a></li><li><a href=/inf1220-hugo/docs/format/>Formattage du code Java</a></li><li><a href=/inf1220-hugo/docs/erreurs/>Vous avez trouvé une erreur?</a></li><li><a href=/inf1220-hugo/docs/modules/>Modules</a><ul><li><input type=checkbox id=section-6ffbdc93c5edebe8ae6289c754c6323e class=toggle checked>
<label for=section-6ffbdc93c5edebe8ae6289c754c6323e class=flex><a href=/inf1220-hugo/docs/modules/module1/ class=flex-auto>Module 1: Algorithme et pseudocode</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module1/teluq/>Modèle du cours</a></li><li><a href=/inf1220-hugo/docs/modules/module1/robot/>Robot conversationnel et intelligence artificielle</a></li><li><a href=/inf1220-hugo/docs/modules/module1/autoevaluation/>Autoévaluation</a></li><li><a href=/inf1220-hugo/docs/modules/module1/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module1/ordinateurs/>Les ordinateurs et leurs langages</a></li><li><a href=/inf1220-hugo/docs/modules/module1/algorithmes/>Les algorithmes</a></li><li><a href=/inf1220-hugo/docs/modules/module1/algorithmes2/>Les algorithmes : conception et syntaxe</a></li><li><a href=/inf1220-hugo/docs/modules/module1/algorithmes3/ class=active>Les algorithmes: les structures de contrôle</a></li><li><a href=/inf1220-hugo/docs/modules/module1/difficile/>Les problèmes difficiles</a></li><li><a href=/inf1220-hugo/docs/modules/module1/complex/>Complexité algorithmique</a></li><li><a href=/inf1220-hugo/docs/modules/module1/erreurs/>Les erreurs communes</a></li><li><a href=/inf1220-hugo/docs/modules/module1/syntaxe/>Présentation du pseudocode</a></li><li><a href=/inf1220-hugo/docs/modules/module1/exercices/>Exercices sur les algorithmes</a></li><li><a href=/inf1220-hugo/docs/modules/module1/travail-note-1/>Travail noté 1</a></li></ul></li><li><input type=checkbox id=section-71b9dfc90da9a83f173743029715be7a class=toggle>
<label for=section-71b9dfc90da9a83f173743029715be7a class=flex><a href=/inf1220-hugo/docs/modules/module2/ class=flex-auto>Module 2: Introduction au langage Java</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module2/preparation/>Préparation de l’espace de travail</a></li><li><a href=/inf1220-hugo/docs/modules/module2/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module2/oriente/>Création d'une classe en Java</a></li><li><a href=/inf1220-hugo/docs/modules/module2/typeoperateur/>Introduction aux types de base et à leurs opérateurs</a></li><li><a href=/inf1220-hugo/docs/modules/module2/exercices-2-1/>Exercices sur les classes, les variables, les types et les opérateurs</a></li><li><a href=/inf1220-hugo/docs/modules/module2/methodes/>Méthodes et constructeurs</a></li><li><a href=/inf1220-hugo/docs/modules/module2/exercices-2-2/>Exercices sur les classes et méthodes</a></li><li><a href=/inf1220-hugo/docs/modules/module2/conseils/>Recommandations</a></li><li><a href=/inf1220-hugo/docs/modules/module2/markdown/>MarkDown</a></li><li><a href=/inf1220-hugo/docs/modules/module2/gabarit/>Gabarit pour les travaux notés 2, 3, 4 et 5</a></li><li><a href=/inf1220-hugo/docs/modules/module2/travail-note-2/>Travail noté 2</a></li></ul></li><li><input type=checkbox id=section-67896e9afc9b4080d8c27b998062dd91 class=toggle>
<label for=section-67896e9afc9b4080d8c27b998062dd91 class=flex><a href=/inf1220-hugo/docs/modules/module3/ class=flex-auto>Module 3: Les structures de données, de contrôle et d'itération en Java</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module3/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module3/github/>GitHub</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-1/>Les structures de contrôle</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-2/>Les structures itératives</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-3-string/>Les chaînes de caractères (String)</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-3/>Les structures de données de base</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-3-random/>Les valeurs aléatoires</a></li><li><a href=/inf1220-hugo/docs/modules/module3/fonctionnel/>La programmation fonctionnelle en Java</a></li><li><a href=/inf1220-hugo/docs/modules/module3/exercices-3-1/>Exercices sur les structures de contrôle, les structures de données, les structures itératives</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-4/>Les exceptions</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-5/>La récursivité</a></li><li><a href=/inf1220-hugo/docs/modules/module3/exercices-3-2/>Exercices sur les exceptions et la récursivité</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-3-modele/>Exemple : modèle de langue</a></li><li><a href=/inf1220-hugo/docs/modules/module3/conseils/>Recommandations</a></li><li><a href=/inf1220-hugo/docs/modules/module3/travail-note-3/>Travail noté 3</a></li></ul></li><li><input type=checkbox id=section-9087a4ffddbd9e1f0f2f4b3f8c85dcb4 class=toggle>
<label for=section-9087a4ffddbd9e1f0f2f4b3f8c85dcb4 class=flex><a href=/inf1220-hugo/docs/modules/module4/ class=flex-auto>Module 4: Les entrées et sorties</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module4/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module4/activite-4-1/>Les flux de console</a></li><li><a href=/inf1220-hugo/docs/modules/module4/activite-4-2/>Les flux de données: lecture dans des fichiers et autres</a></li><li><a href=/inf1220-hugo/docs/modules/module4/exercices-4-1/>Exercices sur les flux</a></li><li><a href=/inf1220-hugo/docs/modules/module4/web/>Développement web</a></li><li><a href=/inf1220-hugo/docs/modules/module4/travail-note-4/>Travail noté 4</a></li></ul></li><li><input type=checkbox id=section-749269b787e65f29f734b50b6282d284 class=toggle>
<label for=section-749269b787e65f29f734b50b6282d284 class=flex><a href=/inf1220-hugo/docs/modules/module5/ class=flex-auto>Module 5. La programmation orientée objet: héritage et le polymorphisme</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module5/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module5/activite-5-1/>L'héritage, les classes abstraites et les interfaces</a></li><li><a href=/inf1220-hugo/docs/modules/module5/activite-5-2/>Le polymorphisme</a></li><li><a href=/inf1220-hugo/docs/modules/module5/exercices-5-1/>Exercices sur l’héritage et le polymorphisme</a></li><li><a href=/inf1220-hugo/docs/modules/module5/travail-note-5/>Travail noté 5</a></li></ul></li><li><a href=/inf1220-hugo/docs/modules/examen/>Examen</a></li></ul></li><li><a href=/inf1220-hugo/docs/evaluation/>Évaluation</a></li><li><a href=/inf1220-hugo/docs/pensebete/>Pense-bête java</a></li><li><input type=checkbox id=section-5cc50cb3031bd6bd7b763bb20cfb7f0e class=toggle>
<label for=section-5cc50cb3031bd6bd7b763bb20cfb7f0e class=flex><a role=button class=flex-auto>Autres ressources</a></label><ul><li><a href=/inf1220-hugo/docs/extra/credits/>Le professeur</a></li><li><a href=/inf1220-hugo/docs/extra/feuille-de-route/>Feuille de route</a></li><li><a href=/inf1220-hugo/docs/extra/ressources/>Ressources</a></li><li><a href=/inf1220-hugo/docs/extra/faq/>FAQ</a></li><li><a href=/inf1220-hugo/docs/extra/manuel/>Manuel</a></li><li><a href=/inf1220-hugo/docs/extra/math/>Rappel mathématique</a></li><li><a href=/inf1220-hugo/docs/extra/ia/>Intelligence artificielle</a></li><li><a href=/inf1220-hugo/docs/extra/courriel/>Petit guide d’usage du courriel efficace</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/inf1220-hugo/svg/menu.svg class=book-icon alt=Menu></label><h3>Les algorithmes: les structures de contrôle</h3><label for=toc-control><img src=/inf1220-hugo/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#le-saut>Le saut</a></li><li><a href=#lembranchement-comme-structure-de-contrôle>L&rsquo;embranchement comme structure de contrôle</a></li><li><a href=#la-boucle-comme-structure-de-contrôle>La boucle comme structure de contrôle</a></li><li><a href=#composition>Composition</a></li><li><a href=#la-fin-dun-algorithme>La fin d&rsquo;un algorithme</a></li><li><a href=#exécution-dun-pseudo-code>Exécution d&rsquo;un pseudo-code</a></li><li><a href=#vidéo-suggérée>Vidéo suggérée</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=les-structures-de-contrôle>Les structures de contrôle
<a class=anchor href=#les-structures-de-contr%c3%b4le>#</a></h1><p>Nous avons déjà présenté les notions d&rsquo;embranchement et de boucle. C&rsquo;est ce que nous appelons des structures de contrôle. Il est essentiel
d&rsquo;en comprendre la fonction.</p><p>On peut concevoir un algorithme qui ne comprend qu&rsquo;une liste d&rsquo;opérations simples (addition, soustraction, etc.). Cependant sans structures de contrôle, nous auront du mal à gérer les données dynamiques, par exemple un tableau qui peut contenir un nombre variable d&rsquo;éléments, et on risque de devoir répéter beaucoup d&rsquo;opérations.
Les structures de contrôle permettent à l&rsquo;algorithme de faire des choix de traitement en fonction de conditions. Une structure de contrôle correspond à l&rsquo;action de tester des variables de contrôle et selon les résultats d&rsquo;effectuer des opérations ou non.</p><h2 id=le-saut>Le saut
<a class=anchor href=#le-saut>#</a></h2><p>Le saut est une structure de contrôle fondamentale en informatique qui permet de modifier le flux d&rsquo;exécution d’un algorithme en redirigeant l’exécution vers une autre partie du programme. Contrairement aux structures comme les embranchements (qui choisissent entre plusieurs chemins selon une condition) ou les boucles (qui répètent un bloc d’instructions), le saut est une instruction explicite qui transfère immédiatement le contrôle à une position spécifique dans le code, souvent marquée par une étiquette ou une adresse.
Un saut peut être inconditionnel, où l’exécution est toujours redirigée vers une nouvelle position, ou conditionnel, où le saut dépend d’une condition booléenne.</p><p>Un saut inconditionnel redirige l’exécution vers une étiquette ou une ligne spécifique sans vérifier de condition. En pseudo-code, cela peut être représenté ainsi :</p><pre tabindex=0><code>ÉTIQUETTE debut
écrire &#34;Bonjour&#34;
SAUTER À debut
</code></pre><p>Dans cet exemple, l’algorithme affiche &ldquo;Bonjour&rdquo; et saute immédiatement à l’étiquette debut, créant une boucle infinie. Bien que rarement utilisé seul en pseudo-code, ce type de saut est courant dans les langages de bas niveau pour organiser le flux du programme</p><h2 id=lembranchement-comme-structure-de-contrôle>L&rsquo;embranchement comme structure de contrôle
<a class=anchor href=#lembranchement-comme-structure-de-contr%c3%b4le>#</a></h2><p>Un saut conditionnel (ou embranchement) dépend d’une condition booléenne. Si la condition est vraie, l’exécution saute à une étiquette donnée ; sinon, elle continue séquentiellement. Voici un exemple en pseudo-code :</p><pre tabindex=0><code>lire nombre
SI nombre &lt; 0 ALORS
    SAUTER À negatif
FIN SI
écrire &#34;Le nombre est positif ou nul&#34;
SAUTER À fin
ÉTIQUETTE negatif
écrire &#34;Le nombre est négatif&#34;
ÉTIQUETTE fin
</code></pre><p>En pratique, ces structures correspondent à poser des questions avec la syntaxe suivante : SI conditions ALORS opérations FIN SI. Il peut y avoir plusieurs conditions dans une structure de contrôle et la logique booléenne est utilisée pour les construire. Par exemple, SI a est égal 0 ET b est égal 1 ALORS faire c FIN SI.</p><p>Dans la notion de pseudo-code, il est également possible de faire une suite de structures de contrôle avec la syntaxe suivante : SI conditionA ALORS opérations SINON SI conditionB ALORS opérations SINON SI conditionC ALORS [et ainsi de suite] FIN SI.</p><p>Voici un exemple en pseudo-code illustrant une suite de structures de contrôle avec plusieurs conditions pour classer un score obtenu à un examen :</p><pre tabindex=0><code>lire score
SI score ≥ 90 ALORS
    écrire &#34;Note : A&#34;
SINON SI score ≥ 80 ALORS
    écrire &#34;Note : B&#34;
SINON SI score ≥ 70 ALORS
    écrire &#34;Note : C&#34;
SINON SI score ≥ 60 ALORS
    écrire &#34;Note : D&#34;
SINON
    écrire &#34;Note : F&#34;
FIN SI
</code></pre><p>Dans cet exemple, l’algorithme lit une variable score (un nombre entier représentant un score d’examen). Il utilise une série de conditions pour déterminer la note correspondante :</p><ul><li>Si score est supérieur ou égal à 90, la note est &ldquo;A&rdquo;.</li><li>Sinon, si score est supérieur ou égal à 80, la note est &ldquo;B&rdquo;.</li><li>Sinon, si score est supérieur ou égal à 70, la note est &ldquo;C&rdquo;.</li><li>Sinon, si score est supérieur ou égal à 60, la note est &ldquo;D&rdquo;.</li><li>Sinon (pour tout score inférieur à 60), la note est &ldquo;F&rdquo;.</li></ul><p>Chaque condition est évaluée séquentiellement, et dès qu’une condition est vraie, l’algorithme exécute l’opération associée (afficher la note) et sort de la structure avec FIN SI. Si aucune condition n’est vraie, l’opération par défaut (afficher &ldquo;Note : F&rdquo;) est exécutée.</p><p>Considérons l&rsquo;exemple suivant. Il s&rsquo;agit d&rsquo;un outil interactif qui t’aide à comprendre comment un algorithme utilise des conditions pour classer une personne selon son âge. Pour commencer, saisis un âge entier positif dans le champ prévu, par exemple « 25 ». Ensuite, clique sur « Prochaine étape » pour exécuter l’algorithme étape par étape. À chaque clic, une ligne du pseudocode s’illumine, et un message explicatif apparaît dans la zone de journalisation en bas. Tu verras également l’état mis à jour : l’âge saisi et la catégorie déterminée (comme « Vous êtes un adulte »). Si tu veux recommencer, clique sur « Réinitialiser » pour effacer les résultats. Attention, l’âge doit être un nombre entier positif, sinon un message te demandera de corriger.</p><p>Cet outil vous permet de suivre le raisonnement de l’algorithme de manière claire. Le pseudocode, affiché à gauche, utilise une structure conditionnelle (SI, SINON SI, SINON) pour évaluer l’âge et assigner une catégorie : enfant (≤ 10 ans), adolescent (> 10 et &lt; 18 ans), adulte (≥ 18 et &lt; 65 ans) ou personne âgée (≥ 65 ans). En progressant dans les étapes, observe comment l’algorithme teste chaque condition et choisit la bonne catégorie. Lisez attentivement les messages du journal pour comprendre les décisions prises.</p><div><div class=age-app style="background:#fff;padding:24px;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,.1);max-width:800px;width:100%"><h1 style=font-size:24px;margin-bottom:16px;color:#1f2937>Catégorie d'âge</h1><p style=font-size:16px;margin-bottom:16px;color:#4b5563>Entrez un âge et exécutez le pseudocode pour déterminer la catégorie d'âge.</p><div style=margin-bottom:16px><input type=number class=ageAgeInput value=25 min=0 style="padding:8px;font-size:16px;border:1px solid #e5e7eb;border-radius:4px;width:calc(100% - 18px)"></div><div style=display:flex;gap:16px><div style="flex:1;background-color:#f9fafb;padding:16px;border:1px solid #e5e7eb;border-radius:8px"><p style=font-size:16px;color:#374151;margin-bottom:8px>Pseudocode</p><pre class=agePseudocode style=font-size:14px;color:#374151;text-align:left;background:#fff;padding:8px;border-radius:4px></pre></div><div style=flex:1><p style=font-size:16px;color:#374151;margin-bottom:8px>État</p><div style="background-color:#f9fafb;padding:16px;border:1px solid #e5e7eb;border-radius:8px;margin-bottom:16px"><p style=font-size:14px;color:#374151>Âge : <span class=ageAge>0</span></p><p style=font-size:14px;color:#374151>Sortie : <span class=ageOutput>-</span></p></div><div class=ageLog style="font-size:14px;color:#374151;max-height:150px;overflow-y:auto;background-color:#f9fafb;padding:16px;border:1px solid #e5e7eb;border-radius:8px"></div></div></div><div style=margin-top:16px><button class=ageStepButton style="background:#3498db;color:#fff;border:none;padding:10px 20px;border-radius:5px;cursor:pointer;font-size:16px">Prochaine étape</button>
<button class=ageResetButton style="background:#3498db;color:#fff;border:none;padding:10px 20px;border-radius:5px;cursor:pointer;font-size:16px">Réinitialiser</button></div></div><script>(function(){for(var t=document.currentScript.previousElementSibling;t&&!t.classList.contains("age-app");)t=t.previousElementSibling;if(!t)return;let n=0,o="-",e=0,i=!1;const r=["SI age <= 10 ALORS",`    Imprimer à l'écran "Vous êtes un enfant"`,"SINON SI age > 10 ET age < 18 ALORS",`    Imprimer à l'écran "Vous êtes un adolescent"`,"SINON SI age >= 18 ET age < 65 ALORS",`    Imprimer à l'écran "Vous êtes un adulte"`,"SINON",`    Imprimer à l'écran "Vous êtes une personne âgée"`,"FIN SI"];function a(){t.querySelector(".ageAge").textContent=n,t.querySelector(".ageOutput").textContent=o;const s=t.querySelector(".agePseudocode");s.innerHTML=r.map((t,n)=>`<span style="display: block; ${n===e?"background: #e6f4ea; color: #15803d;":""}">${t}</span>`).join(""),t.querySelector(".ageStepButton").style.cssText=i||e>=r.length?"background: #95a5a6; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: not-allowed; font-size: 16px;":"background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px;"}function s(e){const s=t.querySelector(".ageLog"),n=document.createElement("div");n.textContent=e,n.style.cssText="opacity: 0; transition: opacity 0.5s ease;",s.appendChild(n),setTimeout(()=>{n.style.opacity="1"},10),s.scrollTop=s.scrollHeight}function d(e){const t=Number(e);return!isNaN(t)&&Number.isInteger(t)&&t>=0}function c(){const e=t.querySelector(".ageAgeInput").value;return d(e)?(n=Number(e),l(),!0):(alert("Veuillez entrer un âge entier positif."),t.querySelector(".ageAgeInput").value=n||25,!1)}async function u(){if(i||e>=r.length)return;i=!0,t.querySelector(".ageStepButton").style.cssText="background: #95a5a6; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: not-allowed; font-size: 16px;",e===0?(n=Number(t.querySelector(".ageAgeInput").value),s(`Vérification : age = ${n} <= 10`),n<=10?e=1:e=2):e===1?(o="Vous êtes un enfant",s('Affichage : "Vous êtes un enfant"'),e=8):e===2?(s(`Vérification : age = ${n} > 10 et age < 18`),n>10&&n<18?e=3:e=4):e===3?(o="Vous êtes un adolescent",s('Affichage : "Vous êtes un adolescent"'),e=8):e===4?(s(`Vérification : age = ${n} >= 18 et age < 65`),n>=18&&n<65?e=5:e=6):e===5?(o="Vous êtes un adulte",s('Affichage : "Vous êtes un adulte"'),e=8):e===6?(s(`Condition : SINON (aucune condition précédente n’est vraie)`),e=7):e===7?(o="Vous êtes une personne âgée",s('Affichage : "Vous êtes une personne âgée"'),e=8):e===8&&(s(`Fin de l’exécution : résultat = "${o}"`),e++),a(),await new Promise(e=>setTimeout(e,500)),i=!1,a()}function l(){n=Number(t.querySelector(".ageAgeInput").value)||25,o="-",e=0,t.querySelector(".ageLog").innerHTML="",a()}t.querySelector(".ageAgeInput").addEventListener("change",c),t.querySelector(".ageStepButton").addEventListener("click",u),t.querySelector(".ageResetButton").addEventListener("click",function(){c()&&l()}),a()})()</script></div><p>Après avoir utilisé l’outil, prenez un moment pour réfléchir à la flexibilité de cet algorithme. Comment pourriez-vous le modifier pour ajouter de nouvelles catégories, comme « bébé » pour les âges de 0 à 2 ans, ou pour inclure des critères supplémentaires, comme une distinction entre « jeune adulte » et « adulte senior » ? Que se passerait-il si l’âge pouvait être négatif ou non entier ? Comment adapteriez-vous le pseudocode pour gérer ces cas ?</p><h2 id=la-boucle-comme-structure-de-contrôle>La boucle comme structure de contrôle
<a class=anchor href=#la-boucle-comme-structure-de-contr%c3%b4le>#</a></h2><p>Il arrive régulièrement dans la résolution d&rsquo;un problème qu&rsquo;il est nécessaire de réaliser à plusieurs reprises une ou des opérations sur un ensemble de données. Par exemple, supposons qu&rsquo;il est nécessaire de trouver le plus petit nombre dans un tableau d&rsquo;entiers. Il sera forcément nécessaire d&rsquo;itérer dans le tableau, une ligne à la fois, et de comparer les nombres entre eux. Pour ce faire, nous utiliserons deux éléments de syntaxe, soit le TANT QUE _ FAIRE ou bien le POUR TOUT _ FAIRE. Voici deux exemples de l&rsquo;utilisation de ces deux approches :</p><details><summary>Pseudocode 1 : Boucle POUR TOUT</summary><div class=highlight><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Entrées :
</span></span><span style=display:flex><span>Tableau d&#39;entiers : tableau[100]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Sorties :
</span></span><span style=display:flex><span>Entier minimum
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>minimum = tableau[0]
</span></span><span style=display:flex><span>POUR TOUT Entier e de tableau FAIRE
</span></span><span style=display:flex><span>    SI e &lt; minimum ALORS
</span></span><span style=display:flex><span>        minimum = e;
</span></span><span style=display:flex><span>    FIN SI
</span></span><span style=display:flex><span>FIN POUR TOUT
</span></span></code></pre></div><p>Ce pseudocode décrit un algorithme pour trouver la valeur minimale dans un tableau d’entiers de taille 100. L’algorithme commence par initialiser la variable minimum à la première valeur du tableau (tableau[0]), en supposant que le tableau n’est pas vide. Ensuite, une boucle (POUR TOUT Entier e de tableau FAIRE) parcourt chaque élément e du tableau. À chaque itération, si l’élément e est inférieur à la valeur actuelle de minimum, alors minimum est mis à jour avec la valeur de e (minimum = e). À la fin de la boucle, minimum contient la plus petite valeur du tableau, qui est retournée comme résultat.</p></details><details><summary>Pseudocode 2 : Boucle TANT QUE</summary><div class=highlight><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>Entrées :
</span></span><span style=display:flex><span>Tableau d&#39;entiers : tableau[100]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Sorties :
</span></span><span style=display:flex><span>Entier minimum
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>minimum = tableau[0]
</span></span><span style=display:flex><span>Entier iterateur = 0;
</span></span><span style=display:flex><span>TANT QUE iterateur &lt; 100 FAIRE
</span></span><span style=display:flex><span>    SI tableau[iterateur] &lt; minimum ALORS
</span></span><span style=display:flex><span>        minimum = tableau[iterateur];
</span></span><span style=display:flex><span>    FIN SI
</span></span><span style=display:flex><span>    iterateur = iterateur + 1;
</span></span><span style=display:flex><span>FIN TANT QUE
</span></span></code></pre></div><p>Ce pseudocode décrit un algorithme pour trouver la valeur minimale dans un tableau d’entiers de taille 100. Une variable minimum est initialisée avec la première valeur du tableau (tableau[0]), supposant que le tableau n’est pas vide. Une variable iterateur est initialisée à 0 pour suivre la position dans le tableau. La boucle (TANT QUE iterateur &lt; 100 FAIRE) parcourt le tableau tant que iterateur est inférieur à 100. À chaque itération, si l’élément à l’indice iterateur (tableau[iterateur]) est inférieur à minimum, alors minimum est mis à jour avec cette valeur. Ensuite, iterateur est incrémenté de 1 (iterateur = iterateur + 1) pour passer à l’élément suivant. À la fin de la boucle, minimum contient la plus petite valeur du tableau, qui est retournée.</p></details><p>Au niveau fondamental, une boucle peut être vue comme un saut conditionnel dans le flux d&rsquo;exécution d’un algorithme. Un saut conditionnel est une instruction qui, en fonction d’une condition, redirige l’exécution vers une autre partie du programme. Dans le cas d’une boucle, ce saut ramène l’exécution au début du bloc d’instructions tant que la condition associée à la boucle reste vraie.</p><p>Prenons l’exemple de la boucle TANT QUE. La condition iterateur &lt; 100 est évaluée à chaque itération. Si elle est vraie, l’algorithme exécute le corps de la boucle (comparaison et mise à jour de minimum, incrémentation de iterateur), puis retourne au début de la boucle pour réévaluer la condition. Ce retour au début est un saut conditionnel : l’algorithme &ldquo;saute&rdquo; en arrière dans le code pour répéter le processus. Lorsque la condition devient fausse (quand iterateur atteint 100), le saut n’a plus lieu, et l’exécution continue après la boucle.</p><p>De même, dans la boucle POUR TOUT du Pseudocode 1, bien que la syntaxe soit plus abstraite, le mécanisme sous-jacent est similaire. La boucle parcourt chaque élément du tableau, ce qui peut être traduit en une série de sauts conditionnels gérés implicitement : après avoir traité un élément, l’algorithme &ldquo;saute&rdquo; à l’élément suivant tant qu’il reste des éléments à traiter.</p><h2 id=composition>Composition
<a class=anchor href=#composition>#</a></h2><p>Dans la pratique, un algorithme peut comporter plusieurs structures de contrôle itératives, plusieurs structures de contrôle alternatives et plusieurs opérations. On peut les combiner de diverses manières. Il est possible, par exemple, d&rsquo;avoir une boucle TANT QUE au sein d&rsquo;une autre boucle TANT QUE.</p><div class=highlight><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>TANT QUE x &gt; 0 FAIRE
</span></span><span style=display:flex><span>  TANT QUE x &gt; 10 FAIRE
</span></span><span style=display:flex><span>     x = x - 1
</span></span><span style=display:flex><span>  FIN TANT QUE
</span></span><span style=display:flex><span>FIN TANT QUE
</span></span></code></pre></div><p>Ce pseudocode décrit une structure de boucles imbriquées qui modifie la valeur de la variable x jusqu&rsquo;à ce qu&rsquo;elle devienne inférieure ou égale à 0. La boucle externe (TANT QUE x > 0 FAIRE) continue tant que x est strictement positif. À l&rsquo;intérieur, la boucle interne (TANT QUE x > 10 FAIRE) s&rsquo;exécute uniquement si x est supérieur à 10, et dans ce cas, elle décrémente x de 1 à chaque itération (x = x - 1). Une fois que x devient inférieur ou égal à 10, la boucle interne s&rsquo;arrête, mais la boucle externe ne se termine pas immédiatement, car elle vérifie seulement si x > 0. Cependant, comme il n&rsquo;y a aucune instruction dans la boucle externe pour modifier x lorsque x ≤ 10, le programme entre dans une boucle infinie si x est compris entre 1 et 10 inclus. Si x est initialement supérieur à 10, il sera décrémenté jusqu&rsquo;à atteindre 10, puis le programme se bloquera. Si x est initialement inférieur ou égal à 0, aucune des boucles ne s&rsquo;exécute.</p><h2 id=la-fin-dun-algorithme>La fin d&rsquo;un algorithme
<a class=anchor href=#la-fin-dun-algorithme>#</a></h2><p>Un algorithme continue à s&rsquo;exécuter tant qu&rsquo;il reste des operations à faire. L&rsquo;algorithme prend fin lorsque nous rencontrons la fin du pseudo-code ou lorsque le programmeur invoque la fin spécifiquement. Dans l&rsquo;exemple suivant, le programmeur demande à ce que l&rsquo;on cesse l&rsquo;exécution dès que la valeur 5 est rencontrée.</p><div class=highlight><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>x = 0
</span></span><span style=display:flex><span>TANT QUE x &lt; 10 ALORS
</span></span><span style=display:flex><span>   ajoute un à x
</span></span><span style=display:flex><span>   SI x == 5 ALORS TERMINE
</span></span><span style=display:flex><span>FIN TANT QUE
</span></span><span style=display:flex><span>AFFICHE x
</span></span></code></pre></div><p>La valeur x ne sera donc jamais affichée.</p><p>Il arrive aussi qu&rsquo;un pseudo-code doit retourner une valeur. Par convention, dès que la valeur attendue est retournée, l&rsquo;algorithme prend fin. Ainsi donc, dans le cas suivant, la valeur 5 sera retournée.</p><div class=highlight><pre tabindex=0 style=background-color:#f7f7f7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>x = 0
</span></span><span style=display:flex><span>TANT QUE x &lt; 10 ALORS
</span></span><span style=display:flex><span>   ajoute un à x
</span></span><span style=display:flex><span>   SI x == 5 ALORS RETOURNE x
</span></span><span style=display:flex><span>FIN TANT QUE
</span></span><span style=display:flex><span>RETOURNE x
</span></span></code></pre></div><h2 id=exécution-dun-pseudo-code>Exécution d&rsquo;un pseudo-code
<a class=anchor href=#ex%c3%a9cution-dun-pseudo-code>#</a></h2><p>Pour comprendre un pseudo-code que vous venez de recevoir, ou pour tester un pseudo-code que vous venez de créer, il est essentiel de l&rsquo;exécuter. Quand on exécute un pseudo-code, on se contente de lire les consignes logiques.</p><p>Prenons un exemple:</p><pre tabindex=0><code>Variable test = 0

TANT QUE test &lt; 100
  test = test + 22
FIN TANT QUE

retourne test
</code></pre><script src=/inf1220-hugo/mermaid.min.js></script><script>mermaid.initialize({flowchart:{useMaxWidth:!0},theme:"default"})</script><pre class=mermaid>

graph TD
    A[Début] --> B[Initialiser test = 0]
    B --> C{test < 100 ?}
    C -- Vrai --> D[test = test + 22]
    D --> C
    C -- Faux --> E[Retourner test]
    E --> F[Fin]
</pre><ol><li>Je débute le pseudo-code avec la valeur 0 stockée dans la variable test.</li><li>J&rsquo;entre dans la boucle TANT QUE.</li><li>J&rsquo;ajoute 22 à la variable test, le résultat est 22.</li><li>J&rsquo;entre dans la boucle TANT QUE.</li><li>J&rsquo;ajoute 22 à la variable test, le résultat est 44.</li><li>J&rsquo;entre dans la boucle TANT QUE.</li><li>J&rsquo;ajoute 22 à la variable test, le résultat est 66.</li><li>J&rsquo;entre dans la boucle TANT QUE.</li><li>J&rsquo;ajoute 22 à la variable test, le résultat est 88.</li><li>J&rsquo;entre dans la boucle TANT QUE.</li><li>J&rsquo;ajoute 22 à la variable test, le résultat est 110.</li><li>Je quitte la boucle TANT QUE.</li><li>Je retourne la valeur stockée dans la variable test, soit 110.</li></ol><p>Vous devez absolument être capable de faire de telles exécutions. Dans certains cas, votre pseudo-code va dépendre de paramètres: il faut alors exécuter le pseudo-code plus d&rsquo;une fois, sur plusieurs cas de test. Dans certains cas, le pseudo-code peut prendre trop d&rsquo;étapes pour qu&rsquo;un humain puisse l&rsquo;exécuter entièrement : vous devriez au moins en faire une partie.</p><h2 id=vidéo-suggérée>Vidéo suggérée
<a class=anchor href=#vid%c3%a9o-sugg%c3%a9r%c3%a9e>#</a></h2><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/kk6YbA5I-Iw?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"><a href=/inf1220-hugo/docs/modules/module1/algorithmes2/ class="flex align-center float-left book-icon"><img src=/inf1220-hugo/svg/backward.svg alt=Previous title="Les algorithmes : conception et syntaxe">
<span>Les algorithmes : conception et syntaxe</span>
</a><a href=/inf1220-hugo/docs/modules/module1/difficile/ class="flex align-center float-right book-icon"><span>Les problèmes difficiles</span>
<img src=/inf1220-hugo/svg/forward.svg alt=Next title="Les problèmes difficiles"></a></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#le-saut>Le saut</a></li><li><a href=#lembranchement-comme-structure-de-contrôle>L&rsquo;embranchement comme structure de contrôle</a></li><li><a href=#la-boucle-comme-structure-de-contrôle>La boucle comme structure de contrôle</a></li><li><a href=#composition>Composition</a></li><li><a href=#la-fin-dun-algorithme>La fin d&rsquo;un algorithme</a></li><li><a href=#exécution-dun-pseudo-code>Exécution d&rsquo;un pseudo-code</a></li><li><a href=#vidéo-suggérée>Vidéo suggérée</a></li></ul></nav></div></aside></main></body></html>