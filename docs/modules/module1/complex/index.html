<!doctype html><html lang=fr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Complexité algorithmique
  #

La plupart des problèmes ne sont pas fondamentalement difficiles, mais toutes les solutions
ne sont pas également efficaces. La complexité algorithmique fournit une mesure de cette efficacité.
La complexité algorithmique mesure le temps ou la mémoire qu’un algorithme nécessite en fonction de la taille de l’entrée (souvent notée \( n \)). Pour comparer les algorithmes, on utilise la notation grand-O (ou O-grande), qui donne un ordre de grandeur du nombre d’opérations à effectuer lorsque la taille des données augmente."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lemire.github.io/inf1220-hugo/docs/modules/module1/complex/"><meta property="og:site_name" content="INF 1220 - Introduction à la programmation"><meta property="og:title" content="Complexité algorithmique"><meta property="og:description" content="Complexité algorithmique # La plupart des problèmes ne sont pas fondamentalement difficiles, mais toutes les solutions ne sont pas également efficaces. La complexité algorithmique fournit une mesure de cette efficacité.
La complexité algorithmique mesure le temps ou la mémoire qu’un algorithme nécessite en fonction de la taille de l’entrée (souvent notée \( n \)). Pour comparer les algorithmes, on utilise la notation grand-O (ou O-grande), qui donne un ordre de grandeur du nombre d’opérations à effectuer lorsque la taille des données augmente."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Complexité algorithmique | INF 1220 - Introduction à la programmation</title><link rel=icon href=/inf1220-hugo/favicon.png><link rel=manifest href=/inf1220-hugo/manifest.json><link rel=canonical href=https://lemire.github.io/inf1220-hugo/docs/modules/module1/complex/><link rel=stylesheet href=/inf1220-hugo/book.min.f5b6812da8cb28cdd091634583a6182b2e7f70231c885158fda89c58af6e3024.css integrity="sha256-9baBLajLKM3QkWNFg6YYKy5/cCMciFFY/aicWK9uMCQ=" crossorigin=anonymous><script defer src=/inf1220-hugo/fuse.min.js></script><script defer src=/inf1220-hugo/fr.search.min.5028de1ce97217e7b9fa75ff650bf14348fcb5171b1bcc5c027c6d9045714a7c.js integrity="sha256-UCjeHOlyF+e5+nX/ZQvxQ0j8tRcbG8xcAnxtkEVxSnw=" crossorigin=anonymous></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/inf1220-hugo/><img src=/inf1220-hugo/livre.jpg alt=Logo class=book-icon><span>INF 1220 - Introduction à la programmation</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/inf1220-hugo/docs/environnement/>Programmation Java en ligne</a></li><li><a href=/inf1220-hugo/docs/erreurs/>Vous avez trouvé une erreur?</a></li><li><input type=checkbox id=section-5cc50cb3031bd6bd7b763bb20cfb7f0e class=toggle>
<label for=section-5cc50cb3031bd6bd7b763bb20cfb7f0e class=flex><a role=button class=flex-auto>Autres ressources</a></label><ul><li><a href=/inf1220-hugo/docs/extra/credits/>Le professeur</a></li><li><a href=/inf1220-hugo/docs/extra/feuille-de-route/>Feuille de route</a></li><li><a href=/inf1220-hugo/docs/extra/ressources/>Ressources</a></li><li><a href=/inf1220-hugo/docs/extra/faq/>FAQ</a></li><li><a href=/inf1220-hugo/docs/extra/manuel/>Manuel</a></li><li><a href=/inf1220-hugo/docs/extra/math/>Rappel mathématique</a></li><li><a href=/inf1220-hugo/docs/extra/ia/>Intelligence artificielle</a></li><li><a href=/inf1220-hugo/docs/extra/courriel/>Petit guide d’usage du courriel efficace</a></li></ul></li><li><a href=/inf1220-hugo/docs/evaluation/>Évaluation</a></li><li><a href=/inf1220-hugo/docs/modules/>Modules</a><ul><li><input type=checkbox id=section-6ffbdc93c5edebe8ae6289c754c6323e class=toggle checked>
<label for=section-6ffbdc93c5edebe8ae6289c754c6323e class=flex><a href=/inf1220-hugo/docs/modules/module1/ class=flex-auto>Module 1: Algorithme et pseudocode</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module1/teluq/>Modèle du cours</a></li><li><a href=/inf1220-hugo/docs/modules/module1/robot/>Robot conversationnel et intelligence artificielle</a></li><li><a href=/inf1220-hugo/docs/modules/module1/autoevaluation/>Autoévaluation</a></li><li><a href=/inf1220-hugo/docs/modules/module1/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module1/ordinateurs/>Les ordinateurs et leurs langages</a></li><li><a href=/inf1220-hugo/docs/modules/module1/algorithmes/>Les algorithmes</a></li><li><a href=/inf1220-hugo/docs/modules/module1/algorithmes2/>Les algorithmes : conception et syntaxe</a></li><li><a href=/inf1220-hugo/docs/modules/module1/algorithmes3/>Les algorithmes: les structures de contrôle</a></li><li><a href=/inf1220-hugo/docs/modules/module1/difficile/>Les problèmes difficiles</a></li><li><a href=/inf1220-hugo/docs/modules/module1/complex/ class=active>Complexité algorithmique</a></li><li><a href=/inf1220-hugo/docs/modules/module1/erreurs/>Les erreurs communes</a></li><li><a href=/inf1220-hugo/docs/modules/module1/exercices/>Exercices sur les algorithmes</a></li><li><a href=/inf1220-hugo/docs/modules/module1/travail-note-1/>Travail noté 1</a></li></ul></li><li><input type=checkbox id=section-71b9dfc90da9a83f173743029715be7a class=toggle>
<label for=section-71b9dfc90da9a83f173743029715be7a class=flex><a href=/inf1220-hugo/docs/modules/module2/ class=flex-auto>Module 2: Introduction au langage Java</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module2/preparation/>Préparation de l’espace de travail</a></li><li><a href=/inf1220-hugo/docs/modules/module2/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module2/oriente/>Langage de programmation orientée objet</a></li><li><a href=/inf1220-hugo/docs/modules/module2/typeoperateur/>Introduction aux types de base et à leurs opérateurs</a></li><li><a href=/inf1220-hugo/docs/modules/module2/exercices-2-1/>Exercices sur les classes, les variables, les types et les opérateurs</a></li><li><a href=/inf1220-hugo/docs/modules/module2/methodes/>Méthodes et constructeurs</a></li><li><a href=/inf1220-hugo/docs/modules/module2/exercices-2-2/>Exercices sur les classes et méthodes</a></li><li><a href=/inf1220-hugo/docs/modules/module2/conseils/>Recommandations</a></li><li><a href=/inf1220-hugo/docs/modules/module2/travail-note-2/>Travail noté 2</a></li></ul></li><li><input type=checkbox id=section-67896e9afc9b4080d8c27b998062dd91 class=toggle>
<label for=section-67896e9afc9b4080d8c27b998062dd91 class=flex><a href=/inf1220-hugo/docs/modules/module3/ class=flex-auto>Module 3: Les structures de données, de contrôle et d'itération en Java</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module3/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module3/github/>GitHub</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-1/>Les structures de contrôle</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-2/>Les structures itératives</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-3/>Les structures de données de base</a></li><li><a href=/inf1220-hugo/docs/modules/module3/exercices-3-1/>Exercices sur les structures de contrôle, les structures de données, les structures itératives</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-4/>Les exceptions</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-5/>La récursivité</a></li><li><a href=/inf1220-hugo/docs/modules/module3/exercices-3-2/>Exercices sur les exceptions et la récursivité</a></li><li><a href=/inf1220-hugo/docs/modules/module3/conseils/>Recommandations</a></li><li><a href=/inf1220-hugo/docs/modules/module3/travail-note-3/>Travail noté 3</a></li></ul></li><li><input type=checkbox id=section-9087a4ffddbd9e1f0f2f4b3f8c85dcb4 class=toggle>
<label for=section-9087a4ffddbd9e1f0f2f4b3f8c85dcb4 class=flex><a href=/inf1220-hugo/docs/modules/module4/ class=flex-auto>Module 4: Les entrées et sorties</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module4/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module4/activite-4-1/>Les flux de console</a></li><li><a href=/inf1220-hugo/docs/modules/module4/activite-4-2/>Les flux de données: lecture dans des fichiers et autres</a></li><li><a href=/inf1220-hugo/docs/modules/module4/exercices-4-1/>Exercices sur les flux</a></li><li><a href=/inf1220-hugo/docs/modules/module4/travail-note-4/>Travail noté 4</a></li></ul></li><li><input type=checkbox id=section-749269b787e65f29f734b50b6282d284 class=toggle>
<label for=section-749269b787e65f29f734b50b6282d284 class=flex><a href=/inf1220-hugo/docs/modules/module5/ class=flex-auto>Module 5. La programmation orientée objet: héritage et le polymorphisme</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module5/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module5/activite-5-1/>L'héritage, les classes abstraites et les interfaces</a></li><li><a href=/inf1220-hugo/docs/modules/module5/activite-5-2/>Le polymorphisme</a></li><li><a href=/inf1220-hugo/docs/modules/module5/exercices-5-1/>Exercices sur l’héritage et le polymorphisme</a></li><li><a href=/inf1220-hugo/docs/modules/module5/travail-note-5/>Travail noté 5</a></li></ul></li><li><a href=/inf1220-hugo/docs/modules/examen/>Examen</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/inf1220-hugo/svg/menu.svg class=book-icon alt=Menu></label><h3>Complexité algorithmique</h3><label for=toc-control><img src=/inf1220-hugo/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#notation-grand-o>Notation grand-O</a></li><li><a href=#exemples-dalgorithmes-en>Exemples d’algorithmes en</a></li><li><a href=#exemples-dalgorithmes-en-1>Exemples d’algorithmes en</a></li><li><a href=#recherche-dans-un-tableau-trié>Recherche dans un tableau trié</a></li><li><a href=#tri>Tri</a></li><li><a href=#table-de-hachage>Table de hachage</a></li><li><a href=#un-problème-résoluble-en--ou-en>Un problème résoluble en ou en</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=complexité-algorithmique>Complexité algorithmique
<a class=anchor href=#complexit%c3%a9-algorithmique>#</a></h1><p>La plupart des problèmes ne sont pas fondamentalement difficiles, mais toutes les solutions
ne sont pas également efficaces. La complexité algorithmique fournit une mesure de cette efficacité.</p><p>La complexité algorithmique mesure le temps ou la mémoire qu’un algorithme nécessite en fonction de la taille de l’entrée (souvent notée \( n \)). Pour comparer les algorithmes, on utilise la notation grand-O (ou O-grande), qui donne un ordre de grandeur du nombre d’opérations à effectuer lorsque la taille des données augmente.</p><p>Comprendre la complexité algorithmique permet de choisir ou d’inventer des solutions efficaces, surtout pour de grandes quantités de données. Il est souvent utile de commencer par une solution simple (même lente), puis de chercher à l’optimiser en utilisant des structures de données ou des propriétés mathématiques adaptées.</p><h3 id=notation-grand-o>Notation grand-O
<a class=anchor href=#notation-grand-o>#</a></h3><p>La notation \( O(f(n)) \) signifie que, pour des entrées de taille \( n \), l’algorithme effectue au plus un nombre d’opérations proportionnel à \( f(n) \) (à une constante près). On ne s’intéresse qu’au comportement pour de grandes valeurs de \( n \), et on ignore les détails d’implémentation ou les constantes cachées.</p><p>On considère souvent que l&rsquo;accès à un élément d&rsquo;un tableau par son index a une complexité \( O(1) \) puisqu&rsquo;il s&rsquo;agit d&rsquo;une seul opération. Les operations arithmétique (+, -, etc.) ont
aussi une complexité \( O(1) \).</p><h3 id=exemples-dalgorithmes-en>Exemples d’algorithmes en \( O(n) \)
<a class=anchor href=#exemples-dalgorithmes-en>#</a></h3><p>Un algorithme est en \( O(n) \) si le nombre d’opérations croît linéairement avec la taille de l’entrée. Par exemple, parcourir un tableau pour calculer la somme de ses éléments :</p><pre tabindex=0><code class=language-pseudo data-lang=pseudo>somme = 0
POUR i de 0 à n-1
    somme = somme + tableau[i]
FIN POUR
</code></pre><p>Ici, chaque élément est visité une seule fois, donc le temps d’exécution est proportionnel à \( n \).</p><h3 id=exemples-dalgorithmes-en-1>Exemples d’algorithmes en \( O(n^2) \)
<a class=anchor href=#exemples-dalgorithmes-en-1>#</a></h3><p>Un algorithme est en \( O(n^2) \) si le nombre d’opérations croît comme le carré de la taille de l’entrée. C’est typique des algorithmes qui utilisent deux boucles imbriquées, comme la recherche de toutes les paires d’éléments dans un tableau :</p><pre tabindex=0><code class=language-pseudo data-lang=pseudo>POUR i de 0 à n-1
    POUR j de 0 à n-1
        faire quelque chose avec tableau[i] et tableau[j]
    FIN POUR
FIN POUR
</code></pre><p>Ici, pour chaque valeur de \( i \), on parcourt toutes les valeurs de \( j \), ce qui donne \( n \times n = n^2 \) opérations.</p><p>Un algorithme \( O(n^2) \) est plus <em>lent</em> qu&rsquo;un algorithme \( O(n) \) quand \( n \) est très grand.</p><h3 id=recherche-dans-un-tableau-trié>Recherche dans un tableau trié
<a class=anchor href=#recherche-dans-un-tableau-tri%c3%a9>#</a></h3><p>Lorsqu’un tableau est trié, on peut utiliser la recherche dichotomique (ou recherche binaire) pour trouver rapidement un élément. Cette méthode consiste à comparer la valeur recherchée à l’élément du milieu du tableau : si la valeur est plus petite, on recommence la recherche dans la moitié gauche ; sinon, dans la moitié droite. On répète jusqu’à trouver l’élément ou à épuiser le tableau.</p><p>Voici un exemple de pseudocode pour la recherche binaire :</p><pre tabindex=0><code class=language-pseudo data-lang=pseudo>DEBUT
    debut ← 0
    fin ← n - 1
    TANT QUE debut ≤ fin
        milieu ← (debut + fin) // 2
        SI tableau[milieu] == valeur
            retourner VRAI
        SINON SI tableau[milieu] &lt; valeur
            debut ← milieu + 1
        SINON
            fin ← milieu - 1
        FIN SI
    FIN TANT QUE
    retourner FAUX
FIN
</code></pre><p>Pour mieux comprendre l&rsquo;algorithme, essayez de chercher des nombreds dans un tableau trié avec
l&rsquo;application suivante.</p><div><div id=arrayContainer style="display:flex;flex-wrap:wrap;justify-content:center;margin:10px 0;gap:5px"></div><div style="margin:20px 0;text-align:center"><input type=number id=searchInput placeholder="Entrez un nombre à rechercher" style="padding:10px;font-size:16px;border:1px solid #ccc;border-radius:4px;width:200px">
<button onclick=performBinarySearch() style="padding:10px 20px;font-size:16px;background-color:#28a745;color:#fff;border:none;border-radius:4px;cursor:pointer;margin-left:10px">Rechercher</button></div><div id=stepsContainer style="margin-top:20px;padding:15px;background-color:#fff;border:1px solid #ddd;border-radius:4px;min-height:100px"><p style=color:#333>Entrez un nombre et cliquez sur "Rechercher" pour voir les étapes de la recherche binaire.</p></div><div id=resultContainer style="margin-top:20px;padding:15px;background-color:#fff;border:1px solid #ddd;border-radius:4px;text-align:center;font-weight:700;color:#333"></div><script>const sortedArray=[1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63],arrayContainer=document.getElementById("arrayContainer");function renderArray(e=-1,t=-1,n=-1){arrayContainer.innerHTML="",sortedArray.forEach((s,o)=>{const i=document.createElement("span");i.innerText=s,i.style.padding="5px 10px",i.style.border="1px solid #ccc",i.style.borderRadius="4px",i.style.backgroundColor=o===n?"#ffc107":o>=e&&o<=t&&e!==-1&&t!==-1?"#d4edda":"#fff",i.style.transition="background-color 0.5s",arrayContainer.appendChild(i)})}renderArray();async function performBinarySearch(){const t=parseInt(document.getElementById("searchInput").value),c=document.getElementById("stepsContainer"),n=document.getElementById("resultContainer");if(c.innerHTML="",n.innerHTML="",renderArray(),t!=t){n.innerHTML="Veuillez entrer un nombre valide.";return}let s=0,o=sortedArray.length-1,e=[],a=!1,r=-1,i=-1;for(;s<=o;){const n=Math.floor((s+o)/2),c=sortedArray[n];if(e.push(`Comparaison avec l'élément au milieu (index ${n}) : ${c}`),renderArray(s,o,n),addStepToContainer(e[e.length-1]),await new Promise(e=>setTimeout(e,1e3)),c===t){a=!0,r=n,e.push(`Valeur ${t} trouvée à l'index ${n}.`),addStepToContainer(e[e.length-1]);break}c<t?(e.push(`La valeur ${t} est plus grande, recherche dans la moitié droite.`),addStepToContainer(e[e.length-1]),i=n,s=n+1):(e.push(`La valeur ${t} est plus petite, recherche dans la moitié gauche.`),addStepToContainer(e[e.length-1]),o=n-1),await new Promise(e=>setTimeout(e,500))}await new Promise(e=>setTimeout(e,500)),a?(n.innerHTML=`Valeur ${t} trouvée à l'index ${r}.`,n.style.color="#28a745"):(i!==-1?n.innerHTML=`Valeur ${t} non trouvée. La plus grande valeur inférieure est ${sortedArray[i]} à l'index ${i}.`:n.innerHTML=`Valeur ${t} non trouvée. Aucune valeur inférieure dans le tableau.`,n.style.color="#dc3545")}function addStepToContainer(e){const t=document.createElement("p");t.innerText=e,t.style.margin="5px 0",t.style.color="#555",document.getElementById("stepsContainer").appendChild(t)}</script></div><p>Observez comment vous faites toujours moins de recherche qu&rsquo;il y a d&rsquo;éléments dans le tableau. Pouvez-vous faire en sorte qu&rsquo;une seule étape soit nécessaire ? Quel est le nombre maximal d&rsquo;étapes nécessaires ?</p><p>Cet algorithme a une complexité en \( O(\log n) \), ce qui le rend très efficace pour les grands tableaux triés.</p><p>Cela signifie que le nombre d’opérations nécessaires pour trouver (ou ne pas trouver) un élément ne croît pas proportionnellement à la taille du tableau, mais beaucoup plus lentement. Par exemple, pour un tableau de 1 000 000 d’éléments, la recherche binaire nécessite au maximum environ 20 comparaisons (car \( \log_2 1\,000\,000 \approx 20 \)), alors qu’une recherche linéaire pourrait en demander jusqu’à 1 000 000 dans le pire cas. Plus le tableau est grand, plus l’avantage de la recherche binaire est important.</p><p>À chaque étape de la recherche binaire, on divise le nombre d’éléments restants par deux. Si on commence avec \( n \) éléments, après une comparaison il en reste \( n/2 \), puis \( n/4 \), puis \( n/8 \), etc. On répète ce processus jusqu’à ce qu’il ne reste qu’un seul élément à examiner.</p><p>On cherche donc le nombre d’étapes \( k \) tel que :</p>\[
\frac{n}{2^k} = 1
\]<p>En résolvant pour \( k \) :</p>\[
n = 2^k \implies k = \log_2 n
\]<p>Ainsi, le nombre maximal de comparaisons est proportionnel à \( \log_2 n \). C’est pourquoi on dit que la recherche binaire a une complexité en \( O(\log n) \).</p><h3 id=tri>Tri
<a class=anchor href=#tri>#</a></h3><p>Le tri consiste à réorganiser les éléments d’un tableau ou d’une liste selon un ordre donné (par exemple, croissant). Un algorithme de tri naïf, comme le tri à bulles (bubble sort) ou le tri par insertion, compare chaque élément à tous les autres et échange leur position si nécessaire. Ces algorithmes effectuent environ \( n^2 \) comparaisons pour un tableau de taille \( n \), ce qui leur donne une complexité en \( O(n^2) \). Cela devient très lent dès que le nombre d’éléments augmente.</p><p>Pseudocode du tri à bulle:</p><pre tabindex=0><code>POUR i de 0 à n-2
    POUR j de 0 à n-2-i
        SI tableau[j] &gt; tableau[j+1] ALORS
            échanger tableau[j] et tableau[j+1]
        FIN SI
    FIN POUR
FIN POUR
</code></pre><p>Heureusement, il existe des algorithmes de tri plus efficaces. Par exemple, le tri fusion (merge sort) utilise une approche « diviser pour régner » : il divise le tableau en deux moitiés, trie chaque moitié récursivement, puis fusionne les deux moitiés triées en un seul tableau trié. Cette méthode réduit considérablement le nombre de comparaisons nécessaires et atteint une complexité en \( O(n \log n) \).</p><p><strong>Idée générale du merge sort :</strong></p><ol><li>Si le tableau contient 0 ou 1 élément, il est déjà trié.</li><li>Sinon, on divise le tableau en deux parties de taille à peu près égale.</li><li>On trie récursivement chaque partie.</li><li>On fusionne les deux parties triées pour obtenir un tableau final trié.</li></ol><p>Pseudocode du tri fusion:</p><pre tabindex=0><code>FONCTION triFusion(tableau)
    SI taille(tableau) ≤ 1 ALORS
        retourner tableau
    FIN SI
    milieu ← taille(tableau) // 2
    gauche ← triFusion(tableau[0 .. milieu-1])
    droite ← triFusion(tableau[milieu .. fin])
    retourner fusionner(gauche, droite)
FIN FONCTION

FONCTION fusionner(gauche, droite)
    résultat ← tableau vide
    TANT QUE gauche et droite ne sont pas vides
        SI gauche[0] ≤ droite[0] ALORS
            ajouter gauche[0] à résultat
            retirer gauche[0] de gauche
        SINON
            ajouter droite[0] à résultat
            retirer droite[0] de droite
        FIN SI
    FIN TANT QUE
    ajouter le reste de gauche (s’il en reste) à résultat
    ajouter le reste de droite (s’il en reste) à résultat
    retourner résultat
FIN FONCTION
</code></pre><p>Le tri fusion est donc beaucoup plus rapide que les tris naïfs pour les grands tableaux, et il illustre l’intérêt des algorithmes efficaces en informatique.</p><h3 id=table-de-hachage>Table de hachage
<a class=anchor href=#table-de-hachage>#</a></h3><p>Une table de hachage (ou « hash table ») est une structure de données qui permet d’associer des clés à des valeurs et d’accéder très rapidement à une valeur à partir de sa clé. Le principe repose sur l’utilisation d’une fonction de hachage qui transforme la clé (par exemple, un texte ou un nombre) en un indice de tableau. Les opérations d’insertion, de recherche et de suppression se font en temps moyen \( O(1) \), c’est-à-dire en temps constant, quelle que soit la taille de la table (si la fonction de hachage est bonne et la table bien dimensionnée). La table de hachage est efficace pour retrouver rapidement une information à partir d’une clé.</p><p><strong>Idée générale :</strong></p><ol><li>On applique une fonction de hachage à la clé pour obtenir un indice.</li><li>On stocke la valeur à cet indice dans un tableau.</li><li>En cas de « collision » (deux clés différentes qui donnent le même indice), on utilise une technique de résolution (chaînage, sondage linéaire, etc.).</li></ol><p>Pseudocode d&rsquo;une recherche dans une table de hachage (sans collision):</p><pre tabindex=0><code class=language-pseudo data-lang=pseudo>FONCTION rechercher(table, clé)
    indice ← hachage(clé)
    SI table[indice] == clé ALORS
        retourner VRAI
    SINON
        retourner FAUX
    FIN SI
FIN FONCTION
</code></pre><p>Pour mieux comprendre, testez l&rsquo;application suivante. Saisissez des chaînes de caractères qui seront ajoutées à la table de hachage. Pouvez-vous créer une collision ?</p><div><div class=hash-app-container><div style=margin-bottom:20px><input type=text id=hashApp_stringInput placeholder="Entrez une chaîne" style=padding:8px;width:200px>
<button id=hashApp_addButton style="padding:8px 16px;cursor:pointer">Ajouter</button></div><h2>Chaînes saisies</h2><table id=hashApp_stringTable style=width:100%;border-collapse:collapse;margin-bottom:20px><thead><tr><th style="border:1px solid #ddd;padding:8px;text-align:left;background-color:#f2f2f2">Chaîne</th><th style="border:1px solid #ddd;padding:8px;text-align:left;background-color:#f2f2f2">Valeur de hachage</th><th style="border:1px solid #ddd;padding:8px;text-align:left;background-color:#f2f2f2">Position dans la table</th></tr></thead><tbody id=hashApp_stringTableBody></tbody></table><h2>Table de hachage</h2><div id=hashApp_hashTableDisplay style=display:grid;gap:10px></div></div><script>(function(){const e="hashApp_",n=10,t={hashTable:Array(n).fill().map(()=>[]),strings:[]};function o(t){try{let e=0;for(let n of t)e+=n.charCodeAt(0);const s=e%n;return{hashValue:e,index:s}}catch(t){return console.error(`${e}Erreur dans hashFunction:`,t),null}}function i(){try{const i=document.getElementById(`${e}stringInput`),n=i.value.trim();if(!n)return;const r=o(n);if(!r)return;const{hashValue:l,index:c}=r;t.strings.push({str:n,hashValue:l,index:c}),t.hashTable[c].push(n),a(),s(),i.value=""}catch(t){console.error(`${e}Erreur dans addString:`,t)}}function a(){try{const n=document.getElementById(`${e}stringTableBody`);n.innerHTML="",t.strings.forEach(({str:e,hashValue:t,index:s})=>{const o=document.createElement("tr");o.innerHTML=`
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: left;">${e}</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: left;">${t}</td>
                    <td style="border: 1px solid #ddd; padding: 8px; text-align: left;">${s}</td>
                `,n.appendChild(o)})}catch(t){console.error(`${e}Erreur dans updateStringTable:`,t)}}function s(){try{const s=document.getElementById(`${e}hashTableDisplay`);s.innerHTML="";for(let e=0;e<n;e++){const o=document.createElement("div");o.style.cssText="padding: 10px; border: 1px solid #ccc; background-color: #f9f9f9;",o.innerHTML=`<h3 style="margin: 0; font-size: 16px;">Index ${e}</h3><p>${t.hashTable[e].length>0?t.hashTable[e].join(", "):"Vide"}</p>`,s.appendChild(o)}}catch(t){console.error(`${e}Erreur dans updateHashTableDisplay:`,t)}}function r(){try{const t=document.getElementById(`${e}addButton`);t&&t.addEventListener("click",i),s()}catch(t){console.error(`${e}Erreur dans init:`,t)}}r()})()</script><style>.hash-app-container{contain:content;padding:20px;max-width:800px;margin:0 auto}</style></div><p>En Java, la classe <code>HashMap</code> que nous verrons plus loin dans le cours implémente une table de hachage. Par exemple :</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#cf222e>import</span><span style=color:#fff> </span><span style=color:#24292e>java.util.HashMap</span><span style=color:#1f2328>;</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span>HashMap<span style=color:#0550ae>&lt;</span>String<span style=color:#1f2328>,</span><span style=color:#fff> </span>Integer<span style=color:#0550ae>&gt;</span><span style=color:#fff> </span>dico<span style=color:#fff> </span><span style=color:#0550ae>=</span><span style=color:#fff> </span><span style=color:#cf222e>new</span><span style=color:#fff> </span>HashMap<span style=color:#0550ae>&lt;&gt;</span><span style=color:#1f2328>();</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span>dico<span style=color:#1f2328>.</span><span style=color:#1f2328>put</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;chat&#34;</span><span style=color:#1f2328>,</span><span style=color:#fff> </span>1<span style=color:#1f2328>);</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span>dico<span style=color:#1f2328>.</span><span style=color:#1f2328>put</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;chien&#34;</span><span style=color:#1f2328>,</span><span style=color:#fff> </span>2<span style=color:#1f2328>);</span><span style=color:#fff>
</span></span></span><span style=display:flex><span><span style=color:#fff></span>System<span style=color:#1f2328>.</span><span style=color:#1f2328>out</span><span style=color:#1f2328>.</span><span style=color:#1f2328>println</span><span style=color:#1f2328>(</span>dico<span style=color:#1f2328>.</span><span style=color:#1f2328>get</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#34;chat&#34;</span><span style=color:#1f2328>));</span><span style=color:#fff> </span><span style=color:#57606a>// Affiche 1</span><span style=color:#fff>
</span></span></span></code></pre></div><p>Les tables de hachage sont omniprésentes en informatique car elles rendent possible la recherche rapide dans de grands ensembles de données.</p><p>Imaginons que l’on souhaite stocker un ensemble de chaînes de caractères de différentes longueurs, par exemple « chat », « chien », « girafe », « lion ». Pour retrouver rapidement une chaîne, on peut utiliser une table de hachage où la fonction de hachage choisie est simplement la longueur de la chaîne. Ainsi, « chat » (4 lettres) sera stocké à l’indice 4, « chien » (5 lettres) à l’indice 5, « girafe » (6 lettres) à l’indice 6, et ainsi de suite. Pour rechercher une chaîne, il suffit de calculer sa longueur et d’aller directement à l’indice correspondant dans le tableau. Cette opération ne dépend pas du nombre total de chaînes stockées, ce qui explique pourquoi la recherche est dite « en temps constant » : on ne parcourt pas toute la table, on accède directement à la bonne case.</p><p>Cependant, ce choix de fonction de hachage est très simple et peut provoquer des « collisions » : deux chaînes de même longueur, comme « lion » et « chat », auraient le même indice. Dans ce cas, il faut une méthode pour gérer ces collisions, par exemple en stockant les deux chaînes dans une liste à cet indice. En pratique, les tables de hachage utilisent des fonctions de hachage beaucoup plus sophistiquées, capables de transformer n’importe quelle clé (texte, nombre, etc.) en un indice réparti de façon plus uniforme dans le tableau. L’objectif reste toujours de minimiser les collisions, car tant qu’il y en a peu, la recherche, l’insertion et la suppression restent très rapides et efficaces, même avec de très grands ensembles de données.</p><h3 id=un-problème-résoluble-en--ou-en>Un problème résoluble en \( O(n^2) \) ou en \( O(n) \)
<a class=anchor href=#un-probl%c3%a8me-r%c3%a9soluble-en--ou-en>#</a></h3><p>Prenons le problème suivant : « Trouver s’il existe deux éléments dans un tableau qui, additionnés, donnent une valeur cible. »</p><p><strong>Solution naïve (\( O(n^2) \)) :</strong></p><pre tabindex=0><code class=language-pseudo data-lang=pseudo>POUR i de 0 à n-1
    POUR j de i+1 à n-1
        SI tableau[i] + tableau[j] == cible
            retourner VRAI
        FIN SI
    FIN POUR
FIN POUR
retourner FAUX
</code></pre><p>Ici, on teste toutes les paires possibles, ce qui prend un temps quadratique.</p><p><strong>Solution optimisée (\( O(n) \)) :</strong></p><p>On peut résoudre ce problème en temps linéaire en utilisant une structure de données comme un ensemble (set) :</p><pre tabindex=0><code class=language-pseudo data-lang=pseudo>initialiser un ensemble vide
POUR chaque élément x du tableau
    SI (cible - x) est dans l’ensemble
        retourner VRAI
    AJOUTER x à l’ensemble
FIN POUR
retourner FAUX
</code></pre><p>Ici, chaque élément est traité une seule fois, et si la recherche dans l’ensemble se fait en temps constant (en moyenne) ou \( O(1) \), la solution est en \( O(n) \).
Dans la solution optimisée, la vérification « (cible - x) est dans l’ensemble » est cruciale.
Il n&rsquo;est pas garanti que la recherche se fasse en temps \( O(1) \), mais c&rsquo;est possible avec
une table de hachage.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/ifvpTzpA59s?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#notation-grand-o>Notation grand-O</a></li><li><a href=#exemples-dalgorithmes-en>Exemples d’algorithmes en</a></li><li><a href=#exemples-dalgorithmes-en-1>Exemples d’algorithmes en</a></li><li><a href=#recherche-dans-un-tableau-trié>Recherche dans un tableau trié</a></li><li><a href=#tri>Tri</a></li><li><a href=#table-de-hachage>Table de hachage</a></li><li><a href=#un-problème-résoluble-en--ou-en>Un problème résoluble en ou en</a></li></ul></li></ul></nav></div></aside></main></body></html>