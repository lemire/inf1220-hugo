<!doctype html><html lang=fr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Les problèmes difficiles
  #


Dans ce cours, vous n&rsquo;avez pas à maîtriser la notion de problème difficile, mais vous devriez être familier avec le concept.

Dans un cours d’introduction à la programmation, la plupart des exercices se concentrent sur des problèmes dont les algorithmes sont relativement simples à concevoir, surtout si vous maîtrisez les bases de la programmation et des mathématiques. Ces problèmes, comme calculer une moyenne ou trier une liste, demandent souvent une compréhension des structures de contrôle (conditions et boucles) et une application directe de concepts logiques. Cependant, dans des contextes plus avancés, certains problèmes se révèlent bien plus complexes, non pas à cause de la programmation elle-même, mais en raison de la difficulté à trouver un algorithme efficace. Ces défis, qualifiés de « problèmes difficiles », nécessitent des approches créatives et parfois des compromis, car leurs solutions idéales peuvent être hors de portée avec les ressources informatiques actuelles."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lemire.github.io/inf1220-hugo/docs/modules/module1/difficile/"><meta property="og:site_name" content="INF 1220 - Introduction à la programmation"><meta property="og:title" content="Les problèmes difficiles"><meta property="og:description" content="Les problèmes difficiles # Dans ce cours, vous n’avez pas à maîtriser la notion de problème difficile, mais vous devriez être familier avec le concept.
Dans un cours d’introduction à la programmation, la plupart des exercices se concentrent sur des problèmes dont les algorithmes sont relativement simples à concevoir, surtout si vous maîtrisez les bases de la programmation et des mathématiques. Ces problèmes, comme calculer une moyenne ou trier une liste, demandent souvent une compréhension des structures de contrôle (conditions et boucles) et une application directe de concepts logiques. Cependant, dans des contextes plus avancés, certains problèmes se révèlent bien plus complexes, non pas à cause de la programmation elle-même, mais en raison de la difficulté à trouver un algorithme efficace. Ces défis, qualifiés de « problèmes difficiles », nécessitent des approches créatives et parfois des compromis, car leurs solutions idéales peuvent être hors de portée avec les ressources informatiques actuelles."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Les problèmes difficiles | INF 1220 - Introduction à la programmation</title><link rel=icon href=/inf1220-hugo/favicon.png><link rel=manifest href=/inf1220-hugo/manifest.json><link rel=canonical href=https://lemire.github.io/inf1220-hugo/docs/modules/module1/difficile/><link rel=stylesheet href=/inf1220-hugo/book.min.a006656c8516e75b9916bf87553cdae09b7d022a0ef8c51fcafcb935e4e3d410.css integrity="sha256-oAZlbIUW51uZFr+HVTza4Jt9AioO+MUfyvy5NeTj1BA=" crossorigin=anonymous><script defer src=/inf1220-hugo/fuse.min.js></script><script defer src=/inf1220-hugo/fr.search.min.45d426c1d447f174d2050b16eb712b4acc23f81efadb17d7dfdc38924cbfda93.js integrity="sha256-RdQmwdRH8XTSBQsW63ErSswj+B762xfX39w4kky/2pM=" crossorigin=anonymous></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/inf1220-hugo/><img src=/inf1220-hugo/livre.jpg alt=Logo class=book-icon><span>INF 1220 - Introduction à la programmation</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Rechercher aria-label=Rechercher maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><a href=/inf1220-hugo/docs/environnement/>Programmation Java en ligne</a></li><li><a href=/inf1220-hugo/docs/erreurs/>Vous avez trouvé une erreur?</a></li><li><a href=/inf1220-hugo/docs/modules/>Modules</a><ul><li><input type=checkbox id=section-6ffbdc93c5edebe8ae6289c754c6323e class=toggle checked>
<label for=section-6ffbdc93c5edebe8ae6289c754c6323e class=flex><a href=/inf1220-hugo/docs/modules/module1/ class=flex-auto>Module 1: Algorithme et pseudocode</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module1/teluq/>Modèle du cours</a></li><li><a href=/inf1220-hugo/docs/modules/module1/robot/>Robot conversationnel et intelligence artificielle</a></li><li><a href=/inf1220-hugo/docs/modules/module1/autoevaluation/>Autoévaluation</a></li><li><a href=/inf1220-hugo/docs/modules/module1/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module1/ordinateurs/>Les ordinateurs et leurs langages</a></li><li><a href=/inf1220-hugo/docs/modules/module1/algorithmes/>Les algorithmes</a></li><li><a href=/inf1220-hugo/docs/modules/module1/algorithmes2/>Les algorithmes : conception et syntaxe</a></li><li><a href=/inf1220-hugo/docs/modules/module1/algorithmes3/>Les algorithmes: les structures de contrôle</a></li><li><a href=/inf1220-hugo/docs/modules/module1/difficile/ class=active>Les problèmes difficiles</a></li><li><a href=/inf1220-hugo/docs/modules/module1/complex/>Complexité algorithmique</a></li><li><a href=/inf1220-hugo/docs/modules/module1/erreurs/>Les erreurs communes</a></li><li><a href=/inf1220-hugo/docs/modules/module1/exercices/>Exercices sur les algorithmes</a></li><li><a href=/inf1220-hugo/docs/modules/module1/travail-note-1/>Travail noté 1</a></li></ul></li><li><input type=checkbox id=section-71b9dfc90da9a83f173743029715be7a class=toggle>
<label for=section-71b9dfc90da9a83f173743029715be7a class=flex><a href=/inf1220-hugo/docs/modules/module2/ class=flex-auto>Module 2: Introduction au langage Java</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module2/preparation/>Préparation de l’espace de travail</a></li><li><a href=/inf1220-hugo/docs/modules/module2/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module2/oriente/>Création d'une classe en Java</a></li><li><a href=/inf1220-hugo/docs/modules/module2/typeoperateur/>Introduction aux types de base et à leurs opérateurs</a></li><li><a href=/inf1220-hugo/docs/modules/module2/exercices-2-1/>Exercices sur les classes, les variables, les types et les opérateurs</a></li><li><a href=/inf1220-hugo/docs/modules/module2/methodes/>Méthodes et constructeurs</a></li><li><a href=/inf1220-hugo/docs/modules/module2/exercices-2-2/>Exercices sur les classes et méthodes</a></li><li><a href=/inf1220-hugo/docs/modules/module2/conseils/>Recommandations</a></li><li><a href=/inf1220-hugo/docs/modules/module2/travail-note-2/>Travail noté 2</a></li></ul></li><li><input type=checkbox id=section-67896e9afc9b4080d8c27b998062dd91 class=toggle>
<label for=section-67896e9afc9b4080d8c27b998062dd91 class=flex><a href=/inf1220-hugo/docs/modules/module3/ class=flex-auto>Module 3: Les structures de données, de contrôle et d'itération en Java</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module3/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module3/github/>GitHub</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-1/>Les structures de contrôle</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-2/>Les structures itératives</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-3-string/>Les chaînes de caractères (String)</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-3/>Les structures de données de base</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-3-random/>Les valeurs aléatoires</a></li><li><a href=/inf1220-hugo/docs/modules/module3/fonctionnel/>La programmation fonctionnelle en Java</a></li><li><a href=/inf1220-hugo/docs/modules/module3/exercices-3-1/>Exercices sur les structures de contrôle, les structures de données, les structures itératives</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-4/>Les exceptions</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-5/>La récursivité</a></li><li><a href=/inf1220-hugo/docs/modules/module3/exercices-3-2/>Exercices sur les exceptions et la récursivité</a></li><li><a href=/inf1220-hugo/docs/modules/module3/activite-3-3-modele/>Exemple : modèle de langue</a></li><li><a href=/inf1220-hugo/docs/modules/module3/conseils/>Recommandations</a></li><li><a href=/inf1220-hugo/docs/modules/module3/travail-note-3/>Travail noté 3</a></li></ul></li><li><input type=checkbox id=section-9087a4ffddbd9e1f0f2f4b3f8c85dcb4 class=toggle>
<label for=section-9087a4ffddbd9e1f0f2f4b3f8c85dcb4 class=flex><a href=/inf1220-hugo/docs/modules/module4/ class=flex-auto>Module 4: Les entrées et sorties</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module4/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module4/activite-4-1/>Les flux de console</a></li><li><a href=/inf1220-hugo/docs/modules/module4/activite-4-2/>Les flux de données: lecture dans des fichiers et autres</a></li><li><a href=/inf1220-hugo/docs/modules/module4/exercices-4-1/>Exercices sur les flux</a></li><li><a href=/inf1220-hugo/docs/modules/module4/web/>Développement web</a></li><li><a href=/inf1220-hugo/docs/modules/module4/travail-note-4/>Travail noté 4</a></li></ul></li><li><input type=checkbox id=section-749269b787e65f29f734b50b6282d284 class=toggle>
<label for=section-749269b787e65f29f734b50b6282d284 class=flex><a href=/inf1220-hugo/docs/modules/module5/ class=flex-auto>Module 5. La programmation orientée objet: héritage et le polymorphisme</a></label><ul><li><a href=/inf1220-hugo/docs/modules/module5/pasapas/>Java pas à pas</a></li><li><a href=/inf1220-hugo/docs/modules/module5/activite-5-1/>L'héritage, les classes abstraites et les interfaces</a></li><li><a href=/inf1220-hugo/docs/modules/module5/activite-5-2/>Le polymorphisme</a></li><li><a href=/inf1220-hugo/docs/modules/module5/exercices-5-1/>Exercices sur l’héritage et le polymorphisme</a></li><li><a href=/inf1220-hugo/docs/modules/module5/travail-note-5/>Travail noté 5</a></li></ul></li><li><a href=/inf1220-hugo/docs/modules/examen/>Examen</a></li></ul></li><li><a href=/inf1220-hugo/docs/evaluation/>Évaluation</a></li><li><a href=/inf1220-hugo/docs/pensebete/>Pense-bête java</a></li><li><input type=checkbox id=section-5cc50cb3031bd6bd7b763bb20cfb7f0e class=toggle>
<label for=section-5cc50cb3031bd6bd7b763bb20cfb7f0e class=flex><a role=button class=flex-auto>Autres ressources</a></label><ul><li><a href=/inf1220-hugo/docs/extra/credits/>Le professeur</a></li><li><a href=/inf1220-hugo/docs/extra/feuille-de-route/>Feuille de route</a></li><li><a href=/inf1220-hugo/docs/extra/ressources/>Ressources</a></li><li><a href=/inf1220-hugo/docs/extra/faq/>FAQ</a></li><li><a href=/inf1220-hugo/docs/extra/manuel/>Manuel</a></li><li><a href=/inf1220-hugo/docs/extra/math/>Rappel mathématique</a></li><li><a href=/inf1220-hugo/docs/extra/ia/>Intelligence artificielle</a></li><li><a href=/inf1220-hugo/docs/extra/courriel/>Petit guide d’usage du courriel efficace</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/inf1220-hugo/svg/menu.svg class=book-icon alt=Menu></label><h3>Les problèmes difficiles</h3><label for=toc-control><img src=/inf1220-hugo/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class="markdown book-article"><h1 id=les-problèmes-difficiles>Les problèmes difficiles
<a class=anchor href=#les-probl%c3%a8mes-difficiles>#</a></h1><blockquote class="book-hint info"><p>Dans ce cours, vous n&rsquo;avez pas à maîtriser la notion de problème difficile, mais vous devriez être familier avec le concept.</p></blockquote><p>Dans un cours d’introduction à la programmation, la plupart des exercices se concentrent sur des problèmes dont les algorithmes sont relativement simples à concevoir, surtout si vous maîtrisez les bases de la programmation et des mathématiques. Ces problèmes, comme calculer une moyenne ou trier une liste, demandent souvent une compréhension des structures de contrôle (conditions et boucles) et une application directe de concepts logiques. Cependant, dans des contextes plus avancés, certains problèmes se révèlent bien plus complexes, non pas à cause de la programmation elle-même, mais en raison de la difficulté à trouver un algorithme efficace. Ces défis, qualifiés de « problèmes difficiles », nécessitent des approches créatives et parfois des compromis, car leurs solutions idéales peuvent être hors de portée avec les ressources informatiques actuelles.</p><p>Les problèmes difficiles se rencontrent fréquemment dans des domaines comme l’intelligence artificielle, l’optimisation ou la cryptographie. Par exemple, développer une intelligence artificielle capable de rivaliser avec un grand maître aux échecs exige non seulement de programmer des règles du jeu, mais aussi de concevoir un algorithme capable d’évaluer des millions de positions possibles en un temps raisonnable. Ce type de problème est complexe, car il combine une exploration stratégique (choisir les meilleurs coups) avec des contraintes de performance (limiter le temps de calcul). De même, des problèmes d’optimisation, comme déterminer le chemin le plus court pour un livreur effectuant plusieurs arrêts, peuvent sembler simples en théorie, mais deviennent rapidement ingérables à mesure que le nombre de destinations augmente, en raison du nombre exponentiel de combinaisons possibles.</p><p>Un exemple classique de problème difficile est le problème du voyageur de commerce (TSP, pour Traveling Salesman Problem). Ce problème consiste à trouver le chemin le plus court permettant à un voyageur de visiter une liste de villes exactement une fois avant de revenir à son point de départ. Pour un petit nombre de villes, il est possible d’énumérer toutes les permutations et de calculer la distance totale de chaque trajet. Cependant, avec seulement 20 villes, le nombre de trajets possibles dépasse les milliards, rendant une approche par force brute (tester toutes les combinaisons) impraticable, même sur des ordinateurs puissants. Ce problème est dit « NP-difficile », un terme technique que les informaticiens utilisent pour désigner un problème qu&rsquo;il est difficile de résoudre rapidement en général.</p><p>Pour aborder le problème du voyageur de commerce, des algorithmes approchés, comme l’algorithme du plus proche voisin, sont souvent utilisés. Cet algorithme commence par une ville arbitraire, puis choisit à chaque étape la ville la plus proche non visitée, jusqu’à ce que toutes les villes soient incluses, avant de revenir à la ville de départ. Bien que cette méthode ne garantisse pas toujours le chemin le plus court, elle produit une solution acceptable dans un temps de calcul bien plus court que l’énumération complète. Voici un pseudocode pour cet algorithme :</p><pre tabindex=0><code>Entrées :
  Liste de villes : villes[n]
  Matrice des distances : distances[n][n]

Sorties :
  Liste ordonnée des villes : trajet

Initialiser trajet comme une liste vide
Choisir une ville de départ (par exemple, villes[0]) et l’ajouter à trajet
Marquer la ville de départ comme visitée
TANT QUE toutes les villes ne sont pas visitées FAIRE
    Trouver la ville non visitée la plus proche de la dernière ville dans trajet
    Ajouter cette ville à trajet
    Marquer cette ville comme visitée
FIN TANT QUE
Ajouter la ville de départ à la fin de trajet pour boucler
RETOURNER trajet
</code></pre><p>Ce pseudocode décrit une solution gloutonne au problème du voyageur de commerce (TSP), qui cherche un circuit visitant chaque ville d’une liste exactement une fois et revenant à la ville de départ, en minimisant la distance totale. Les entrées sont une liste de n villes (<code>villes[n]</code>) et une matrice <code>distances[n][n]</code> indiquant les distances entre chaque paire de villes. Une liste trajet est initialisée vide pour stocker l’ordre des villes. L’algorithme commence par choisir une ville de départ (par exemple, <code>villes[0]</code>), l’ajoute à trajet, et la marque comme visitée. Une boucle (TANT QUE toutes les villes ne sont pas visitées FAIRE) sélectionne à chaque étape la ville non visitée la plus proche de la dernière ville ajoutée à trajet, en consultant la matrice distances. Cette ville est ajoutée à trajet et marquée comme visitée. Une fois toutes les villes visitées, la ville de départ est ajoutée à la fin de trajet pour former un circuit fermé. La liste trajet est retournée comme résultat.</p><p>Considérons une table (fictive) des distances entre certains villes du Québec.</p><table><thead><tr><th>Ville</th><th>Montréal</th><th>Québec</th><th>Laval</th><th>Gatineau</th><th>Longueuil</th></tr></thead><tbody><tr><td>Montréal</td><td>-</td><td>250</td><td>20</td><td>200</td><td>15</td></tr><tr><td>Québec</td><td>250</td><td>-</td><td>240</td><td>450</td><td>245</td></tr><tr><td>Laval</td><td>20</td><td>240</td><td>-</td><td>210</td><td>30</td></tr><tr><td>Gatineau</td><td>200</td><td>450</td><td>210</td><td>-</td><td>210</td></tr><tr><td>Longueuil</td><td>15</td><td>245</td><td>30</td><td>210</td><td>-</td></tr></tbody></table><p>Vous pouvez vérifier que le trajet suivant représente 910 km.</p><p>Montréal -> Gatineau -> Laval -> Québec -> Longueuil -> Montréal</p><p>Maintenant, exécutez l&rsquo;algorithme du plus proche voisin avec l&rsquo;application suivante :</p><div><div id=tsp-app-container style="font-family:inter,-apple-system,BlinkMacSystemFont,segoe ui,Roboto,sans-serif;background-color:#f7fafc;color:#2d3748;padding:16px;display:flex;align-items:center;justify-content:center;isolation:isolate"><div style="background-color:#fff;box-shadow:0 10px 15px rgba(0,0,0,.1);border-radius:8px;padding:24px;max-width:960px;width:100%;margin:32px auto"><h2 style=font-size:24px;font-weight:700;text-align:center;color:#2b6cb0;margin-bottom:24px>Problème du voyageur de commerce (TSP)</h2><div style=margin-bottom:24px><h3 style=font-size:20px;font-weight:600;color:#4a5568;margin-bottom:12px>Pseudocode (Approche du plus proche voisin)</h3><pre id=tsp-pseudocode style="background-color:#edf2f7;padding:16px;border-radius:6px;font-size:14px;font-family:courier new,Courier,monospace;color:#1a202c;overflow:auto;white-space:pre-wrap">
Entrées :
  Liste de villes : villes[n]
  Matrice des distances : distances[n][n]

Sorties :
  Liste ordonnée des villes : trajet

Initialiser trajet comme une liste vide
Choisir une ville de départ aléatoire et l’ajouter à trajet
Marquer la ville de départ comme visitée
TANT QUE toutes les villes ne sont pas visitées FAIRE
    Trouver la ville non visitée la plus proche de la dernière ville dans trajet
    Ajouter cette ville à trajet
    Marquer cette ville comme visitée
FIN TANT QUE
Ajouter la ville de départ à la fin de trajet pour boucler
RETOURNER trajet, Distance totale
            </pre></div><div style=margin-bottom:24px;overflow-x:auto><h3 style=font-size:20px;font-weight:600;color:#4a5568;margin-bottom:12px>Tableau des distances (km)</h3><table id=tsp-distance-table style=width:100%;border-collapse:collapse;border-radius:8px;overflow:hidden><thead><tr style=background-color:#2b6cb0;color:#fff><th style="padding:12px;border-right:1px solid #2c5282;font-weight:500">Ville</th><th style="padding:12px;border-right:1px solid #2c5282;font-weight:500">Montréal</th><th style="padding:12px;border-right:1px solid #2c5282;font-weight:500">Québec</th><th style="padding:12px;border-right:1px solid #2c5282;font-weight:500">Laval</th><th style="padding:12px;border-right:1px solid #2c5282;font-weight:500">Gatineau</th><th style="padding:12px;border-right:1px solid #2c5282;font-weight:500">Longueuil</th></tr></thead><tbody><tr style=background-color:#f7fafc><td style="padding:8px;border:1px solid #e2e8f0;font-weight:500">Montréal</td><td style="padding:8px;border:1px solid #e2e8f0">-</td><td style="padding:8px;border:1px solid #e2e8f0">250</td><td style="padding:8px;border:1px solid #e2e8f0">20</td><td style="padding:8px;border:1px solid #e2e8f0">200</td><td style="padding:8px;border:1px solid #e2e8f0">15</td></tr><tr style=background-color:#fff><td style="padding:8px;border:1px solid #e2e8f0;font-weight:500">Québec</td><td style="padding:8px;border:1px solid #e2e8f0">250</td><td style="padding:8px;border:1px solid #e2e8f0">-</td><td style="padding:8px;border:1px solid #e2e8f0">240</td><td style="padding:8px;border:1px solid #e2e8f0">450</td><td style="padding:8px;border:1px solid #e2e8f0">245</td></tr><tr style=background-color:#f7fafc><td style="padding:8px;border:1px solid #e2e8f0;font-weight:500">Laval</td><td style="padding:8px;border:1px solid #e2e8f0">20</td><td style="padding:8px;border:1px solid #e2e8f0">240</td><td style="padding:8px;border:1px solid #e2e8f0">-</td><td style="padding:8px;border:1px solid #e2e8f0">210</td><td style="padding:8px;border:1px solid #e2e8f0">30</td></tr><tr style=background-color:#fff><td style="padding:8px;border:1px solid #e2e8f0;font-weight:500">Gatineau</td><td style="padding:8px;border:1px solid #e2e8f0">200</td><td style="padding:8px;border:1px solid #e2e8f0">450</td><td style="padding:8px;border:1px solid #e2e8f0">210</td><td style="padding:8px;border:1px solid #e2e8f0">-</td><td style="padding:8px;border:1px solid #e2e8f0">210</td></tr><tr style=background-color:#f7fafc><td style="padding:8px;border:1px solid #e2e8f0;font-weight:500">Longueuil</td><td style="padding:8px;border:1px solid #e2e8f0">15</td><td style="padding:8px;border:1px solid #e2e8f0">245</td><td style="padding:8px;border:1px solid #e2e8f0">30</td><td style="padding:8px;border:1px solid #e2e8f0">210</td><td style="padding:8px;border:1px solid #e2e8f0">-</td></tr></tbody></table></div><div style=display:flex;justify-content:center;gap:16px;margin-bottom:24px><button id=tsp-next-btn style="padding:12px 24px;background-color:#2b6cb0;color:#fff;font-weight:600;border-radius:6px;box-shadow:0 4px 6px rgba(0,0,0,.1);border:none;cursor:pointer;transition:background-color .3s">Commencer</button>
<button id=tsp-reset-btn style="padding:12px 24px;background-color:#4a5568;color:#fff;font-weight:600;border-radius:6px;box-shadow:0 4px 6px rgba(0,0,0,.1);border:none;cursor:pointer;transition:background-color .3s">Réinitialiser</button></div><div style="background-color:#ebf8ff;padding:16px;border-radius:6px;border:1px solid #bee3f8"><h3 style=font-size:18px;font-weight:600;color:#2c5282;margin-bottom:8px>État actuel</h3><p id=tsp-message style=color:#1a202c;margin-bottom:8px>Cliquez sur 'Commencer' pour commencer l'initialisation.</p><p id=tsp-step style=color:#1a202c;margin-bottom:8px>Étape : 0</p><p id=tsp-trajet style=color:#1a202c;margin-bottom:8px>Trajet actuel :</p><p id=tsp-distance style=color:#1a202c>Distance totale parcourue : 0 km</p></div></div></div><script>const TSPApp=function(){const t=["Montréal","Québec","Laval","Gatineau","Longueuil"],h=[[0,250,20,200,15],[250,0,240,450,245],[20,240,0,210,30],[200,450,210,0,210],[15,245,30,210,0]];let i=[],l=new Array(t.length).fill(!1),e=-1,a=-1,r=0,s=0,c=!1;const _=["Entrées :","  Liste de villes : villes[n]","  Matrice des distances : distances[n][n]","","Sorties :","  Liste ordonnée des villes : trajet","","Initialiser trajet comme une liste vide","Choisir une ville de départ aléatoire et l’ajouter à trajet","Marquer la ville de départ comme visitée","TANT QUE toutes les villes ne sont pas visitées FAIRE","    Trouver la ville non visitée la plus proche de la dernière ville dans trajet","    Ajouter cette ville à trajet","    Marquer cette ville comme visitée","FIN TANT QUE","Ajouter la ville de départ à la fin de trajet pour boucler","RETOURNER trajet, Distance totale"],o=document.getElementById("tsp-next-btn"),j=document.getElementById("tsp-reset-btn"),n=document.getElementById("tsp-message"),u=document.getElementById("tsp-step"),m=document.getElementById("tsp-trajet"),f=document.getElementById("tsp-distance"),y=document.getElementById("tsp-pseudocode"),p=document.getElementById("tsp-distance-table");function g(){const e={0:7,1:8,2:9,3:10,4:11,5:12,6:13,7:15,8:16},t=e[s]||-1;y.innerHTML=_.map((e,n)=>n+1===t?`<span style="background-color: #fefcbf; padding: 2px 4px; border-radius: 4px;">${e}</span>`:e).join(`
`)}function v(){const t=p.querySelectorAll("tbody tr"),n=p.querySelectorAll("thead th");if(e===-1){t.forEach(e=>{e.querySelectorAll("td").forEach(e=>{e.style.backgroundColor=""})}),n.forEach(e=>{e.style.backgroundColor="#2b6cb0"});return}e!==-1&&!c&&(n[e+1]&&(n[e+1].style.backgroundColor="#9ae6b4"),t[e]&&t[e].querySelectorAll("td").forEach((e)=>{e.style.backgroundColor="#fefcbf"}),t.forEach((t)=>{const s=t.querySelectorAll("td")[e+1];s&&(s.style.backgroundColor="#fefcbf")}))}function d(){i=[],l=new Array(t.length).fill(!1),e=-1,a=-1,r=0,s=0,c=!1,n.textContent="Cliquez sur 'Commencer' pour commencer l'initialisation.",u.textContent=`Étape : 0`,m.textContent=`Trajet actuel : `,f.textContent=`Distance totale parcourue : 0 km`,o.textContent="Commencer",o.disabled=!1,v(),g()}function b(){if(c){n.textContent=`Algorithme terminé. Trajet final : ${i.join(" → ")}. Distance totale : ${r} km. Cliquez sur 'Réinitialiser' pour recommencer.`,o.disabled=!0;return}switch(s){case 0:i=[],l=new Array(t.length).fill(!1),n.textContent="Le trajet est initialisé. Prêt à choisir une ville de départ.",s=1,o.textContent="Suivant";break;case 1:a=Math.floor(Math.random()*t.length),i.push(t[a]),e=a,n.textContent=`Ville de départ choisie aléatoirement : ${t[a]}.`,s=2;break;case 2:l[e]=!0,n.textContent=`Ville de départ (${t[e]}) marquée comme visitée.`,s=3;break;case 3:i.length===t.length?(n.textContent="Toutes les villes ont été visitées. Ajout de la ville de départ pour boucler le trajet.",s=7):(n.textContent="Toutes les villes ne sont pas encore visitées. Recherche de la ville la plus proche.",s=4);break;case 4:let u=1/0,m=-1;for(let n=0;n<t.length;n++)if(!l[n]){const t=h[e][n];t<u&&(u=t,m=n)}if(m===-1){n.textContent="Erreur: Aucune ville non visitée trouvée. L'algorithme est bloqué. Réinitialisez.",c=!0,o.textContent="Terminé",o.disabled=!0;break}o.dataset.nextCityIdx=m,o.dataset.minD=u,n.textContent=`La ville la plus proche de ${t[e]} est ${t[m]} (distance ${u} km).`,s=5;break;case 5:const f=parseInt(o.dataset.nextCityIdx),g=parseInt(o.dataset.minD);i.push(t[f]),r+=g,e=f,n.textContent=`Ajout de ${t[f]} au trajet. Distance cumulée : ${r} km.`,s=6;break;case 6:l[e]=!0,n.textContent=`Ville ${t[e]} marquée comme visitée.`,s=3;break;case 7:const p=h[e][a];i.push(t[a]),r+=p,n.textContent=`Retour à la ville de départ (${t[a]}) pour boucler (distance ${p} km).`,s=8;break;case 8:c=!0,n.textContent=`Algorithme terminé. Trajet final : ${i.join(" → ")}. Distance totale : ${r} km.`,o.textContent="Terminé",o.disabled=!0;break;default:n.textContent="État inconnu. Réinitialisation.",d();break}u.textContent=`Étape : ${s}`,m.textContent=`Trajet actuel : ${i.join(" → ")}`,f.textContent=`Distance totale parcourue : ${r} km`,v(),g()}return o.addEventListener("click",b),j.addEventListener("click",d),d(),{initialize:d,nextStep:b}}()</script></div><p>Pouvez-vous obtenir une distance aussi courte que 910 km ;? Comment pourriez-vous modifier
le pseudocode pour obtenir toujours la distance la plus courte ? C&rsquo;est une question difficile.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/yqH11OHfN2U?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>Cet exemple d&rsquo;algorithme est un algorithme glouton.
Un algorithme glouton est une méthode algorithmique qui résout un problème en faisant à chaque étape le choix localement optimal, dans l’espoir que ces choix mènent à une solution globale optimale. Il privilégie la simplicité et la rapidité, mais ne garantit pas toujours la meilleure solution pour tous les problèmes, car il ne revient jamais en arrière pour réévaluer les décisions prises. Ce type d’algorithme est souvent utilisé pour des problèmes d’optimisation où une solution approximative est acceptable ou lorsque le problème possède une structure particulière, comme la propriété de sous-structure optimale ou la propriété gloutonne.</p><p>Considérons d&rsquo;autres exemples de l&rsquo;approche gloutonne.</p><ul><li>Suppose que nous disposions d’un sac à dos de capacité limitée et d’objets ayant chacun un poids et une valeur. L’objectif est de maximiser la valeur totale des objets dans le sac, en autorisant des fractions d’objets. L&rsquo;approche gloutonne dans ce cas consiste à d&rsquo;abord trier les objets par rapport décroissant de leur rapport valeur/poids. Ensuite, il faut remplir le sac en prenant autant que possible de chaque objet dans cet ordre jusqu’à atteindre la capacité.</li><li>Suppose que nous disposions d’un ensemble d’activités avec des heures de début et de fin, et l’objectif est de sélectionner le plus grand nombre d’activités compatibles (qui ne se chevauchent pas). Une approche gloutonne consiste à trier les activités par heure de fin croissante. Sélectionner la première activité, puis la prochaine activité compatible, et ainsi de suite.</li></ul><p>Les approches gloutonnes donnent généralement une solution qui n&rsquo;est pas optimale.</p><p>Dans le cadre de ce cours, vous ne serez pas confronté à des problèmes aussi complexes que le voyageur de commerce. Les exercices proposés viseront à renforcer votre compréhension des bases algorithmiques, comme les boucles, les conditions et la manipulation de données simples. Cependant, il est utile de connaître l’existence de ces problèmes difficiles pour apprécier la profondeur de l’informatique. Ils illustrent l’importance de l’efficacité algorithmique et des compromis dans la conception de solutions. En explorant des cas plus simples, vous poserez les fondations nécessaires pour, un jour, peut-être, relever ces défis plus ardus.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"><a href=/inf1220-hugo/docs/modules/module1/algorithmes3/ class="flex align-center float-left book-icon"><img src=/inf1220-hugo/svg/backward.svg alt=Previous title="Les algorithmes: les structures de contrôle">
<span>Les algorithmes: les structures de contrôle</span>
</a><a href=/inf1220-hugo/docs/modules/module1/complex/ class="flex align-center float-right book-icon"><span>Complexité algorithmique</span>
<img src=/inf1220-hugo/svg/forward.svg alt=Next title="Complexité algorithmique"></a></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents></nav></div></aside></main></body></html>